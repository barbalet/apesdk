/* Autogenerated combined source file */
/* ./toolkit/file.c */
/****************************************************************

 file.c

 =============================================================



 ****************************************************************/

/*! \file   n_file.c
 *  \brief  Covers the low level input and output relating to files.
 */

#define CONSOLE_REQUIRED


#include "toolkit.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>



#define CHAR_TAB                 (9)

/* this is v2 of the file parsing, v3 is soon to be implemented through the scripting interface */
#define CHAR_EOF                    0

#define IS_TAB(val)               ((val) == CHAR_TAB)
#define    IS_WHITE_HORIZON(val)      (IS_TAB(val)  || IS_SPACE(val))
#define    IS_WHITE_SPACE(val)          (IS_WHITE_HORIZON((val))||IS_RETURN((val)))
#define FILE_END_INCLUSION        0x0101
#define    FILE_TYPE(num)              ((num)&0x07)
#define    FILE_CONTINUATION          0x80



/**
 * Allocates a new file.
 * @return a 4k worth of data file pointer.
 */
n_file *io_file_new( void )
{
    n_file *output = memory_new( sizeof( n_file ) );
    if ( output == 0L )
    {
        return 0L;
    }
    output->size = STRING_BLOCK_SIZE;
    output->data = memory_new( STRING_BLOCK_SIZE );
    if ( output->data == 0L )
    {
        memory_free( ( void ** )&output );
        return 0L;
    }
    output->location = 0;
    return output;
}

n_file * io_file_new_from_string_block(n_string_block contents)
{
    n_file * new_file = io_file_new();
    if (new_file)
    {
        memory_copy((n_byte*)contents, (n_byte*)new_file->data, STRING_BLOCK_SIZE);
        new_file->location = io_length((n_string)contents, STRING_BLOCK_SIZE);
    }
    return new_file;
}

n_file * io_file_new_from_string(n_string string, n_uint string_length)
{
    n_file *output = memory_new( sizeof( n_file ) );
    if ( output == 0L )
    {
        return 0L;
    }
    output->size = string_length * 2;
    output->data = memory_new( string_length * 2 );
    if ( output->data == 0L )
    {
        memory_free( ( void ** )&output );
        return 0L;
    }
    output->location = 0;

    memory_copy((n_byte*)string, (n_byte*)output->data, string_length);

    return output;
}


/// Frees the file pointer
/// - Parameter file: the pointer to be freed.
void io_file_free( n_file **file )
{
    if ( file != 0L )
    {
        if ( ( *file )->data )
        {
            memory_free( ( void ** ) & ( ( *file )->data ) );
        }
    }
    memory_free( ( void ** )file );
}

/// Turn ``n_int`` value to ``n_byte`` value
/// - Parameter value: integer value
/// - Parameter bytes: byte pointer
void io_int_to_bytes( n_int value, n_byte *bytes )
{
    memory_copy( ( n_byte * )&value, bytes, sizeof( n_int ) );
}

/// Turn ``n_byte`` to ``n_int`` value.
/// - Parameter bytes: byte pointer
/// - Returns: integer value
n_int io_bytes_to_int( n_byte *bytes )
{
    /*n_uint unsigned_value;*/
    n_int return_value;

    memory_copy( bytes, ( n_byte * )&return_value, sizeof( n_int ) );
    return return_value;
}

/// Takes a file and hashes it based on the file size.
/// - Parameter local_file: The local file pointer.
/// - Returns: unsigned integer hash value.
n_uint io_file_hash( n_file *local_file )
{
    n_uint hash = math_hash( ( n_byte * )&local_file->location, sizeof( n_uint ) );
    hash ^= math_hash( ( n_byte * )&local_file->size, sizeof( n_uint ) );
    hash ^= math_hash( local_file->data, local_file->size );
    return hash;
}

/// Reads a file from disk.
/// - Parameter local_file: the pointer to the n_file data that will have the file stored in it.
/// - Parameter file_name: the name of the file to be read.
/// - Returns: FILE_ERROR if there is a problem and FILE_OKAY if it is successful.
static n_int io_disk_read_error( n_file *local_file, n_string file_name, n_byte error_show )
{
    n_uint file_size;
#ifndef _WIN32
    FILE *in_file = fopen( file_name, "rb" );
#else
    FILE *in_file = 0L;
    fopen_s( &in_file, file_name, "rb" );
#endif
    if ( in_file == 0L )
    {
        if ( error_show )
        {
            return SHOW_ERROR( "File does not exist" );
        }
        return -1;
    }

    fseek( in_file, 0L, SEEK_END );
    file_size = ftell( in_file );
    fseek( in_file, 0L, SEEK_SET );

    memory_free( ( void ** )&local_file->data );

    local_file->data = memory_new( file_size * 2 );
    if ( local_file->data == 0L )
    {
        if ( error_show )
        {
            return SHOW_ERROR( "File data could not be allocated" );
        }
        return -1;
    }

    memory_erase( local_file->data, file_size * 2 );

    fread( local_file->data, 1, file_size, in_file );

    local_file->size = file_size * 2;
    local_file->location = file_size;

    fclose( in_file );
    return FILE_OKAY;
}

///Reads a file from disk.
/// - Parameter local_file: the pointer to the n_file data that will have the file stored in it.
/// - Parameter file_name: the name of the file to be read.
/// - Returns: FILE_ERROR if there is a problem and FILE_OKAY if it is successful.
n_int io_disk_read( n_file *local_file, n_string file_name )
{
    return io_disk_read_error( local_file, file_name, 1 );
}

n_int io_disk_read_no_error( n_file *local_file, n_string file_name )
{
    return io_disk_read_error( local_file, file_name, 0 );
}


///Writes a file to disk.
/// - Parameter local_file: the pointer to the n_file data that is written to disk.
/// - Parameter file_name: the name of the file to be written.
/// - Returns: FILE_ERROR if there is a problem and FILE_OKAY if it is successful.
n_int io_disk_write( n_file *local_file, n_constant_string file_name )
{
    n_uint written_length;
    FILE *out_file = 0L;
#ifndef _WIN32
    out_file = fopen( file_name, "wb" );
#else
    fopen_s( &out_file, file_name, "wb" );
#endif
    if ( out_file == 0L )
    {
        return SHOW_ERROR( "Error opening file to write" );
    }
    if ( local_file->data == 0L )
    {
        return SHOW_ERROR( "No data in file to be written" );
    }

    written_length = fwrite( local_file->data, 1, local_file->location, out_file );

    if ( fclose( out_file ) != 0 )
    {
        return SHOW_ERROR( "File could not be closed" );
    }

    if ( written_length != local_file->location )
    {
        return SHOW_ERROR( "File did not complete write" );
    }
    return FILE_OKAY;
}


///Appends a file to disk.
/// - Parameter file_name: the name of the file to be appended.
/// - Returns: FILE_ERROR if there is a problem and FILE_OKAY if it is successful.
n_int io_disk_check( n_constant_string file_name )
{
#ifndef _WIN32
    FILE *local_check_file = fopen( file_name, "rb" );
#else
    FILE *local_check_file = 0L;

    fopen_s( &local_check_file, file_name, "rb" );
#endif

    if ( local_check_file == 0L )
    {
        return 0;
    }

    if ( fclose( local_check_file ) != 0 )
    {
        return 0;
    }
    return 1;
}


///Reads binary data from the file pointer.
/// - Parameter fil: the pointer to the n_file data that is read from.
/// - Parameter local_byte: the single byte.
/// - Returns: FILE_ERROR if there is a problem and FILE_OKAY if it is successful.
n_int io_read_bin( n_file *fil, n_byte *local_byte )
{
    n_uint    file_location = fil -> location;
    if ( file_location >= ( fil -> size ) )
    {
        return -1;
    }

    *local_byte = fil -> data[file_location];
    fil->location = ( file_location + 1 );
    return 0;
}

///Reads a character - white-space and comments have already been removed
/// - Parameter fil: the pointer to the n_file data that is read from.
/// - Returns: CHAR_EOF if there is a problem and the byte value if it is successful.
static n_byte    io_read( n_file *fil )
{
    n_byte val = 0;
    if ( io_read_bin( fil, &val ) == -1 )
    {
        return ( CHAR_EOF );
    }
    return ( val );
}

///Converts a tab delimited file to a series of string pointers
/// - Parameter tab_file: the pointer to the n_file data that is read from.
/// - Parameter size_value: the pointer to the total number.
/// - Parameter row_value: the pointer to the number of columns per row.
/// - Returns: string pointers.
n_string *io_tab_delimit_to_n_string_ptr( n_file *tab_file, n_int *size_value, n_int *row_value )
{
    n_int              string_point_location = 1;
    n_int              first_value = 0;
    n_uint             loop = 0;
    n_string          *string_point;
    n_int              local_row_value = 0;
    n_byte             resultant_value;

    if ( tab_file->location != 0 )
    {
        while ( loop < tab_file->location )
        {
            resultant_value = tab_file->data[loop];
            if ( IS_TAB( resultant_value ) || IS_RETURN( resultant_value ) )
            {
                tab_file->data[loop] = 0;
                first_value = 1;
                if ( ( local_row_value == 0 ) && IS_RETURN( resultant_value ) )
                {
                    local_row_value = string_point_location;
                }
            }
            else
            {
                if ( first_value )
                {
                    string_point_location++;
                    first_value = 0;
                }
            }
            loop ++;
        }
    }

    if ( size_value != 0L )
    {
        *size_value = string_point_location;
    }

    if ( row_value != 0L )
    {
        *row_value = local_row_value;
    }

    if ( tab_file->location == 0 )
    {
        return 0L;
    }

    if ( ( string_point = ( n_string * )memory_new( string_point_location * sizeof( n_string * ) ) ) == 0L )
    {
        return 0L;
    }

    string_point_location = 0;
    first_value = 0;
    loop = 0;

    string_point[string_point_location++] = ( n_string ) & ( tab_file->data[0] );
    while ( loop < tab_file->location )
    {
        resultant_value = tab_file->data[loop];
        if ( ( first_value ) && ( resultant_value != 0 ) )
        {
            string_point[string_point_location++] = ( n_string ) & ( tab_file->data[loop] );
            first_value = 0;
        }
        if ( resultant_value == 0 )
        {
            first_value = 1;
        }
        loop ++;
    }

    return string_point;
}

///Appends a file to disk.
/// - Parameter local_file: the pointer to the n_file data that is written to disk.
/// - Parameter file_name: the name of the file to be appended.
/// - Returns: FILE_ERROR if there is a problem and FILE_OKAY if it is successful.

# ifdef APESDK_OLD_CODE

static n_int io_disk_append( n_file *local_file, n_string file_name )
{
    n_uint written_length;
#ifndef _WIN32
    FILE *out_file = fopen( file_name, "a" );
#else
    FILE *out_file = 0L;

    fopen_s( &out_file, file_name, "a" );
#endif

    written_length = fwrite( local_file->data, 1, local_file->location, out_file );

    if ( fclose( out_file ) != 0 )
    {
        return SHOW_ERROR( "File could not be closed" );
    }

    if ( written_length != local_file->location )
    {
        return SHOW_ERROR( "File did not complete write" );
    }
    return FILE_OKAY;
}


/// Adds XML open to the named string.
/// - Parameter file: the pointer to the n_file data that is written.
/// - Parameter name: the string that is wrapped.
/// - Returns: FILE_ERROR if there is a problem and FILE_OKAY if it is successful.
static n_int io_file_xml_open( n_file *file, n_string name )
{
    if ( io_write( file, "<", 0 ) == -1 )
    {
        return -1;
    }
    if ( io_write( file, name, 0 ) == -1 )
    {
        return -1;
    }
    if ( io_write( file, ">", 1 ) == -1 )
    {
        return -1;
    }
    return 0;
}


///Adds XML close to the named string.
/// - Parameter file: the pointer to the n_file data that is written.
/// - Parameter name: the string that is wrapped.
/// - Returns: if there is a problem and FILE_OKAY if it is successful.
static n_int io_file_xml_close( n_file *file, n_string name )
{
    if ( io_write( file, "</", 0 ) == -1 )
    {
        return -1;
    }
    if ( io_write( file, name, 0 ) == -1 )
    {
        return -1;
    }
    if ( io_write( file, ">", 1 ) == -1 )
    {
        return -1;
    }
    return 0;
}

///Wraps a string with XML open and close
/// - Parameter file: the pointer to the n_file data that is written.
/// - Parameter name: the string that is the wrapper.
/// - Parameter string: the string that is wrapped.
/// - Returns: FILE_ERROR if there is a problem and FILE_OKAY if it is successful.
static n_int io_file_xml_string( n_file *file, n_string name, n_string string )
{
    if ( io_file_xml_open( file, name ) == -1 )
    {
        return -1;
    }
    if ( io_write( file, string, 0 ) == -1 )
    {
        return -1;
    }
    if ( io_file_xml_close( file, name ) == -1 )
    {
        return -1;
    }
    return 0;
}

///Wraps an integer with XML open and close
/// - Parameter file: the pointer to the n_file data that is written.
/// - Parameter name: the string that is the wrapper.
/// - Parameter number: the integer that is wrapped.
/// - Returns: FILE_ERROR if there is a problem and FILE_OKAY if it is successful.
static n_int io_file_xml_int( n_file *file, n_string name, n_int number )
{
    if ( io_file_xml_open( file, name ) == -1 )
    {
        return -1;
    }
    if ( io_writenumber( file, number, 1, 0 ) == -1 )
    {
        return -1;
    }
    if ( io_file_xml_close( file, name ) == -1 )
    {
        return -1;
    }
    return 0;

}

#endif

///Read a four byte value from n_file
/// - Parameter fil: the pointer to the n_file data that is read from.
/// - Parameter actual_value: the actual value read.
/// - Parameter final_char: the final character (after the last number).
/// - Returns: number of characters read in condition of success and -1 in condition of failure.
n_int io_read_byte4( n_file *fil, n_uint *actual_value, n_byte *final_char )
{
    n_uint  temp = 0;
    n_int   ten_power_place = 0;
    while ( 1 )
    {
        n_byte  value = io_read( fil );
        n_uint mod_ten;
        if ( !ASCII_NUMBER( value ) )
        {
            *actual_value = temp;
            *final_char = value;
            return ten_power_place;
        }
        mod_ten = value - '0';
        if ( ( temp == 429496729 ) && ( mod_ten > 5 ) )
        {
            return -1;
        }
        if ( temp > 429496729 )
        {
            return -1;
        }
        temp = ( temp * 10 ) + mod_ten;
        ten_power_place++;
    }
}


#define    ASCII_WHITESPACE(num) ((((num)>8)&&((num)<14))||((num)==32))

///Removes the whitespace from the initial file - CRs, LFs, tabs and spaces.
/// - Parameter input: the file pointer that will have the white space removed.
void io_whitespace( n_file *input )
{
    n_uint    loop = 0, out_loop = 0;
    n_uint    end_loop = input->size;
    n_byte    *local_data = input->data;

    while ( loop < end_loop )
    {
        n_byte    temp = local_data[loop++];
        if ( ( temp == '/' ) && ( loop != end_loop ) )
        {
            n_byte    check_twice[2] = {'/', 0};
            check_twice[1] = local_data[loop++];
            if ( check_twice[1] != '*' )
            {
                local_data[out_loop++] = '/';
                if ( ASCII_WHITESPACE( check_twice[1] ) == 0 )
                {
                    local_data[out_loop++] = check_twice[1];
                }
            }
            else
            {
                check_twice[0] = 0;
                check_twice[1] = 0;
                do
                {
                    check_twice[0] = check_twice[1];
                    check_twice[1] = local_data[loop++];
                }
                while ( ( loop != end_loop ) && !( ( check_twice[0] == '*' ) && ( check_twice[1] == '/' ) ) );
            }
        }
        else if ( ASCII_WHITESPACE( temp ) == 0 )
        {
            local_data[out_loop++] = temp;
        }
    }

    loop = out_loop;

    while ( loop < end_loop )
    {
        local_data[loop++] = 0;
    }
    input->size = out_loop;
}

n_file * io_file_duplicate(n_file * initial)
{
    n_file * new_file = memory_new(sizeof(n_file));
    new_file->size = new_file->location = 0;

    if (new_file)
    {

        new_file->data = memory_new(initial->size);
        if (new_file->data)
        {
            memory_copy(initial->data, new_file->data, initial->size);
            new_file->size = initial->size;
            new_file->location = initial->location;
        }
    }
    return new_file;
}


/// This is a dynamic write to file function which will increase the file size and
/// allocated a larger data buffer if the original end of the file is reached. It
/// is very useful for a number of dynamic file applications through the simulation.
/// - Parameter fil: The file data to be written to.
/// - Parameter byte: The byte/character to be written.
/// - Returns: Whether the parsing was successful or -1 on failure.
n_int io_file_write( n_file *fil, n_byte byte )
{
    n_uint local_size = fil->size;
    if ( ( fil->location + 1 ) == local_size )
    {
        /* This logic had to be changed for large file handling.*/
        n_uint    temp_size;
        n_byte *temp_data;
        if ( local_size <= ( 256 * 1024 ) )
        {
            temp_size = local_size * 4;
        }
        else
        {
            if ( local_size <= ( 512 * 1024 * 1024 ) )
            {
                temp_size = local_size * 2;
            }
            else
            {
                temp_size = ( local_size * 3 ) >> 1;
            }
        }
        temp_data = memory_new( temp_size );
        if ( temp_data == 0L )
        {
            return ( SHOW_ERROR( "Attempted file overwrite" ) );
        }
        memory_copy( fil->data, temp_data, local_size );
        memory_free( ( void ** ) & ( fil->data ) );
        fil->data = temp_data;
        fil->size = temp_size;
    }
    fil->data[fil->location++] = byte;
    return ( FILE_OKAY );
}

/* Memory saving */
void io_file_reused( n_file *fil )
{
    memory_erase( fil->data, fil->size );
    fil->location = 0;
}




/* writes a string, adding a new line if required in the OS correct format */
#define FILE_MACRO_WRITE(ch)        if(io_file_write(fil,(ch)) == -1) return -1

n_int io_write( n_file *fil, n_constant_string ch, n_byte new_line )
{
    if ( ch[0] != 0 )
    {
        n_uint    lp = 0;
        while ( ch[lp] != 0 )
        {
            FILE_MACRO_WRITE( ch[lp++] );
        }
    }
    if ( new_line & 1 )
    {
#ifdef    _WIN32
        FILE_MACRO_WRITE( 13 );
#endif
        FILE_MACRO_WRITE( 10 );
    }
    if ( new_line & 2 )
    {
        FILE_MACRO_WRITE( 9 );
    }
    return ( FILE_OKAY );
}

/* writes a 16-bit or 8-bit number with an end terminator(,/;) and new line if required */
/* n_int error */
n_int io_writenumber( n_file *fil, n_int loc_val, n_uint numer, n_uint denom )
{
    n_byte    number_buffer[14] = {0};
    n_byte    negative;
    n_byte    decimal = 0;
    n_uint    positive_number;
    n_int    location = 12;
    if ( loc_val < 0 )
    {
        negative = 1;
        positive_number = ( n_uint )( 0 - loc_val );
    }
    else
    {
        negative = 0;
        positive_number = ( n_uint )( loc_val );
    }

    if ( denom != 0 )
    {
        n_uint roll_over = positive_number;

        positive_number = positive_number * numer * 100;

        if ( positive_number < roll_over )
        {
            return -1;
        }

        positive_number = positive_number / denom;
        decimal = 1;
    }

    do
    {
        number_buffer[location --] = ( n_byte )( ( positive_number % 10 ) + '0' );
        positive_number = positive_number / 10;
        if ( decimal && location == 10 )
        {
            number_buffer[location --] = '.';
            if ( positive_number == 0 )
            {
                number_buffer[location --] = '0';
            }
        }
    }
    while ( ( positive_number > 0 ) || ( decimal && ( location > 9 ) ) );
    if ( negative )
    {
        number_buffer[location] = '-';
    }
    else
    {
        location++;
    }
    return io_write( fil, ( n_string )&number_buffer[location], 0 );
}

n_int io_writenum( n_file *fil, n_int loc_val, n_byte ekind, n_byte new_line )
{
    n_int    return_val = io_writenumber( fil, loc_val, 1, 0 );
    n_byte    ekind_buffer[2] = {0};
    if ( return_val != FILE_OKAY )
    {
        return return_val;
    }
    ekind_buffer[0] = ekind;

    return io_write( fil, ( n_string )ekind_buffer, new_line );
}

/* find the variable command */
n_int io_command( n_file *fil, const simulated_file_entry *commands )
{
    n_byte   found_text[7] = {0};
    n_byte *commands_bytes = ( n_byte * ) commands[0].characters;

    n_byte2 lp = 0;

    found_text[0] = io_read( fil );
    if ( found_text[0] == 0 )
    {
        return ( FILE_EOF );
    }
    found_text[1] = io_read( fil );
    if ( found_text[0] == '}' && found_text[1] == ';' )
    {
        return ( FILE_END_INCLUSION );
    }
    found_text[2] = io_read( fil );
    found_text[3] = io_read( fil );
    found_text[4] = io_read( fil );
    found_text[5] = io_read( fil );

    while ( POPULATED( commands_bytes ) )
    {
        commands_bytes = ( n_byte * ) commands[lp].characters;
        if ( ( ( commands_bytes[0] == found_text[0] ) && ( commands_bytes[1] == found_text[1] ) ) &&
                ( ( commands_bytes[2] == found_text[2] ) && ( commands_bytes[3] == found_text[3] ) ) &&
                ( ( commands_bytes[4] == found_text[4] ) && ( commands_bytes[5] == found_text[5] ) ) )
        {
            return ( lp );
        }
        lp ++;
    }

    /*io_output_contents(fil);*/

    printf( "String length : %ld\n", io_length( ( n_string )fil->data, 0xffff ) );
    printf( "Actual size : %lu\n", fil->size );
    printf( "String location : %lu\n", fil->location );

    printf( "Failed text %s\n", found_text );

    printf( "Failed text %d\n", found_text[0] );
    printf( "Failed text %d\n", found_text[1] );
    printf( "Failed text %d\n", found_text[2] );
    printf( "Failed text %d\n", found_text[3] );
    printf( "Failed text %d\n", found_text[4] );
    printf( "Failed text %d\n", found_text[5] );

    NA_ASSERT( 0, "Failed here" );

    return SHOW_ERROR( ( n_constant_string )found_text );
}

/* find the largest size data unit to handle the file copying to data structures */
n_uint io_find_size_data( simulated_file_entry *commands )
{
    n_uint   max_entry = 0;
    n_int   lp = 1;
    n_byte  last_incl = FILE_INCL( commands[0].incl_kind );
    n_byte *last_characters;
    do
    {
        n_byte    data_incl = FILE_INCL( commands[lp].incl_kind );
        last_characters = commands[lp].characters;
        if ( last_incl != data_incl )
        {
            n_uint   local_kind = FILE_KIND( commands[lp - 1].incl_kind );
            n_uint   data_size;
            n_uint   running_entry = commands[lp - 1].start_location;

            switch ( local_kind )
            {
            case FILE_TYPE_BYTE4:
                data_size = 4;
                break;
            case FILE_TYPE_BYTE2:
                data_size = 2;
                break;
            default:
                data_size = 1;
                break;
            }

            running_entry += data_size * commands[lp - 1].number_entries;
            if ( running_entry > max_entry )
            {
                max_entry = running_entry;
            }
            last_incl = data_incl;
        }
        lp++;
    }
    while ( POPULATED( last_characters ) );
    return max_entry;
}

#define    FILE_MACRO_CONCLUSION(ch)    (((comman_req==1) && (ch) == ',') || \
((comman_req==0) && (ch) == ';'))

/* after the variable command, read the kind of data in specified through the commands array */
/* n_int error */
n_int io_read_data( n_file *fil, n_byte2 command, n_byte *data_read )
{
    n_int  comman_req = ( ( command & FILE_CONTINUATION ) == FILE_CONTINUATION );
    n_byte type_from_command = ( n_byte )FILE_TYPE( command );

    if ( type_from_command == FILE_TYPE_PACKED )
    {
        n_uint loop = 0;
        n_byte  buffer[5] = {0};
        n_uint output_val;
        n_byte  num_char;

        if ( data_read == 0L )
        {
            return ( FILE_OKAY );
        }

        while ( loop < PACKED_DATA_BLOCK )
        {
            buffer[0] = io_read( fil );
            buffer[1] = io_read( fil );
            buffer[2] = io_read( fil );

            output_val = ( buffer[0] - 65 );
            output_val += ( buffer[1] - 65 ) * 41;
            output_val += ( buffer[2] - 65 ) * 41 * 41;

            data_read[loop++] = ( output_val >> 0 ) & 255;
            data_read[loop++] = ( output_val >> 8 ) & 255;
        }
        num_char  = io_read( fil );

        if ( FILE_MACRO_CONCLUSION( num_char ) )
        {
            return ( FILE_OKAY );
        }
        return SHOW_ERROR( "Packed ends incorrectly" );
    }

    if ( ( type_from_command == FILE_TYPE_BYTE ) ||
            ( type_from_command == FILE_TYPE_BYTE_EXT ) ||
            ( type_from_command == FILE_TYPE_BYTE2 ) ||
            ( type_from_command == FILE_TYPE_BYTE4 ) )
    {
        n_uint    number = 0;
        n_byte    num_char;
        n_int   response_code = io_read_byte4( fil, &number, &num_char );

        if ( response_code == 0 )
        {
            return SHOW_ERROR( "Expected number not found" );
        }
        if ( response_code < 0 )
        {
            return SHOW_ERROR( "Expected number too big" );
        }

        if ( ( type_from_command == FILE_TYPE_BYTE ) || ( type_from_command == FILE_TYPE_BYTE_EXT ) )
        {
            if ( number > 0x000000ff )
            {
                return SHOW_ERROR( "Expected byte too big" );
            }
            data_read[0] = ( n_byte ) number;
        }

        if ( type_from_command == FILE_TYPE_BYTE2 )
        {
            n_byte2     *data_read2 = ( n_byte2 * )data_read;
            if ( number > 0x0000ffff )
            {
                return SHOW_ERROR( "Expected two byte too big" );
            }
            data_read2[0] = ( n_byte2 ) number;
        }

        if ( type_from_command == FILE_TYPE_BYTE4 )
        {
            n_byte4     *data_read4 = ( n_byte4 * )data_read;
            data_read4[0] = ( n_byte4 ) number;
        }

        if ( FILE_MACRO_CONCLUSION( num_char ) )
        {
            return ( FILE_OKAY );
        }
        return SHOW_ERROR( "Number ends incorrectly" );
    }
    return SHOW_ERROR( "Type not found" );
}

void io_output_contents( n_file *file )
{
    n_uint loop = 0;
    printf( "\n--------------------FILE--------------------\n" );
    printf( "Location %ld\n", file->location );
    printf( "Size %ld\n", file->size );
    printf( "* * * * * * \n" );

    while ( loop < file->location )
    {
        printf( "%c", file->data[loop++] );
    }
    printf( "\n--------------------------------------------\n" );

}

/**
 @discussion This function takes a file and parses the file date with the commands
 shown into the output data. This function is extremely powerful because it allows
 all different kinds of format-rich text data to be converted into binary
 information based on the command information passed in to this function too.
 @param fil The file data to be parsed.
 @param data The resultant output data.
 @param commands The commands used to parse the output data.
 @return Whether the parsing was successful or -1 on failure.
 */
n_int    io_read_buff( n_file *fil, n_byte *data, const simulated_file_entry *commands )
{

    n_int    inclusion_number = 0xffff;
    n_int    result_number = 0;
    do
    {
        result_number = io_command( fil, commands );
        if ( result_number == -1 )
        {
            return SHOW_ERROR( "Unknown command" );
        }

        if ( result_number > 0x00ff )
        {
            if ( result_number != FILE_END_INCLUSION )
            {
                return ( result_number );
            }
        }
        else
        {
            n_byte  com_inclusion = FILE_INCL( commands[result_number].incl_kind );
            n_byte  com_kind      = FILE_KIND( commands[result_number].incl_kind );

            n_uint  com_number_of = commands[result_number].number_entries;
            n_uint  com_location  = commands[result_number].start_location;

            n_uint    loop = 0;
            n_byte *local_data = &data[com_location];

            if ( inclusion_number == 0xffff )
            {
                if ( commands[result_number].characters[5] != '{' )
                {
                    return SHOW_ERROR( "{ expected in the file" );
                }
                inclusion_number = com_inclusion;
            }
            if ( inclusion_number != com_inclusion )
            {
                return SHOW_ERROR( "Wrong start in file" );
            }

            while ( loop < com_number_of )
            {
                n_byte    local_kind = com_kind;
                if ( ( loop + 1 ) != com_number_of )
                {
                    local_kind |= FILE_CONTINUATION;
                }
                if ( io_read_data( fil, local_kind, local_data ) != FILE_OKAY )
                {
                    return ( FILE_ERROR );
                }
                if ( com_kind == FILE_TYPE_PACKED )
                {
                    local_data = &local_data[ PACKED_DATA_BLOCK ];
                }
                else
                {
                    if ( com_kind == FILE_TYPE_BYTE_EXT )
                    {
                        local_data = &local_data[ 1 ];
                    }
                    else
                    {
                        local_data = &local_data[ com_kind ];
                    }
                }
                loop++;
            }
        }
    }
    while ( result_number != FILE_END_INCLUSION );
    return ( inclusion_number );
}

#define    IO_CHECK_ERROR(cnd)             \
{                                   \
n_int    out_cnd = cnd;          \
if ( (out_cnd) != FILE_OKAY)    \
return    out_cnd;            \
}
/**
 This function takes a block of data and various format-rules (through the
 commands) and applies these rules to produce an output datafile. In many
 regards this can be thought of as the inverse of io_read_buff.
 @param fil The file data that is produced.
 @param data The resultant output data.
 @param commands The commands used to parse data to the output file.
 @param command_num Output the command number block of commands.
 @param func Allows a file specific function to be injected to add additional format requirments.
 @return Whether the parsing was successful.
 */
n_int io_write_buff( n_file *fil, void *data, const simulated_file_entry *commands, n_byte command_num, n_file_specific *func )
{
    if ( command_num == FILE_COPYRIGHT )
    {
        n_string *fluff = ( n_string * ) data;

        IO_CHECK_ERROR( io_write( fil, "/*", 3 ) );
        IO_CHECK_ERROR( io_write( fil, fluff[0], 0 ) );
        IO_CHECK_ERROR( io_write( fil, fluff[1], 3 ) );

        IO_CHECK_ERROR( io_write( fil, fluff[2], 0 ) );
        IO_CHECK_ERROR( io_write( fil, fluff[3], 0 ) );
        IO_CHECK_ERROR( io_write( fil, fluff[4], 1 ) );
        IO_CHECK_ERROR( io_write( fil, "*/", 1 ) );
        IO_CHECK_ERROR( io_write( fil, "", 1 ) );

        return ( FILE_OKAY );
    }
    {
        const n_byte    *commands_bytes;
        n_byte          writeout_commands[7] = {0};
        n_uint    offset = 0;
        n_int    release = FILE_ERROR;
        do
        {
            commands_bytes = commands[offset].characters;
            if ( ( commands_bytes[0] == 0 ) && ( commands_bytes[1] == 0 ) &&
                    ( commands_bytes[2] == 0 ) && ( commands_bytes[3] == 0 ) &&
                    ( commands_bytes[4] == 0 ) && ( commands_bytes[5] == 0 ) )
            {
                return SHOW_ERROR( "File command not found" );
            }

            if ( FILE_INCL( commands[offset].incl_kind ) == command_num )
            {
                release = FILE_OKAY;
            }
            else
            {
                offset++;
            }
        }
        while ( release == FILE_ERROR );
        writeout_commands[0] = commands_bytes[0];
        writeout_commands[1] = commands_bytes[1];
        writeout_commands[2] = commands_bytes[2];
        writeout_commands[3] = commands_bytes[3];
        writeout_commands[4] = commands_bytes[4];
        writeout_commands[5] = commands_bytes[5];

        IO_CHECK_ERROR( io_write( fil, ( n_string )writeout_commands, 3 ) );
        release = FILE_ERROR;
        offset++;
        do
        {
            commands_bytes = commands[offset].characters;

            if ( ( commands_bytes[0] == 0 ) && ( commands_bytes[1] == 0 ) &&
                    ( commands_bytes[2] == 0 ) && ( commands_bytes[3] == 0 ) &&
                    ( commands_bytes[4] == 0 ) && ( commands_bytes[5] == 0 ) )
            {
                release = FILE_OKAY;
            }

            if ( FILE_INCL( commands[offset].incl_kind ) != command_num )
            {
                release = FILE_OKAY;
            }

            if ( release == FILE_ERROR )
            {
                n_uint    loop = 0;
                n_byte    data_type    = FILE_KIND( commands[offset].incl_kind );
                n_uint  end_loop     = commands[offset].number_entries;
                n_uint    data_offset  = commands[offset].start_location;
                n_int    right_ending = ( FILE_INCL( commands[offset + 1].incl_kind ) != command_num );

                right_ending |= ( ( commands[offset + 1].characters[0] == 0 ) && ( commands[offset + 1].characters[1] == 0 ) &&
                                  ( commands[offset + 1].characters[2] == 0 ) && ( commands[offset + 1].characters[3] == 0 ) &&
                                  ( commands[offset + 1].characters[4] == 0 ) && ( commands[offset + 1].characters[5] == 0 ) );
                right_ending = 3 - ( right_ending * 2 );
#if 0
                if ( data_type == FILE_TYPE_PACKED )
                {
                    if ( unpack_data != 0L )
                    {
                        n_byte  buffer[6] = {0};
                        n_uint output_val;
                        n_byte  *local_unpack_data = unpack_data;
                        writeout_commands[0] = commands_bytes[0];
                        writeout_commands[1] = commands_bytes[1];
                        writeout_commands[2] = commands_bytes[2];
                        writeout_commands[3] = commands_bytes[3];
                        writeout_commands[4] = commands_bytes[4];
                        writeout_commands[5] = commands_bytes[5];
                        IO_CHECK_ERROR( io_write( fil, ( n_string )writeout_commands, ( n_byte )right_ending ) );
                        while ( loop < end_loop )
                        {
                            n_uint data_loop = 0;
                            while ( data_loop < PACKED_DATA_BLOCK )
                            {
                                output_val  = local_unpack_data[data_loop++];
                                output_val |= local_unpack_data[data_loop++] << 8;
                                buffer[0] = ( output_val % 41 ) + 65;
                                output_val /= 41;
                                buffer[1] = ( output_val % 41 ) + 65;
                                output_val /= 41;
                                buffer[2] = ( output_val % 41 ) + 65;

                                if ( ( data_loop % 80 ) == 0 )
                                {
                                    IO_CHECK_ERROR( io_write( fil, ( n_string ) buffer, ( n_byte )right_ending ) );
                                }
                                else
                                {
                                    IO_CHECK_ERROR( io_write( fil, ( n_string ) buffer, 0 ) );
                                }
                            }
                            local_unpack_data = &local_unpack_data[PACKED_DATA_BLOCK];
                            loop++;
                            if ( loop == end_loop )
                            {
                                IO_CHECK_ERROR( io_write( fil, ";", ( n_byte )right_ending ) );
                            }
                            else
                            {
                                IO_CHECK_ERROR( io_write( fil, ",", ( n_byte )right_ending ) );
                            }
                        }
                    }
                }
                else
#endif
                {
                    n_byte *byte_data = ( n_byte * )data;
                    if ( data_type == FILE_TYPE_BYTE_EXT )
                    {
                        n_string_block block_code = {0};
                        if ( func != 0 )
                        {
                            ( *func )( ( n_string )block_code, byte_data );
                        }
                        IO_CHECK_ERROR( io_write( fil, "", 1 ) );
                        IO_CHECK_ERROR( io_write( fil, "", 2 ) );
                        IO_CHECK_ERROR( io_write( fil, "/* ", 0 ) );

                        IO_CHECK_ERROR( io_writenumber( fil, loop, 1, 0 ) );
                        IO_CHECK_ERROR( io_write( fil, "", 2 ) );
                        IO_CHECK_ERROR( io_write( fil, block_code, 0 ) );
                        IO_CHECK_ERROR( io_write( fil, " */", 2 ) );
                    }

                    writeout_commands[0] = commands_bytes[0];
                    writeout_commands[1] = commands_bytes[1];
                    writeout_commands[2] = commands_bytes[2];
                    writeout_commands[3] = commands_bytes[3];
                    writeout_commands[4] = commands_bytes[4];
                    writeout_commands[5] = commands_bytes[5];

                    IO_CHECK_ERROR( io_write( fil, ( n_string )writeout_commands, 0 ) );
                    while ( loop < end_loop )
                    {
                        n_byte4 num_write = 0;
                        switch ( data_type )
                        {
                        case FILE_TYPE_BYTE_EXT:
                            if ( ( loop != 0 ) && ( ( loop % 3 ) == 0 ) && ( loop != 126 ) )
                            {
                                n_string_block block_code = {0};
                                if ( func != 0L )
                                {
                                    ( *func )( block_code, &byte_data[data_offset + loop] );
                                }
                                IO_CHECK_ERROR( io_write( fil, "", 1 ) );
                                IO_CHECK_ERROR( io_write( fil, "", 2 ) );
                                IO_CHECK_ERROR( io_write( fil, "/* ", 0 ) );
                                IO_CHECK_ERROR( io_writenumber( fil, loop, 1, 0 ) );
                                IO_CHECK_ERROR( io_write( fil, "", 2 ) );
                                IO_CHECK_ERROR( io_write( fil, ( n_string )block_code, 0 ) );
                                IO_CHECK_ERROR( io_write( fil, " */", 2 ) );
                            }
                        case FILE_TYPE_BYTE:
                            num_write = byte_data[data_offset + loop];
                            break;
                        case FILE_TYPE_BYTE2:
                        {
                            num_write = ( ( n_byte2 * )  &byte_data[data_offset + ( loop * 2 )] )[0];
                        }
                        break;
                        case FILE_TYPE_BYTE4:
                            num_write = ( ( n_byte4 * ) &byte_data[data_offset + ( loop * 4 )] )[0];
                            break;
                        }
                        loop++;

                        if ( loop == end_loop )
                        {
                            IO_CHECK_ERROR( io_writenum( fil, num_write, ';', ( n_byte )right_ending ) );
                        }
                        else
                        {
                            IO_CHECK_ERROR( io_writenum( fil, num_write, ',', 0 ) );
                        }
                    }

                }
                offset++;
            }
        }
        while ( release == FILE_ERROR );
        IO_CHECK_ERROR( io_write( fil, "};", 1 ) );
        IO_CHECK_ERROR( io_write( fil, "", 1 ) );
    }
    return ( FILE_OKAY );
}

/* write the output data with the commands array and the required copyright "fluff" */
/* n_int error */
n_int io_write_csv( n_file *fil, n_byte *data, const simulated_file_entry *commands, n_byte command_num, n_byte initial )
{
    if ( command_num == FILE_COPYRIGHT )
    {
        return ( FILE_OKAY );
    }
    {
        const n_byte *commands_bytes;
        n_uint    offset = 0;
        n_int      release = FILE_ERROR;
        n_byte  first_entry = 1;
        n_byte  writeout_commands[6] = {0};
        do
        {
            commands_bytes = commands[offset].characters;
            if ( ( commands_bytes[0] == 0 ) && ( commands_bytes[1] == 0 ) &&
                    ( commands_bytes[2] == 0 ) && ( commands_bytes[3] == 0 ) &&
                    ( commands_bytes[4] == 0 ) && ( commands_bytes[5] == 0 ) )
            {
                return SHOW_ERROR( "File command not found" );
            }
            if ( FILE_INCL( commands[offset].incl_kind ) == command_num )
            {
                release = FILE_OKAY;
            }
            else
            {
                offset++;
            }
        }
        while ( release == FILE_ERROR );

        release = FILE_ERROR;
        offset++;
        do
        {
            commands_bytes = commands[offset].characters;
            if ( ( commands_bytes[0] == 0 ) && ( commands_bytes[1] == 0 ) &&
                    ( commands_bytes[2] == 0 ) && ( commands_bytes[3] == 0 ) &&
                    ( commands_bytes[4] == 0 ) && ( commands_bytes[5] == 0 ) )
            {
                release = FILE_OKAY;
            }
            if ( FILE_INCL( commands[offset].incl_kind ) != command_num )
            {
                release = FILE_OKAY;
            }
            if ( release == FILE_ERROR )
            {
                n_uint    loop = 0;
                n_byte    data_type   = FILE_KIND( commands[offset].incl_kind );
                n_uint  end_loop    = commands[offset].number_entries;
                n_uint    data_offset = commands[offset].start_location;

                if ( data_type != FILE_TYPE_PACKED )
                {
                    while ( loop < end_loop )
                    {
                        n_byte2    num_write = 0;

                        if ( first_entry == 0 )
                        {
                            IO_CHECK_ERROR( io_write( fil, ",", 0 ) );
                        }
                        else
                        {
                            first_entry = 0;
                        }

                        if ( initial == 1 )
                        {
                            writeout_commands[0] = commands_bytes[0];
                            writeout_commands[1] = commands_bytes[1];
                            writeout_commands[2] = commands_bytes[2];
                            writeout_commands[3] = commands_bytes[3];
                            writeout_commands[4] = commands_bytes[4];
                            writeout_commands[5] = commands_bytes[5];

                            IO_CHECK_ERROR( io_write( fil, ( n_string )writeout_commands, 0 ) );
                            IO_CHECK_ERROR( io_writenumber( fil, loop, 1, 0 ) );
                        }
                        else
                        {
                            switch ( data_type )
                            {
                            case FILE_TYPE_BYTE:
                            case FILE_TYPE_BYTE_EXT:
                                num_write = data[data_offset + loop];
                                break;
                            case FILE_TYPE_BYTE2:
                                num_write = ( ( n_byte2 * ) & data[data_offset + ( loop * 2 )] )[0];
                                break;
                            }
                            IO_CHECK_ERROR( io_writenumber( fil, num_write, 1, 0 ) );
                        }
                        loop++;
                    }
                }
                offset++;
            }
        }
        while ( release == FILE_ERROR );
        IO_CHECK_ERROR( io_write( fil, "", 1 ) );
    }
    return ( FILE_OKAY );
}

void io_search_file_format( const simulated_file_entry *format, n_string compare )
{
    n_int              loop = 0;
    n_byte               print_file_format_exit = 0;
    n_byte               print_file_place_show_all = 0;
    simulated_file_entry *place;
    if ( compare == 0L )
    {
        print_file_place_show_all = 2;
    }
    else
    {
        n_byte leave_condition = 0;
        do
        {
            place = ( simulated_file_entry * )&format[loop++];
            if ( ( place->characters[0] != 0 ) && ( place->characters[1] != 0 ) &&
                    ( place->characters[2] != 0 ) && ( place->characters[3] != 0 ) &&
                    ( place->characters[4] != 0 ) && ( place->characters[5] != 0 ) )
            {
                if ( ( place->characters[0] == compare[0] ) && ( place->characters[1] == compare[1] ) &&
                        ( place->characters[2] == compare[2] ) && ( place->characters[3] == compare[3] ) &&
                        ( place->characters[4] == compare[4] ) && ( 0 == compare[5] ) )
                {
                    leave_condition = 1;
                }

            }
            else
            {
                print_file_format_exit = 1;
            }
        }
        while ( ( print_file_format_exit == 0 ) && ( leave_condition == 0 ) );

        if ( print_file_format_exit == 1 )
        {
            ( void )SHOW_ERROR( "String not found" );
            return;
        }
        if ( place->characters[5] == '{' )
        {
            print_file_place_show_all = 1;
        }
        loop--;
    }
    do
    {
        place = ( simulated_file_entry * )&format[loop++];
        if ( ( place->characters[0] != 0 ) && ( place->characters[1] != 0 ) &&
                ( place->characters[2] != 0 ) && ( place->characters[3] != 0 ) &&
                ( place->characters[4] != 0 ) && ( place->characters[5] != 0 ) )
        {
            if ( place->characters[5] == '{' )
            {
                printf( " %c%c%c%c%c %s\n", place->characters[0], place->characters[1], place->characters[2],
                        place->characters[3], place->characters[4], place->what_is_it );
            }
            else
            {
                printf( "  %c%c%c%c%c %s\n", place->characters[0], place->characters[1], place->characters[2],
                        place->characters[3], place->characters[4], place->what_is_it );
            }

            if ( print_file_place_show_all == 0 )
            {
                return;
            }
            if ( ( format[loop].characters[5] == '{' ) && ( print_file_place_show_all == 1 ) )
            {
                return;
            }
        }
        else
        {
            print_file_format_exit = 1;
        }
    }
    while ( print_file_format_exit == 0 );
}

void io_audit_file( const simulated_file_entry *format, n_byte section_to_audit )
{
    n_uint      loop = 0;
    n_uint      being_counter = 0;
    n_byte     *local_characters;
    do
    {
        n_byte   local_incl_kind  = format[loop].incl_kind;
        n_uint   local_number     = format[loop].number_entries;
        n_uint   local_location   = format[loop].start_location;
        n_string_block   printout_characters = {0};
        local_characters = ( n_byte * )format[loop].characters;
        if ( ( local_incl_kind & 0xF0 ) == section_to_audit )
        {
            n_uint local_type = local_incl_kind & 0x0F;

            if ( local_type == FILE_TYPE_BYTE_EXT )
            {
                local_type = FILE_TYPE_BYTE;
            }

            if ( ( local_type == FILE_TYPE_BYTE ) || ( local_type == FILE_TYPE_BYTE2 ) || ( local_type == FILE_TYPE_BYTE4 ) )
            {
                printout_characters[0] = ( n_char )local_characters[0];
                printout_characters[1] = ( n_char )local_characters[1];
                printout_characters[2] = ( n_char )local_characters[2];
                printout_characters[3] = ( n_char )local_characters[3];
                printout_characters[4] = ( n_char )local_characters[4];
                printout_characters[5] = ( n_char )local_characters[5];

                printf( "%s \t %lu * %lu = %lu bytes \t reported/actual/diff offset %d / %d / %d\n", printout_characters,
                        local_number, local_type, ( local_number * local_type ), ( int )local_location, ( int )being_counter, ( ( int )local_location - ( int )being_counter ) );

                being_counter += ( local_number * local_type );
            }
        }
        loop++;
    }
    while ( ( local_characters[0] != 0 ) && ( local_characters[1] != 0 ) &&
            ( local_characters[2] != 0 ) && ( local_characters[3] != 0 ) );
}



n_file *io_file_ready( n_int entry, n_file *file )
{
    if ( entry == 1 )
    {
        return 0L;
    }
    return file;
}

void io_file_cleanup( n_int *entry, n_file **file )
{
    /* This setting to zero may be duplicated in at least one place
     but provides additional protection - it may not be needed following
     a case-by-case review */

    *entry = 0;

    if ( *file )
    {
        io_file_free( file );
    }
}

void io_file_writeon( n_int *entry, n_file **file, n_byte blocked_write )
{
    if ( *entry == 0 )
    {
        return;
    }
#ifndef COMMAND_LINE_DEBUG
    if ( *file == 0L ) /* io_file_reused */
    {
        *file = io_file_new();
    }
    if ( *file == 0L )
    {
        ( void )SHOW_ERROR( "Could not set up special use file" );
        return;
    }
    if ( blocked_write )
    {
        *entry = 1;
    }
    else
    {
        *entry = 2;
    }
#endif
}

void io_file_writeoff( n_int *entry, n_file *file )
{
    if ( *entry == 0 )
    {
        return;
    }
#ifndef COMMAND_LINE_DEBUG
    if ( file != 0L )
    {
        *entry = 0;
    }
#endif
}

void io_file_string( n_int entry, n_file *file, n_constant_string string )
{
    if ( entry == 0 )
    {
        return;
    }

    if ( ( string != 0L )
#ifndef COMMAND_LINE_DEBUG
            && ( file  != 0L )
#endif
       )
    {
#ifndef COMMAND_LINE_DEBUG
        io_write( file, string, 0 );
#else
        printf( "%s", string );
#endif
    }
}

void io_file_debug( n_file *file )
{
    n_uint loop = 0;
    while ( loop < file->location )
    {
        printf( "%c", file->data[loop] );
        loop++;
    }
    printf( "\n\n" );
}



/* ./toolkit/io.c */
/****************************************************************

 io.c

 =============================================================



 ****************************************************************/

/*! \file   io.c
 *  \brief  Covers the low level input and output relating to memory and files.
    In addition to memory and file handling, io has typically been a place holder
    for new functionality.
 */

#include "toolkit.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>


/**
 * Moves the string to lower case for the length shown.
 * @param value the string with the case to be lowered.
 * @param length the number of bytes to be lowered.
 */
void io_lower( n_string value, n_int length )
{
    n_int loop = 0;
    while ( loop < length )
    {
        IO_LOWER_CHAR( value[loop] );
        loop++;
    }
}

/**
 * Read a number from a string.
 * @param number_string the string to be read from.
 * @param actual_value the actual value read.
 * @param decimal_divisor the value required to provide a decimal version.
 * @return number of characters read in condition of success and -1 in condition of failure.
 */
n_int io_number( n_string number_string, n_int *actual_value, n_int *decimal_divisor )
{
    n_uint  temp = 0;
    n_int   divisor = 0;
    n_int   ten_power_place = 0;
    n_int   string_point = 0;
    n_byte  negative = 0;

    if ( number_string == 0L )
    {
        return -1;
    }
    if ( number_string[0] == 0 )
    {
        return -1;
    }

    if ( number_string[0] == '-' )
    {
        negative = 1;
        string_point++;
    }

    while ( 1 )
    {
        n_char value = number_string[string_point++];
        n_uint mod_ten;
        if ( value == 0 )
        {
            n_int   translate;

            if ( negative == 1 )
            {
                translate = 0 - temp;
            }
            else
            {
                translate = temp;
            }

            *actual_value = translate;

            if ( divisor > 0 )
            {
                divisor--;
            }

            *decimal_divisor = divisor;
            return ten_power_place;
        }
        if ( value == '.' )
        {
            if ( divisor != 0 )
            {
                return SHOW_ERROR( "double decimal point in number" );
            }
            divisor = 1;
        }
        else
        {
            if ( !ASCII_NUMBER( value ) )
            {
                return SHOW_ERROR( "number contains non-numeric value" );
            }

            mod_ten = value - '0';
            if ( temp == 922337203685477580 )
            {
                if ( negative == 1 )
                {
                    if ( mod_ten > 8 )
                    {
                        return SHOW_ERROR( "number too small" );
                    }
                }
                else
                {
                    if ( mod_ten > 7 )
                    {
                        return SHOW_ERROR( "number too large" );
                    }
                }
            }
            if ( temp > 922337203685477580 )
            {
                return SHOW_ERROR( "number numerically too large" );
            }
            if ( divisor != 0 )
            {
                divisor++;
            }
            temp = ( temp * 10 ) + mod_ten;
            ten_power_place++;
        }
    }
}



/*
 This is too slow, consider:

 n_uint io_length(n_string s) {
 n_string start = s;
 while(*s)s++;
 return s - start;
 }
 */

/* this is used for finding the actual length of fixed length strings, max length is enforced */
n_int io_length( n_string value, n_int max )
{
    n_int return_length = -1;
    if ( value == 0L )
    {
        return 0;
    }
    if ( max < 1 )
    {
        return -1;
    }
    do
    {
        return_length++;
    }
    while ( ( value[return_length] != 0 ) && ( return_length < max ) );
    return return_length;
}

/*

 These are too slow too.

 Consider:

 return <0 if s<t, 0 if s==t, >0 if s>t


 n_int io_find(n_string s, n_string t)
 {
 for ( ; *s == *t; s++, t++)
 if (*s == '\0')
 return 0;
 return *s - *t;
 }

 */
#if 1
n_int io_find( n_string check, n_int from, n_int max, n_string value_find, n_int value_find_length )
{
    n_int  loop = from;
    n_int  check_length = 0;
    while ( loop < max )
    {
        if ( check[loop] == value_find[check_length] )
        {
            check_length++;
            if ( check_length == value_find_length )
            {
                return loop + 1;
            }
        }
        else
        {
            check_length = 0;
        }
        loop ++;
    }
    return -1;
}
#else
n_int io_find( n_string check, n_int from, n_int max, n_string value_find, n_int value_find_length )
{
    n_int loop = from;
    n_int check_length = 0;
    n_int match_start = from;
    
    while ( loop < max )
    {
        if ( check[loop] == value_find[check_length] )
        {
            if ( check_length == 0 )
            {
                match_start = loop;  // Remember where this potential match started
            }
            check_length++;
            if ( check_length == value_find_length )
            {
                return match_start;  // Return the start position of the match
            }
        }
        else
        {
            if ( check_length > 0 )
            {
                // Backtrack: restart search from position after where partial match began
                loop = match_start;
                check_length = 0;
            }
        }
        loop++;
    }
    return -1;
}
#endif

void io_string_write( n_string dest, n_string insert, n_int *pos )
{
    n_int  loop = 0;
    n_char character = 127;
    do
    {
        character = insert [loop++];
        if ( character )
        {
            dest[*pos] = character;
            *( pos ) += 1;
        }
    }
    while ( character );
    dest[*pos] = 0;
}

void io_three_string_combination( n_string output, n_string first, n_string second, n_string third, n_int count )
{
    n_int command_length = io_length( first, STRING_BLOCK_SIZE );
    n_int addition_length = io_length( second, STRING_BLOCK_SIZE );
    n_int total = count - ( command_length + addition_length + 1 );
    n_int loop2 = 0;
    n_int position = 0;

    io_string_write( output, " ", &position );
    io_string_write( output, first, &position );
    io_string_write( output, " ", &position );
    io_string_write( output, second, &position );
    while ( loop2 < total )
    {
        io_string_write( output, " ", &position );
        loop2++;

    }
    io_string_write( output, third, &position );
}

void io_number_to_string( n_string value, n_uint number )
{
    n_uint temp_number = number;
    n_uint digits_in_number = 0;
    n_uint multiplier = 1;
    n_uint number_location = 0;
    do
    {
        temp_number = temp_number / 10;
        digits_in_number++;
        if ( temp_number != 0 )
        {
            multiplier = multiplier * 10;
        }
    }
    while ( temp_number != 0 );
    do
    {
        value[number_location++] = '0' + ( number / multiplier ) % 10;
        multiplier = multiplier / 10;
        digits_in_number --;
    }
    while ( multiplier != 0 );
    value[number_location++] = 0;
}

void io_string_number( n_string output_string, n_string input_string, n_uint number )
{
    n_int input_length = io_length( input_string, STRING_BLOCK_SIZE );
    if ( input_length > 0 )
    {
        memory_copy( ( n_byte * )input_string, ( n_byte * )output_string, ( n_uint )input_length );
        io_number_to_string( &output_string[input_length], number );
        return ;
    }
    io_number_to_string( output_string, number );
}

void       io_three_strings( n_string output_string, n_string first_string, n_string second_string, n_string third_string, n_byte new_line )
{
    n_int first_length = io_length( first_string, STRING_BLOCK_SIZE );
    n_int second_length = io_length( second_string, STRING_BLOCK_SIZE );
    n_int third_length = io_length( third_string, STRING_BLOCK_SIZE );
    n_int carried_length = 0;

    if ( first_length > 0 )
    {
        if ( first_string != output_string )
        {
            memory_copy( ( n_byte * )first_string, ( n_byte * )output_string, ( n_uint )first_length );
        }
        carried_length += first_length;
    }
    if ( second_length > 0 )
    {
        memory_copy( ( n_byte * )second_string, ( n_byte * )&output_string[carried_length], ( n_uint )second_length );
        carried_length += second_length;
    }
    if ( third_length > 0 )
    {
        memory_copy( ( n_byte * )third_string, ( n_byte * )&output_string[carried_length], ( n_uint )third_length );
        carried_length += third_length;
    }
    if ( new_line )
    {
#ifdef    _WIN32
        output_string[carried_length++] = 13;
#endif
        output_string[carried_length++] = 10;
    }
    output_string[carried_length] = 0;
}

n_string io_string_copy( n_string string )
{
    n_string return_string = 0L;
    n_uint    string_length = ( n_uint )( io_length( string, STRING_BLOCK_SIZE ) + 1 );
    if ( string_length > 0 )
    {
        return_string = ( n_string )memory_new( string_length );
        memory_copy( ( n_byte * )string, ( n_byte * )return_string, string_length - 1 );
        return_string[string_length - 1] = 0;
    }
    return return_string;
}

void io_string_copy_buffer( n_string string, n_string buffer )
{
    n_int loop = 0;
    n_char copy_character;
    if ( string == 0L || buffer == 0L )
    {
        return;
    }
    do
    {
        copy_character = string[loop];
        buffer[loop] = copy_character;
        loop++;
    }
    while ( copy_character != 0 );
}

#ifdef SIMULATED_APE_ASSERT

void io_assert( n_string message, n_string file_loc, n_int line )
{
    printf( "Assert: %s, %s, %ld\n", message, file_loc, line );
}

#endif




/* ./toolkit/math.c */
/****************************************************************

 math.c

 =============================================================



 ****************************************************************/

/*! \file   math.c
 *  \brief  This covers vector math, the hash/random mathematics,
   (Newton) square root, the Bresenham's line algorithm, the bilinear
   interpolation and other abstract math that is used in Simulated Ape.
 */

#include "toolkit.h"

/**
 This is used to produce a series of steps between two points useful for drawing
 a line or a line of sight test.
 @param sx The starting x location.
 @param sy The starting y location.
 @param dx The distance to be traveled in the x direction.
 @param dy The distance to be traveled in the y direction.
 @param draw The generic draw function used to traverse the line points.
 @return This is 0 if the line draw is completed successfully and 1 if it exits
 through the generic draw function's request.
 */
n_byte math_join( n_int sx, n_int sy, n_int dx, n_int dy, n_join *draw )
{
    n_int	  px = sx;
    n_int	  py = sy;

    n_pixel	 *local_draw;
    void	 *local_info;

    NA_ASSERT( draw, "draw NULL" );

    if ( draw == 0L )
    {
        return 1;
    }
    if ( draw->pixel_draw == 0L )
    {
        return 1;
    }

    local_draw = draw->pixel_draw;
    local_info = draw->information;

    NA_ASSERT( local_draw, "local_draw NULL" );
    NA_ASSERT( local_info, "local_info NULL" );

    if ( ( *local_draw )( px, py, 0, 0, local_info ) )
    {
        return 1;
    }
    if ( ( dx == 0 ) && ( dy == 0 ) )
    {
        return 0;
    }
    {
        n_int	  dxabs = dx;
        n_int	  dyabs = dy;

        n_int	  sdx = ( dxabs != 0 );
        n_int	  sdy = ( dyabs != 0 );
        if ( dxabs < 0 )
        {
            dxabs = 0 - dxabs;
            sdx = -1;
        }
        if ( dyabs < 0 )
        {
            dyabs = 0 - dyabs;
            sdy = -1;
        }
        if ( dxabs >= dyabs )
        {
            n_int y2 = dxabs >> 1;
            n_int i = 0;
            while ( i++ < dxabs )
            {
                y2 += dyabs;
                if ( y2 >= dxabs )
                {
                    y2 -= dxabs;
                    py += sdy;
                }
                px += sdx;
                if ( ( *local_draw )( px, py, sdx, sdy, local_info ) )
                {
                    return 1;
                }
            }
        }
        else
        {
            n_int x2 = dyabs >> 1;
            n_int i = 0;
            while ( i++ < dyabs )
            {
                x2 += dxabs;
                if ( x2 >= dyabs )
                {
                    x2 -= dyabs;
                    px += sdx;
                }
                py += sdy;
                if ( ( *local_draw )( px, py, sdx, sdy, local_info ) )
                {
                    return 1;
                }
            }
        }
    }
    return 0;
}

n_byte math_join_vect2( n_int sx, n_int sy, n_vect2 *vect, n_join *draw )
{
    return math_join( sx, sy, vect->x, vect->y, draw );
}

n_byte math_line_vect( n_vect2 *point1, n_vect2 *point2, n_join *draw )
{
    n_vect2 delta;
    vect2_subtract( &delta, point2, point1 );
    return math_join( point1->x, point1->y, delta.x, delta.y, draw );
}

n_byte math_line( n_int x1, n_int y1, n_int x2, n_int y2, n_join *draw )
{
    n_int dx = x2 - x1;
    n_int dy = y2 - y1;
    return math_join( x1, y1, dx, dy, draw );
}

n_byte4 math_hash_fnv1( n_constant_string key )
{
    n_byte4 hash = 2166136261;
    while ( *key )
    {
        hash = ( 16777619 * hash ) ^ ( n_byte4 )( *key++ );
    }
    return hash;
}

/**
 Creates a near-unique integer value from a block of data. This is
 similar to CRC or other hash methods.
 @param values The data in byte chunks.
 @param length The length of the data in bytes.
 @return The hash value produced.
 */
n_uint math_hash( n_byte *values, n_uint length )
{
    n_uint	loop = 0;
    n_byte2	round[5] = {0xfa78, 0xfad7, 0x53e7, 0xa728, 0x2c81};

    NA_ASSERT( values, "values NULL" );

    if ( sizeof( n_uint ) == 8 )
    {
        n_uint  big_round[4];

        while ( loop < length )
        {
            round[0] ^= round[4];
            round[1] ^= values[loop++];
            math_random3( round );
            math_random3( &round[1] );
            math_random3( &round[2] );
            math_random3( &round[3] );
        }
        big_round[0] = round[0];
        big_round[1] = round[1];
        big_round[2] = round[2];
        big_round[3] = round[3];

        return big_round[0] | ( big_round[1] << 16 ) | ( big_round[2] << 32 ) | ( big_round[3] << 48 );
    }

    while ( loop < length )
    {
        round[1] ^= values[loop++];
        math_random3( round );
    }
    return ( n_uint )( round[0] | ( round[1] << 16 ) );
}

n_int math_tan( n_vect2 *p )
{
    n_int   return_value = 0, best_p;
    n_vect2 vector_facing;
    n_int check_switch = 128;
    vect2_direction( &vector_facing, 0, 8 );
    best_p = vect2_dot( p, &vector_facing, 1, 1 );

    do
    {
        n_int   temp_p;
        vect2_direction( &vector_facing, return_value + check_switch, 8 );
        temp_p = vect2_dot( p, &vector_facing, 1, 1 );
        if (temp_p > best_p)
        {
            best_p = temp_p;
            return_value += check_switch;
        }

        vect2_direction( &vector_facing, return_value - check_switch + 256, 8 );
        temp_p = vect2_dot( p, &vector_facing, 1, 1 );
        if (temp_p > best_p)
        {
            best_p = temp_p;
            return_value -= check_switch;
        }
        check_switch = check_switch >> 1;
    }
    while (check_switch);
    return (return_value + 256) & 255;
}

n_int math_spline(n_vect2 * start_vector, n_vect2 * end_vector, n_vect2 * elements, n_int number_elements)
{
    if (number_elements == 0)
    {
        return -1;
    }

    n_vect2 start, end;

    vect2_subtract( &start, &start_vector[1], &start_vector[0] );
    vect2_subtract( &end, &end_vector[1], &end_vector[0] );

    n_int tan_start = math_tan(&start);
    n_int tan_end = math_tan(&end);
    n_int tan_new = tan_start;
    n_int tan_delta;

    if (tan_start > tan_end)
    {
        tan_end += 256;
    }

    tan_delta = (tan_end - tan_start) / number_elements;

    /* pre calculation */

    n_int loop = 0;

    n_vect2 span;

    span.x = start_vector[1].x;
    span.y = start_vector[1].y;

    while (loop < number_elements)
    {
        n_vect2 direction;
        tan_new += tan_delta;
        vect2_direction(&direction, tan_new, 1);
        vect2_delta(&span, &direction);
        loop++;
    }

    n_int dx = (end_vector[0].x - start_vector[1].x);
    n_int dy = (end_vector[0].y - start_vector[1].y);
    n_int dix = (span.x - start_vector[1].x);
    n_int diy = (span.y - start_vector[1].y);

    n_int divisor = 0;

    if (dx && dy)
    {
        divisor = ((dix / dx) + (diy / dy)) / 2;
    }
    else
    {
        if (dx)
        {
            divisor = (dix / dx);
        }
        else if (dy)
        {
            divisor = (diy / dy);
        }
    }

    if (divisor == 0)
    {
        return -1;
    }

    /* final calculation */
    loop = 0;

    tan_new = tan_start;

    span.x = start_vector[1].x;
    span.y = start_vector[1].y;

    while (loop < number_elements)
    {
        n_vect2 direction;
        tan_new += tan_delta;
        vect2_direction(&direction, tan_new, divisor);
        vect2_delta(&span, &direction);
        elements[loop].x = span.x;
        elements[loop].y = span.y;
        loop++;
    }

    return 0;
}

n_int math_spread_byte( n_byte val )
{
    n_int result = ( n_int )( val >> 1 );

    if ( ( val & 1 ) == 1 )
    {
        result = 0 - result;
    }
    return result;
}

#ifdef DEBUG_RANDOM

n_uint debug_random_count = 0;

void math_random_debug_count( n_string string )
{
    printf( "debug random count (%s) %ld\n", string, debug_random_count );
}

#endif

/**
 Generates a random number from two change-able two-byte random number
 values passed into the function in the form of a pointer.
 @param local The pointer leading to both the two-byte numbers used to seed (and change
 in the process).
 @return The two-byte random number produced.
 */

#ifdef DEBUG_RANDOM
n_byte2 math_random_debug( n_byte2 *local, n_string file_string, n_int line_number )
#else
n_byte2 math_random( n_byte2 *seed )
#endif
{
    n_byte2 tmp0 = seed[0];
    n_byte2 tmp1 = seed[1];
    n_int runIt = 1;

    seed[0] = tmp1;
    n_byte tempAnd7 = tmp0 & 7;
    
    if (tempAnd7 == 0) {
        seed[0] = ( tmp1 ^ ( tmp0 >> 3 ) ^ 23141 );
        runIt = 0;
    }
    if (tempAnd7 == 3) {
        seed[1] = ( tmp0 ^ ( tmp1 >> 1 ) ^ 53289 );
        runIt = 0;
    }
    if (tempAnd7 == 5) {
        seed[1] = ( tmp1 ^ ( tmp0 >> 2 ) ^ 44550 );
        runIt = 0;
    }
    if (runIt == 1) {
        seed[1] = ( tmp0 ^ ( tmp1 >> 1 ) );
    }

#ifdef DEBUG_RANDOM
#ifdef VERBOSE_DEBUG_RANDOM
    if ( ( debug_random_count & 15 ) == 0 )
    {
        printf( "\n(%ld %s %ld) %d ", debug_random_count++, file_string, line_number, tmp1 );
    }
    else
    {
        printf( " %d ", tmp1 );
    }
#endif
    debug_random_count++;
#endif

    return ( tmp1 );
}

#ifndef DEBUG_RANDOM

void math_random3( n_byte2 *local )
{
    NA_ASSERT( local, "local NULL" );

    ( void )math_random( local );
    ( void )math_random( local );
    ( void )math_random( local );
}

#endif

/* math_newton_root may need to be obsoleted */
n_uint math_root( n_uint input )
{
    n_uint op  = input;
    n_uint res = 0;
    n_uint one = 1uL << ( ( sizeof( n_uint ) * 8 ) - 2 );
    /* "one" starts at the highest power of four <= than the argument. */
    while ( one > op )
    {
        one >>= 2;
    }
    while ( one != 0 )
    {
        if ( op >= res + one )
        {
            op = op - ( res + one );
            res = res +  2 * one;
        }
        res >>= 1;
        one >>= 2;
    }
    return res;
}

/* from ASCII 32 - 127, corresponding to the seg14 results */

/* n_byte segment = seg14[ conv[ character_value ]]; */
static const n_byte    conv[ 96 ] =
{
    0, 40, 41, 0, 0, 0, 0, 42, 43, 44, 38, 39, 45, 11, 46, 47, 1, 2, 3, 4, 5, 6, 7,
    8, 9, 10, 48, 49, 0, 50, 0, 51, 0, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
    23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 52, 53, 54, 0, 55, 56,
    12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
    32, 33, 34, 35, 36, 37, 57, 58, 59, 0, 0
};

/* one bit per segment */
static const n_byte2 seg14[ 60 ] =
{
    0x0000, 0x3F00, 0x1800, 0x36C0, 0x3CC0, 0x19C0, 0x2DC0, 0x2FC0, 0x3800, 0x3FC0,
    0x3DC0, 0x00C0, 0x3BC0, 0x3CA1, 0x2700, 0x3C21, 0x27C0, 0x23C0, 0x2F80, 0x1BC0,
    0x2421, 0x1E00, 0x0354, 0x0700, 0x1B06, 0x1B12, 0x3F00, 0x33C0, 0x3F10, 0x33D0,
    0x2DC0, 0x2021, 0x1F00, 0x030C, 0x1B18, 0x001E, 0x11E0, 0x240C, 0x00FF, 0x00E1,

    0x8001, 0x0101, 0x0001, 0x0014, 0x000A, 0x0008, 0x8000, 0x000C, 0xC000, 0x4008,
    0x04C0, 0xA004, 0x2700, 0x0012, 0x3402, 0x0400, 0x0002, 0x244A, 0x0021, 0x2494
};

n_int math_seg14( n_int character )
{
    return seg14[conv[character]];
}

static n_int math_max( n_int a, n_int b )
{
    return ( a < b ) ? b : a;
}

static n_int math_min( n_int a, n_int b )
{
    return !( b < a ) ? a : b;
}

/*
 * Line segment intersection test using parametric line equations.
 *
 * Two line segments can be represented as:
 * Segment 1: P1 + t1 * (Q1 - P1) where t1  [0,1]
 * Segment 2: P2 + t2 * (Q2 - P2) where t2  [0,1]
 *
 * At intersection: P1 + t1 * dir1 = P2 + t2 * dir2
 * Solving for t1 and t2, if both are in [0,1], segments intersect.
 */
n_byte math_do_intersect(n_vect2 *p1, n_vect2 *q1, n_vect2 *p2, n_vect2 *q2)
{
    /* Calculate direction vectors for both line segments */
    n_int dir1_x = q1->x - p1->x;
    n_int dir1_y = q1->y - p1->y;
    n_int dir2_x = q2->x - p2->x;
    n_int dir2_y = q2->y - p2->y;
    
    /* Calculate cross product of direction vectors */
    n_int cross_product = dir1_x * dir2_y - dir1_y * dir2_x;
    
    /* If cross product is 0, direction vectors are parallel (no intersection) */
    if (cross_product == 0)
    {
        return 0;
    }
    
    /* Calculate vector from p2 to p1 */
    n_int p2_to_p1_x = p1->x - p2->x;
    n_int p2_to_p1_y = p1->y - p2->y;
    
    /* Calculate numerators for the parametric equations */
    n_int t1_numerator = dir2_x * p2_to_p1_y - dir2_y * p2_to_p1_x;
    n_int t2_numerator = dir1_x * p2_to_p1_y - dir1_y * p2_to_p1_x;
    
    /*
     * Check if intersection point lies on both segments by ensuring 0 <= t1 <= 1 and 0 <= t2 <= 1
     * Since t1 = t1_numerator / cross_product and t2 = t2_numerator / cross_product,
     * we need to check the sign of cross_product to avoid division and handle negatives correctly.
     */
    if (cross_product > 0)
    {
        return (t1_numerator >= 0 && t1_numerator <= cross_product &&
                t2_numerator >= 0 && t2_numerator <= cross_product);
    }
    else
    {
        return (t1_numerator <= 0 && t1_numerator >= cross_product &&
                t2_numerator <= 0 && t2_numerator >= cross_product);
    }
}


/* ./toolkit/memory.c */
/****************************************************************

 memory.c

 =============================================================



 ****************************************************************/

/*! \file   memory.c
 *  \brief  Covers the low level input and output relating to memory.
 */

#include "toolkit.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>


static memory_execute * static_execution = 0;

void memory_execute_set(memory_execute * value)
{
    static_execution = value;
}

void memory_execute_run(void)
{
    if (static_execution)
    {
        static_execution();
    }
}

/**
 * This is a historical legacy function as all platforms now use memcpy. Although in the future this may change.
 * @param from pointer to copy from.
 * @param to pointer to copy to.
 * @param number the number of bytes to copy.
 */
void memory_copy( n_byte *from, n_byte *to, n_uint number )
{
    memcpy( to, from, number );
}

/**
 * This is a historical legacy function as all platforms now use malloc. Although in the future this may change.
 * @param bytes number of bytes to allocate.
 * @return a void* pointer of the allocated bytes.
 */
void 	*memory_new( n_uint bytes )
{
    void 	*tmp = 0L;
    if ( bytes )
    {
        tmp = ( void * ) malloc( bytes );
    }
    return ( tmp );
}

/**
 * This is a historical legacy function as all platforms now use free. Although in the future this may change.
 * @param ptr the void * pointer to be freed. Should really be a void ** to catch the 0L-ing.
 */
void memory_free( void **ptr )
{
    if ( *ptr != 0L )
    {
        free( *ptr );
        *ptr = 0L;
    }
}

/**
 * This is allocates a range of memory depending on availability.
 * @param memory_min the minimum possible allocated memory before returning 0L.
 * @param memory_allocated the starting value for memory size and returning the actual size.
 * @return a void* pointer of the allocated bytes.
 */
void *memory_new_range( n_uint memory_min, n_uint *memory_allocated )
{
    void *memory_buffer = 0L;
    do
    {
        memory_buffer = ( void * ) malloc( *memory_allocated );
        if ( memory_buffer == 0L )
        {
            *memory_allocated = ( ( *memory_allocated ) * 3 ) >> 2;
        }
    }
    while ( ( memory_buffer == 0L ) && ( ( *memory_allocated ) > memory_min ) );
    return memory_buffer;
}


void memory_erase( n_byte *buf_offscr, n_uint nestop )
{
    memset( buf_offscr, 0, nestop );
}

memory_list *memory_list_new( n_uint size, n_uint number )
{
    memory_list *new_list = ( memory_list * )memory_new( sizeof( memory_list ) );
    if ( new_list )
    {
        new_list->data = ( n_byte * )memory_new( size * number );
        if ( new_list->data == 0L )
        {
            memory_free( ( void ** )&new_list );
            return 0L;
        }
        new_list->count = 0;
        new_list->max = number;
        new_list->unit_size = size;
    }
    return new_list;
}

void memory_list_copy( memory_list *list, n_byte *data, n_uint size)
{
    memory_copy( data, &( list->data[list->unit_size * list->count] ), size );
    list->count += (size /(list->unit_size));
    if (size % (list->unit_size))
    {
        (void)SHOW_ERROR("wrong base unit size");
    }

    if ( list->count >= list->max )
    {
        n_uint   new_max = ( list->max * 2 );
        n_uint   new_size = new_max * list->unit_size;
        n_byte *new_range = memory_new( new_size );
        NA_ASSERT( new_range, "range failed to allocate" );
        if ( new_range )
        {
            memory_copy( list->data, new_range, new_size / 2 );
            memory_free( ( void ** ) & ( list->data ) );
            list->max = new_max;
            list->data = new_range;
        }
    }
}

void memory_list_free( memory_list **value )
{
    memory_list *list = *value;
    memory_free( ( void ** ) & ( list->data ) );
    memory_free( ( void ** )value );
}

int_list *int_list_new( n_uint number )
{
    return (int_list *)memory_list_new( sizeof(n_int), number );
}

void int_list_copy( int_list *list, n_int int_add)
{
    memory_list_copy(list, (n_byte *) &int_add, sizeof(int_add));
}

void int_list_free( int_list **value )
{
    memory_list_free(value);
}

n_int int_list_find( int_list * list,  n_int location, n_int * error)
{
    n_int * data_int = (n_int *) list->data;

    if ((location > list->count) || (location < 0))
    {
        *error = -1;
        return SHOW_ERROR("Out of Bounds failure");
    }
    *error = 0;
    return data_int[location];
}

void int_list_debug( int_list * debug_list)
{
    n_int count = debug_list->count, loop = 0, error = 0;
    printf("count %ld max %ld\n - - - - - - - - - - - - - - - - - - -\n", debug_list->count, debug_list->max);
    while (loop < count)
    {
        n_int value = int_list_find( debug_list,  loop, &error );
        if (error == 0)
        {
            if (value == BIG_INTEGER)
            {
                printf("| ");
            }
            else
            {
                if ((value - BIG_NEGATIVE_INTEGER) <= object_get_hash_count())
                {
                    n_uint key_value = value - BIG_NEGATIVE_INTEGER;
                    printf("\n(%ld), ", key_value);
                }
                else
                {
                    printf("%ld, ", value);
                }
            }
        }
        else
        {
            printf("%ld (%ld), ", value, error);
        }
        loop++;
    }
    printf("\n");
}

number_array_list * number_array_list_new(void)
{
    return (number_array_list *) memory_list_new(sizeof(number_array), 10);
}

void number_array_list_free(number_array_list ** nal)
{
    memory_list_free( (memory_list**) nal );
}

static void number_array_list_copy(number_array_list * nal, number_array * na)
{
    memory_list_copy(nal, (n_byte *)na, sizeof(number_array));
}

number_array * number_array_list_find(number_array_list * nal, void * array)
{
    n_int loop = 0;
    number_array * checkptr = (number_array *)nal->data;
    while (loop < nal->count)
    {
        if (checkptr[loop].array == array)
        {
            return &checkptr[loop];
        }
        loop++;
    }
    return 0L;
}

number_array * number_array_list_find_add(number_array_list * nal, void * array)
{
    n_int loop = 0;
    number_array * checkptr = (number_array *)nal->data;
    while (loop < nal->count)
    {
        if (checkptr[loop].array == array)
        {
            return &checkptr[loop];
        }
        loop++;
    }

    number_array * return_value = memory_new(sizeof(number_array));
    return_value->array = array;
    return_value->number = int_list_new(8);

    number_array_list_copy(nal, return_value);

    return return_value;
}

void number_array_not_number(number_array * na)
{
    if (na)
    {
        if (na->number)
        {
            int_list_free(&(na->number));
        }
        (void)SHOW_ERROR("number array values not present (clear)");
    }
    (void)SHOW_ERROR("number array not present (clear)");
}

void number_array_number(number_array * na, n_int number)
{
    if (na)
    {
        if (na->number)
        {
            int_list_copy(na->number, number);
        }
        else
        {
            (void)SHOW_ERROR("number array values not present (copy)");
            return;
        }
    }
    else
    {
        (void)SHOW_ERROR("number array not present (copy)");
    }
}

n_int number_array_get_number(number_array * na, n_int location, n_int * error)
{
    if (na)
    {
        if (na->number)
        {
            return int_list_find(na->number, location, error);
        }
        * error = -3;
        return SHOW_ERROR("number array values not present");
    }
    * error = -2;
    return SHOW_ERROR("number array not present");
}

n_int number_array_get_size(number_array * na)
{
    if (na)
    {
        if (na->number)
        {
            return na->number->count;
        }
        return SHOW_ERROR("number array values not present (size)");
    }
    return SHOW_ERROR("number array not present (size)");
}


/* ./toolkit/object.c */
/****************************************************************

 object.c

 =============================================================



 ****************************************************************/

/*! \file   object.c
 *  \brief  Provides a primitive object type to allow for dynamic
 *          object creation and also reading and writing in a
 *          JSON format.
 */
#if 1

#include "toolkit.h"
#include <stdio.h>

static void object_write_object( n_file *file, n_object *start );
static void object_write_array( n_file *file, n_array *start );


#undef OBJECT_DEBUG

#undef OBJECT_RETAIN1
#define OBJECT_RETAIN2 // diff name
#define OBJECT_RETAIN3 // warfare to run but with leak


#ifdef OBJECT_RETAIN1

#define STRING_COPY1(value) io_string_copy(value)

#else

#define STRING_COPY1(value) (value)

#endif

#ifdef OBJECT_RETAIN2

#define STRING_COPY2(value) io_string_copy(value)

#else

#define STRING_COPY2(value) (value)

#endif

#ifdef OBJECT_RETAIN3

#define STRING_COPY3(value) io_string_copy(value)

#else

#define STRING_COPY3(value) (value)

#endif

#ifdef OBJECT_DEBUG

#define OBJ_DBG( test, string ) if (test == 0L) printf("%s\n", string)

#else

#define OBJ_DBG( test, string ) /* test string */

#endif

static n_object *object_file_base( n_file *file );

static number_array_list    * object_number_array_list = 0L;

static n_uint * object_hashes = 0L;
static n_uint object_hash_count = 0;


n_uint object_get_hash_count(void)
{
    return object_hash_count;
}

void object_init(n_uint * hashes, n_uint hash_count)
{
    object_number_array_list = number_array_list_new();
    object_hashes = hashes;
    object_hash_count = hash_count;
}

void object_ptr_debug(void * ptr)
{
    n_uint      ptr_repr = (n_uint)ptr;

    printf("%ld\n", ptr_repr);
}

void object_close(void)
{
    number_array * checkptr = (number_array *)object_number_array_list->data;
    n_int          loop = 0, array_count = object_number_array_list->count;
    printf("\n array_count %ld\n", array_count);
    while (loop < array_count)
    {
        number_array * location = &checkptr[loop];
        int_list     * il_repr = location->number;
        printf("\n");
        object_ptr_debug(location->array);
        printf("\n");
        int_list_debug(il_repr);

        loop ++;
    }


    number_array_list_free(&object_number_array_list);
}

void object_array_add_number(void * array, n_int number)
{
    if (object_number_array_list)
    {
        if (array)
        {
            number_array * num_array = number_array_list_find_add(object_number_array_list, array);
            if (num_array)
            {
                number_array_number(num_array, number);

                /*                printf("number_array_number\n");*/

            }
            else
            {
                printf("no num_array\n");
            }
        }
        else
        {
            /*            printf("no array\n");*/
        }
    }
    else
    {
        /*        printf("no object_number_array_list\n");*/
    }
}

void object_array_not_number(void * array)
{
    if (object_number_array_list)
    {
        if (array)
        {
            number_array * num_array = number_array_list_find_add(object_number_array_list, array);
            if (num_array)
            {
                number_array_not_number(num_array);
            }
        }
    }
}

static n_object_type object_type( n_array *array )
{
    return array->type;
}

static void object_erase( n_object *object )
{
    memory_erase( ( n_byte * )object, sizeof( n_object ) );
}

static n_object *object_new( void )
{
    n_object *return_object = ( n_object * )memory_new( sizeof( n_object ) );
    if ( return_object )
    {
        object_erase( return_object );
    }
    return return_object;
}

void obj_free( n_object **object );

static void obj_free_array( n_int is_array, void **payload, n_object_type type )
{
    n_array *array = 0L;

    if ( is_array )
    {
        array = ( n_array * )( *payload );
    }
    else
    {
        n_object *array_object =  ( n_object * )( *payload );
        array = ( n_array * ) & ( array_object->primitive );
    }


    if ( type == OBJECT_NUMBER )
    {

    }
    if ( type == OBJECT_BOOLEAN )
    {

    }
    if ( type == OBJECT_STRING )
    {
        memory_free( ( void ** )&array->data );
    }
    if ( type == OBJECT_ARRAY )
    {
        n_array *local_array = obj_get_array( array->data );
        obj_free_array( 1, ( void ** )&local_array, local_array->type );
    }
    if ( type == OBJECT_OBJECT )
    {
        n_object *object = obj_get_object( array->data );
        obj_free( &object );
    }
    if ( array->next )
    {
        if ( is_array )
        {
            n_array *next_array = ( n_array * )array->next;
            obj_free_array( 1, ( void ** )&next_array, next_array->type );
        }
        else
        {
            obj_free( ( n_object ** )&array->next );
        }
    }
    memory_free( payload );
}

void obj_free( n_object **object )
{
    n_array *string_primitive = &( ( *object )->primitive );
    memory_free( ( void ** ) & ( *object )->name );
    obj_free_array( 0, ( void ** ) object, string_primitive->type );
}

void object_top_object( n_file *file, n_object *top_level )
{
    io_write( file, "{", 0 );
    object_write_object( file, top_level );
    io_write( file, "}", 0 );
}

static void object_top_array( n_file *file, n_array *top_level )
{
    io_write( file, "[", 0 );
    object_write_array( file, top_level );
    io_write( file, "]", 0 );
}

static void *object_write_primitive( n_file *file, n_array *primitive )
{
    switch ( object_type( primitive ) )
    {
    case OBJECT_NUMBER:
    {
        n_int *int_data = ( n_int * )&primitive->data;
        io_writenumber( file, int_data[0], 1, 0 );
    }
    break;
    case OBJECT_BOOLEAN:
    {
        n_int *int_data = ( n_int * )&primitive->data;
        if ( int_data[0] )
        {
            io_write( file, "true", 0 );
        }
        else
        {
            io_write( file, "false", 0 );
        }
    }
    break;
    case OBJECT_STRING:
        io_write( file, "\"", 0 );
        io_write( file, primitive->data, 0 );
        io_write( file, "\"", 0 );
        break;
    case OBJECT_OBJECT:
        object_top_object( file, ( n_object * )primitive->data );
        break;
    case OBJECT_ARRAY:
        object_top_array( file, ( n_array * )primitive->data );
        break;
    default:
        ( void )SHOW_ERROR( "Object kind not found" );
        return 0L;
    }
    if ( primitive->next )
    {
        io_write( file, ",", 0 );
    }
    return primitive->next;
}

n_array *obj_get_array( n_string array )
{
    return ( n_array * )array;
}

n_object *obj_get_object( n_string object )
{
    return ( n_object * )object;
}

n_int obj_get_number( n_string object )
{
    n_int *data = ( n_int * )&object;
    return data[0];
}

n_int obj_get_boolean( n_string object )
{
    return obj_get_number( object );
}

static void object_write_object( n_file *file, n_object *start )
{
    n_object *current = start;
    do
    {
        if (current)
        {
            io_write( file, "\"", 0 );
            io_write( file, current->name, 0 );
            io_write( file, "\":", 0 );
            current = ( n_object * )object_write_primitive( file, &current->primitive );
        }
    }
    while ( current );
}

static void object_write_array( n_file *file, n_array *start )
{
    n_array *current = start;
    do
    {
        current = ( n_array * )object_write_primitive( file, current );
    }
    while ( current );
}

n_file *unknown_json( void *unknown, n_object_type type )
{
    n_file *output_file = 0L;
    if ( type == OBJECT_OBJECT )
    {
        output_file = io_file_new();
        object_top_object( output_file, ( n_object * )unknown );
    }
    if ( type == OBJECT_ARRAY )
    {
        output_file = io_file_new();
        object_top_array( output_file, ( n_array * )unknown );
    }
    return output_file;
}

static n_object *object_end_or_find( n_object *object, n_string name )
{
    n_object *previous_object = 0L;
    n_int      string_length = io_length( name, STRING_BLOCK_SIZE );
    if ( string_length > 0 )
    {
        n_uint     hash = math_hash( ( n_byte * )name, ( n_uint ) string_length );
        if ( object == 0L )
        {
            return 0L;
        }
        do
        {
            if ( hash == object->name_hash )
            {
                return previous_object;
            }
            previous_object = object;
            object = object->primitive.next;
        }
        while ( object );
    }
    return previous_object;
}

static n_object *obj_get( n_object *object, n_string name )
{
    n_object *set_object;
    n_int      string_length = io_length( name, STRING_BLOCK_SIZE );

    if ( string_length > 0 )
    {
        n_uint     hash = math_hash( ( n_byte * )name, ( n_uint )string_length );
        if ( object == 0L )
        {
            object = object_new();
        }
        if ( object_type( &object->primitive ) == OBJECT_EMPTY )
        {
            set_object = object;
        }
        else
        {
            n_object *previous_object = object_end_or_find( object, name );
            if ( previous_object == 0L )
            {
                set_object = object;
            }
            else
            {
                set_object = previous_object->primitive.next;
                if ( set_object == 0L )
                {
                    set_object = object_new();
                }
                previous_object->primitive.next = set_object;
            }
        }

        set_object->name = STRING_COPY1( name );
        set_object->name_hash = hash;

        return set_object;
    }
    return 0L;
}

n_array *array_add( n_array *array, n_array * element )
{
    if ( array )
    {
        n_array *next = array;
        do
        {
            if ( next->next )
            {
                next = next->next;
            }
        }
        while ( next->next );
        next->next = element;
    }

    return element;
}

void array_add_empty(n_array ** array, n_array * element)
{
    if (*array)
    {
        array_add(*array, element);
    }
    else
    {
        *array = array_add(0L, element);
    }
}

static void *ar_pass_through( void *ptr )
{
    if ( ptr == 0L )
    {
        ptr = memory_new( sizeof( n_array ) );
        if ( ptr )
        {
            memory_erase( ( n_byte * )ptr, sizeof( n_array ) );
        }
    }
    return ptr;
}

static void *ar_number( void *ptr, n_int set_number )
{
    n_array *cleaned = ( n_array * )ar_pass_through( ptr );
    if ( cleaned )
    {
        n_int     *number;
        cleaned->type = OBJECT_NUMBER;
        number = ( n_int * )&cleaned->data;
        number[0] = set_number;
    }
    return ( void * )cleaned;
}

static void *ar_boolean( void *ptr, n_int set_boolean )
{
    n_array *cleaned = ( n_array * )ar_pass_through( ptr );
    if ( cleaned )
    {
        n_int     *number;
        cleaned->type = OBJECT_BOOLEAN;
        number = ( n_int * )&cleaned->data;
        number[0] = set_boolean;
    }
    return ( void * )cleaned;
}

static void *ar_string( void *ptr, n_string set_string )
{
    n_array *cleaned = ( n_array * )ar_pass_through( ptr );
    if ( cleaned )
    {
        cleaned->type = OBJECT_STRING;
        cleaned->data = STRING_COPY2( set_string );
    }
    return ( void * )cleaned;
}

static void *ar_object( void *ptr, n_object *set_object )
{
    n_array *cleaned = ( n_array * )ar_pass_through( ptr );
    if ( cleaned )
    {
        cleaned->type = OBJECT_OBJECT;
        cleaned->data = ( n_string )set_object;
    }
    return ( void * )cleaned;
}

static void *ar_array( void *ptr, n_array *set_array )
{
    n_array *cleaned = ( n_array * )ar_pass_through( ptr );
    if ( cleaned )
    {
        cleaned->type = OBJECT_ARRAY;
        cleaned->data = ( n_string )set_array;
    }
    return ( void * )cleaned;
}

n_array *array_boolean( n_int set_boolean )
{
    return ar_boolean( 0L, set_boolean );
}

n_array *array_number( n_int set_number )
{
    return ar_number( 0L, set_number );
}

n_array *array_string( n_string set_string )
{
    return ar_string( 0L, set_string );
}

n_array *array_object( n_object *set_object )
{
    return ar_object( 0L, set_object );
}

n_array *array_array( n_array *set_array )
{
    return ar_array( 0L, set_array );
}

static n_object *obj_boolean( n_object *obj, n_string name, n_int boolean )
{
    return ar_boolean( obj_get( obj, name ), boolean );
}

static n_object *obj_number( n_object *obj, n_string name, n_int number )
{
    return ar_number( obj_get( obj, name ), number );
}

static n_object *obj_string( n_object *obj, n_string name, n_string string )
{
    return ar_string( obj_get( obj, name ), string );
}

static n_object *obj_object( n_object *obj, n_string name, n_object *object )
{
    return ar_object( obj_get( obj, name ), object );
}

static n_object *obj_array( n_object *obj, n_string name, n_array *array )
{
    return ar_array( obj_get( obj, name ), array );
}

n_object *object_number( n_object *obj, n_string name, n_int number )
{
    return obj_number( obj, io_string_copy( name ), number );
}

n_object *object_boolean( n_object *obj, n_string name, n_int boolean )
{
    return obj_boolean( obj, name, boolean );
}

n_object *object_string( n_object *obj, n_string name, n_string string )
{
    return obj_string( obj, io_string_copy( name ), string );
}

n_object *object_object( n_object *obj, n_string name, n_object *object )
{
    return obj_object( obj, io_string_copy( name ), object );
}

n_object *object_array( n_object *obj, n_string name, n_array *array )
{
    return obj_array( obj, io_string_copy( name ), array );
}

static n_int tracking_array_open;
static n_int tracking_object_open;
static n_int tracking_string_quote;

#define CHECK_FILE_SIZE(error_string)   if (file->location >= file->size) \
                                        { \
                                            (void)SHOW_ERROR(error_string); \
                                            return 0L; \
                                        }

static n_string object_file_read_string( n_file *file )
{
    n_string return_string = 0L;
    n_string_block block_string = {0};
    n_int          location = 0;
    if ( file->data[file->location] != '"' ) // TODO: Replace with smart char handling
    {
        ( void )SHOW_ERROR( "json not string as expected" );
        return return_string;
    }

    tracking_string_quote = 1;

    file->location ++;
    do
    {
        CHECK_FILE_SIZE( "end of json file reach unexpectedly" );
        if ( file->data[file->location] != '"' )
        {
            block_string[location] = ( n_char )file->data[file->location];
            location++;
            file->location++;
        }
    }
    while ( file->data[file->location] != '"' );
    if ( location == 0 )
    {
        ( void )SHOW_ERROR( "blank string in json file" );
        return 0L;
    }
    tracking_string_quote = 0;
    file->location++;
    CHECK_FILE_SIZE( "end of json file reach unexpectedly" );
    return_string = STRING_COPY3( block_string );
    return return_string;
}


static n_int object_file_read_number( n_file *file, n_int *with_error )
{
    n_int return_number = 0;
    n_string_block block_string = {0};
    n_int          location = 0;
    n_byte         read_char = file->data[file->location];
    n_int          char_okay = ( ASCII_NUMBER( read_char ) || ( read_char == '-' ) );
    *with_error = 1;

    if ( !char_okay )
    {
        ( void )SHOW_ERROR( "first character not number or minus" );
        return 0;
    }

    CHECK_FILE_SIZE( "end of json file reach unexpectedly for number" );

    block_string[location] = ( n_char )read_char;
    file->location++;
    location++;


    do
    {
        read_char = file->data[file->location];
        char_okay = ASCII_NUMBER( read_char );

        CHECK_FILE_SIZE( "end of json file reach unexpectedly for number" );

        if ( char_okay )
        {
            block_string[location] = ( n_char )read_char;
            location++;
            file->location++;
        }

    }
    while ( char_okay );

    {
        n_int actual_value = 1;
        n_int decimal_divisor = 1;
        n_int error_number = io_number( ( n_string )block_string, &actual_value, &decimal_divisor );

        if ( error_number == -1 )
        {
            return 0;
        }

        if ( decimal_divisor != 0 )
        {
            ( void )SHOW_ERROR( "decimal number in json file" );
            return 0;
        }
        return_number = actual_value;
    }
    *with_error = 0;
    return return_number;
}

static n_int object_file_read_boolean( n_file *file, n_int *with_error )
{
    n_int          return_number = 0;
    n_byte         read_char = file->data[file->location];
    n_int          char_okay;
    n_char        *allowed[2] = {"fals", "true"};
    n_int          allowed_advance = 1;
    *with_error = 1;

    if ( read_char == allowed[0][0] )
    {
        return_number = 0;
    }
    else if ( read_char == allowed[1][0] )
    {
        return_number = 1;
    }
    else
    {
        ( void )SHOW_ERROR( "not valid boolean (first character)" );
        return 0;
    }

    file->location++;

    while ( allowed_advance < 4 )
    {
        CHECK_FILE_SIZE( "end of json file reach unexpectedly for boolean" );

        read_char = file->data[file->location];
        char_okay = allowed[return_number][allowed_advance] == read_char;

        if ( char_okay )
        {
            file->location++;
        }
        else
        {
            ( void )SHOW_ERROR( "not valid boolean" );
            return 0;
        }
        allowed_advance++;
    }

    if ( return_number == 0 )
    {
        read_char = file->data[file->location];
        char_okay = 'e' == read_char;

        CHECK_FILE_SIZE( "end of json file reach unexpectedly for number" );

        if ( char_okay )
        {
            file->location++;
        }
        else
        {
            ( void )SHOW_ERROR( "not valid boolean (false)" );
            return 0;
        }
    }
    *with_error = 0;
    return return_number;
}

static n_object_stream_type object_stream_char( n_byte value )
{
    if ( value == '{' )
    {
        return OBJ_TYPE_OBJECT_OPEN;
    }
    if ( value == '}' )
    {
        return OBJ_TYPE_OBJECT_CLOSE;
    }
    if ( value == '[' )
    {
        return OBJ_TYPE_ARRAY_OPEN;
    }
    if ( value == ']' )
    {
        return OBJ_TYPE_ARRAY_CLOSE;
    }
    if ( ( value == 't' ) || ( value == 'f' ) )
    {
        return OBJ_TYPE_BOOLEAN;
    }
    if ( ASCII_NUMBER( value ) || ( value == '-' ) )
    {
        return OBJ_TYPE_NUMBER;
    }
    if ( ASCII_COMMA( value ) )
    {
        return OBJ_TYPE_COMMA;
    }
    if ( ASCII_COLON( value ) )
    {
        return OBJ_TYPE_COLON;
    }
    if ( ASCII_QUOTE( value ) )
    {
        return OBJ_TYPE_STRING_NOTATION;
    }
    return OBJ_TYPE_EMPTY;
}

n_array *number_base_array = 0L;


static n_array *object_file_array( n_file *file )
{
    n_array *base_array = 0L;

    n_object_stream_type stream_type;
    n_object_stream_type stream_type_in_this_array = OBJ_TYPE_EMPTY;

    if ( object_stream_char( file->data[file->location] ) != OBJ_TYPE_ARRAY_OPEN )
    {
        ( void )SHOW_ERROR( "json not array as expected" );
        return base_array;
    }

    tracking_array_open ++;

    file->location ++;
    do
    {
        CHECK_FILE_SIZE( "end of json file reach unexpectedly" );
        stream_type = object_stream_char( file->data[file->location] );

        if ( stream_type_in_this_array == OBJ_TYPE_EMPTY )
        {
            stream_type_in_this_array = stream_type;
        }
        else if ( stream_type_in_this_array != stream_type )
        {
            ( void )SHOW_ERROR( "array contains multiple types" );
            return 0L;
        }

        if ( stream_type == OBJ_TYPE_ARRAY_OPEN )
        {
            n_array *array_value = object_file_array( file );
            if ( array_value )
            {
                stream_type = object_stream_char( file->data[file->location] );

                if ( ( stream_type == OBJ_TYPE_ARRAY_CLOSE ) || ( stream_type == OBJ_TYPE_COMMA ) )
                {
                    if ( base_array == 0L )
                    {
                        base_array = array_array( array_value );
                    }
                    else
                    {
                        array_add( base_array, array_array( array_value ) );
                    }
                }
            }
            stream_type = object_stream_char( file->data[file->location] );
        }
        if ( stream_type == OBJ_TYPE_OBJECT_OPEN )
        {
            n_object *object_value = object_file_base( file );
            OBJ_DBG( object_value, "object value is nil?" );
            if ( object_value )
            {
                file->location++;
                CHECK_FILE_SIZE( "end of json file reach unexpectedly" );
                stream_type = object_stream_char( file->data[file->location] );

                if ( ( stream_type == OBJ_TYPE_ARRAY_CLOSE ) || ( stream_type == OBJ_TYPE_COMMA ) )
                {
                    if ( base_array == 0L )
                    {
                        base_array = array_object( object_value );
                    }
                    else
                    {
                        array_add( base_array, array_object( object_value ) );
                    }
                }
            }

            OBJ_DBG( base_array, "base array still nil?" );

            CHECK_FILE_SIZE( "end of json file reach unexpectedly" );
            stream_type = object_stream_char( file->data[file->location] );
        }
        if ( stream_type == OBJ_TYPE_STRING_NOTATION )
        {
            n_string string_value = object_file_read_string( file );
            if ( string_value )
            {
                stream_type = object_stream_char( file->data[file->location] );

                if ( ( stream_type == OBJ_TYPE_ARRAY_CLOSE ) || ( stream_type == OBJ_TYPE_COMMA ) )
                {
                    if ( base_array == 0L )
                    {
                        base_array = array_string( string_value );
                    }
                    else
                    {
                        array_add( base_array, array_string( string_value ) );
                    }
                }
            }
        }
        if ( stream_type == OBJ_TYPE_NUMBER )
        {
            n_int with_error;
            n_int number_value = object_file_read_number( file, &with_error );

            if ( with_error == 0 )
            {
                stream_type = object_stream_char( file->data[file->location] );

                if ( ( stream_type == OBJ_TYPE_ARRAY_CLOSE ) || ( stream_type == OBJ_TYPE_COMMA ) )
                {
                    if ( base_array == 0L )
                    {
                        base_array = array_number( number_value );
                    }
                    else
                    {
                        array_add( base_array, array_number( number_value ) );
                    }
                }

                if (number_base_array == 0L)
                {
                    number_base_array = base_array;
                }

                object_array_add_number(number_base_array, number_value);
            }
        }
        if ( stream_type == OBJ_TYPE_BOOLEAN )
        {
            n_int with_error;
            n_int boolean_value = object_file_read_boolean( file, &with_error );

            if ( with_error == 0 )
            {
                stream_type = object_stream_char( file->data[file->location] );

                if ( ( stream_type == OBJ_TYPE_ARRAY_CLOSE ) || ( stream_type == OBJ_TYPE_COMMA ) )
                {
                    if ( base_array == 0L )
                    {
                        base_array = array_boolean( boolean_value );
                    }
                    else
                    {
                        array_add( base_array, array_boolean( boolean_value ) );
                    }
                }
            }
        }
        if ( stream_type == OBJ_TYPE_ARRAY_CLOSE )
        {
            tracking_array_open --;

            /* TODO: This is based on a sign array layer then getting to the data */
            if (tracking_array_open == 2)
            {
                object_array_add_number(number_base_array, BIG_INTEGER);
            }
            if (tracking_array_open == 1)
            {
                number_base_array = 0L;
            }
        }
        file->location ++;

        OBJ_DBG( base_array, "base array nil check?" );
    }
    while ( stream_type == OBJ_TYPE_COMMA );

    OBJ_DBG( base_array, "base array really nil?" );

    return base_array;
}

static n_int object_string_key(n_string string_key)
{
    n_uint string_hash = math_hash((n_byte *)string_key, io_length(string_key, STRING_BLOCK_SIZE));
    /*
     static n_uint * object_hashes = 0L;
     static n_uint object_hash_count = 0;
     */

    if (object_hash_count == 0)
    {
        return -2;
    }
    if (object_hashes)
    {
        n_uint loop = 0;
        while (loop < object_hash_count)
        {
            if (object_hashes[loop] == string_hash)
            {
                return loop;
            }
            loop++;
        }
        return -3;
    }
    return -1;
}

static n_object *object_file_base( n_file *file )
{
    n_object *base_object = 0L;
    n_object_stream_type stream_type;
    CHECK_FILE_SIZE( "file read outside end of file" );

    stream_type = object_stream_char( file->data[file->location] );

    if ( stream_type == OBJ_TYPE_OBJECT_OPEN )
    {
        tracking_object_open++;
        do
        {
            file->location++;
            CHECK_FILE_SIZE( "file read outside end of file" );
            stream_type = object_stream_char( file->data[file->location] );
            if ( stream_type == OBJ_TYPE_STRING_NOTATION )
            {
                n_string string_key = object_file_read_string( file );
                if ( string_key )
                {
                    stream_type = object_stream_char( file->data[file->location] );
                    if ( stream_type == OBJ_TYPE_COLON )
                    {
                        file->location++;
                        CHECK_FILE_SIZE( "file read outside end of file" );
                        stream_type = object_stream_char( file->data[file->location] );

                        if ( stream_type == OBJ_TYPE_OBJECT_OPEN )
                        {
                            n_object *insert_object = object_file_base( file );
                            if ( insert_object )
                            {
                                if ( base_object )
                                {
                                    obj_object( base_object, string_key, insert_object );
                                }
                                else
                                {
                                    base_object = obj_object( base_object, string_key, insert_object );
                                }
                                file->location++;
                                CHECK_FILE_SIZE( "file read outside end of file" );
                                stream_type = object_stream_char( file->data[file->location] );
                            }
                        }
                        if ( stream_type == OBJ_TYPE_NUMBER )
                        {
                            n_int number_error;
                            n_int number_value = object_file_read_number( file, &number_error );
                            if ( number_error == 0 )
                            {
                                stream_type = object_stream_char( file->data[file->location] );
                                if ( ( stream_type == OBJ_TYPE_OBJECT_CLOSE ) || ( stream_type == OBJ_TYPE_COMMA ) )
                                {
                                    if ( base_object )
                                    {
                                        obj_number( base_object, string_key, number_value );
                                    }
                                    else
                                    {
                                        base_object = obj_number( base_object, string_key, number_value );
                                    }
                                }
                                CHECK_FILE_SIZE( "file read outside end of file" );
                                stream_type = object_stream_char( file->data[file->location] );
                            }
                        }
                        if ( stream_type == OBJ_TYPE_BOOLEAN )
                        {
                            n_int number_error;
                            n_int boolean_value = object_file_read_boolean( file, &number_error );
                            if ( number_error == 0 )
                            {
                                stream_type = object_stream_char( file->data[file->location] );
                                if ( ( stream_type == OBJ_TYPE_OBJECT_CLOSE ) || ( stream_type == OBJ_TYPE_COMMA ) )
                                {
                                    if ( base_object )
                                    {
                                        obj_boolean( base_object, string_key, boolean_value );
                                    }
                                    else
                                    {
                                        base_object = obj_boolean( base_object, string_key, boolean_value );
                                    }
                                }
                                CHECK_FILE_SIZE( "file read outside end of file" );
                                stream_type = object_stream_char( file->data[file->location] );
                            }
                        }
                        if ( stream_type == OBJ_TYPE_STRING_NOTATION )
                        {
                            n_string string_value = object_file_read_string( file );
                            if ( string_value )
                            {
                                stream_type = object_stream_char( file->data[file->location] );
                                if ( ( stream_type == OBJ_TYPE_OBJECT_CLOSE ) || ( stream_type == OBJ_TYPE_COMMA ) )
                                {
                                    if ( base_object )
                                    {
                                        obj_string( base_object, string_key, string_value );
                                    }
                                    else
                                    {
                                        base_object = obj_string( base_object, string_key, string_value );
                                    }
                                }
                                CHECK_FILE_SIZE( "file read outside end of file" );
                                stream_type = object_stream_char( file->data[file->location] );
                            }
                        }
                        if ( stream_type == OBJ_TYPE_ARRAY_OPEN )
                        {
                            n_array *array_value = object_file_array( file ); // TODO: rename object_file_read_array
                            if ( array_value )
                            {
                                stream_type = object_stream_char( file->data[file->location] );
                                if ( ( stream_type == OBJ_TYPE_OBJECT_CLOSE ) || ( stream_type == OBJ_TYPE_COMMA ) )
                                {
                                    n_int string_key_output = object_string_key(string_key);

                                    if (string_key_output > -1)
                                    {
                                        object_array_add_number(number_base_array, BIG_NEGATIVE_INTEGER + string_key_output);
                                    }

                                    if ( base_object )
                                    {
                                        obj_array( base_object, string_key, array_value );
                                    }
                                    else
                                    {
                                        base_object = obj_array( base_object, string_key, array_value );
                                    }
                                }
                                CHECK_FILE_SIZE( "file read outside end of file" );
                                stream_type = object_stream_char( file->data[file->location] );
                            }
                            OBJ_DBG( array_value, "array value nil?" );
                        }
                    }
                }
            }
            if ( stream_type == OBJ_TYPE_OBJECT_CLOSE )
            {
                tracking_object_open--;
            }
        }
        while ( stream_type == OBJ_TYPE_COMMA );
    }
    return base_object;
}

void unknown_free( void **unknown, n_object_type type )
{
    if ( type == OBJECT_ARRAY )
    {
        n_array **found_array = ( n_array ** )unknown;
        obj_free_array( 1, ( void ** )found_array, ( *found_array )->type );
    }
    if ( type == OBJECT_OBJECT )
    {
        n_object **found_object = ( n_object ** )unknown;
        obj_free( found_object );
    }
}

#define    JSON_WHITESPACE(num) ((((num)>8)&&((num)<14))||((num)==32))

void io_whitespace_json( n_file *input )
{
    n_uint    loop = 0, out_loop = 0;
    n_uint    end_loop = input->size;
    n_byte    *local_data = input->data;
    n_int     inside_string = 0;

    while ( loop < end_loop )
    {
        n_byte    temp = local_data[loop++];
        if ( temp == '"' )
        {
            inside_string ^= 1;
            local_data[out_loop++] = temp;
        }
        else if ( ( JSON_WHITESPACE( temp ) == 0 ) || inside_string )
        {
            local_data[out_loop++] = temp;
        }
    }

    loop = out_loop;

    while ( loop < end_loop )
    {
        local_data[loop++] = 0;
    }
    input->size = out_loop;
    input->location = 0;
}

void *unknown_file_to_tree( n_file *file, n_object_type *type )
{
    n_object  *base_object = 0L;
    n_array   *base_array = 0L;
    n_int      something_wrong = 0;

    n_object_stream_type stream_type;

    tracking_array_open = 0;
    tracking_object_open = 0;
    tracking_string_quote = 0;
    io_whitespace_json( file );
    file->location = 0;

    stream_type = object_stream_char( file->data[file->location] );

    if ( stream_type == OBJ_TYPE_OBJECT_OPEN )
    {
        *type = OBJECT_OBJECT;
        base_object = object_file_base( file );
    }

    if ( stream_type == OBJ_TYPE_ARRAY_OPEN )
    {
        *type = OBJECT_ARRAY;
        base_array = object_file_array( file );
    }

    if ( tracking_array_open != 0 )
    {
        ( void )SHOW_ERROR( "Array json does not match up" );
        something_wrong = 1;
    }
    if ( tracking_object_open != 0 )
    {
        ( void )SHOW_ERROR( "Object json does not match up" );
        something_wrong = 1;
    }
    if ( tracking_string_quote != 0 )
    {
        ( void )SHOW_ERROR( "String quote json does not match up" );
        something_wrong = 1;
    }
    if ( something_wrong )
    {
        printf("\n\n");

        printf("%c", file->data[file->location-3]);
        printf("%c", file->data[file->location-2]);
        printf("%c", file->data[file->location-1]);

        printf("~%c~", file->data[file->location]);

        printf("%c", file->data[file->location+1]);
        printf("%c", file->data[file->location+2]);
        printf("%c", file->data[file->location+3]);

        printf("\n\n");

        if ( base_object )
        {
            obj_free( &base_object );
        }
        if ( base_array )
        {
            obj_free_array( 1, ( void ** )&base_array, base_array->type );
        }
        return 0L;
    }
    if ( *type == OBJECT_ARRAY )
    {
        return ( void * )base_array;
    }

    return ( void * )base_object;
}

n_string obj_contains( n_object *base, n_string name, n_object_type type )
{
    n_object *return_object = base;
    n_int      string_length = io_length( name, STRING_BLOCK_SIZE );
    if ( string_length > 0 )
    {
        n_uint     hash = math_hash( ( n_byte * )name, ( n_uint )string_length );
        if ( return_object == 0L )
        {
            return 0L;
        }
        do
        {
            if ( ( hash == return_object->name_hash ) && ( type == object_type( &return_object->primitive ) ) )
            {
                return return_object->primitive.data;
            }
            return_object = return_object->primitive.next;
        }
        while ( return_object );
    }
    return 0L;
}

n_int obj_contains_number( n_object *base, n_string name, n_int *number )
{
    n_object *return_object = base;
    n_int      string_length = io_length( name, STRING_BLOCK_SIZE );
    if ( string_length > 0 )
    {
        n_uint     hash = math_hash( ( n_byte * )name, ( n_uint )string_length );
        if ( return_object == 0L )
        {
            return 0;
        }
        do
        {
            if ( ( hash == return_object->name_hash ) && ( OBJECT_NUMBER == object_type( &return_object->primitive ) ) )
            {
                n_int *data = ( n_int * )&return_object->primitive.data;
                number[0] = data[0];
                return 1;
            }
            return_object = return_object->primitive.next;
        }
        while ( return_object );
    }
    return 0;
}

n_array *obj_array_next( n_array *array, n_array *element )
{
    if ( element == 0L )
    {
        return array;
    }
    return ( n_array * )element->next;
}

n_int obj_array_count( n_array *array_obj )
{
    n_array *arr_second_follow = 0L;
    n_int     count = 0;
    if ( array_obj )
    {
        while ( ( arr_second_follow = obj_array_next( array_obj, arr_second_follow ) ) )
        {
            count++;
        }
    }
    return count;
}


n_int obj_contains_array_nbyte2( n_object *base, n_string name, n_byte2 *array_numbers, n_int size )
{
    n_string array_string;
    if ( ( array_string = obj_contains( base, name, OBJECT_ARRAY ) ) )
    {
        n_array *array_obj = obj_get_array( array_string );
        n_array *arr_follow = 0L;
        n_int     count = 0;
        n_int     estimated_size = obj_array_count( array_obj );
        if ( estimated_size != size )
        {
            return -1;
        }
        while ( ( arr_follow = obj_array_next( array_obj, arr_follow ) ) )
        {
            n_int follow_number = obj_get_number( arr_follow->data );
            array_numbers[count++] = follow_number;
            if ( count == size )
            {
                return 1;
            }
        }
    }
    return 0;
}

n_int obj_contains_array_numbers( n_object *base, n_string name, n_int *array_numbers, n_int size )
{
    n_string array_string;
    if ( ( array_string = obj_contains( base, name, OBJECT_ARRAY ) ) )
    {
        n_array *array_obj = obj_get_array( array_string );
        n_array *arr_follow = 0L;
        n_int     count = 0;
        n_int     estimated_size = obj_array_count( array_obj );
        if ( estimated_size != size )
        {
            return 0;
        }
        while ( ( arr_follow = obj_array_next( array_obj, arr_follow ) ) )
        {
            if (arr_follow->type == OBJECT_NUMBER)
            {
                n_int follow_number = obj_get_number( arr_follow->data );
                array_numbers[count++] = follow_number;
                if ( count == size )
                {
                    return 1;
                }
            }
            else
            {
                return -1;
            }
        }
    }
    return 0;
}

n_array * object_vect2_array(n_vect2 * value)
{
    n_array  * point = array_number(value->x);
    array_add( point, array_number(value->y) );
    return point;
}

n_array * object_vect2_pointer(n_vect2 * vect_array, n_uint count)
{
    n_array * json_array = 0L;
    n_int loop = 0;
    while (loop < count)
    {
        array_add_empty( &json_array, array_array(object_vect2_array(&vect_array[loop])));
        loop++;
    }
    return json_array;
}

n_int object_unwrap_four_vect2( n_string pass_through, n_byte * buffer)
{
    return vect2_unwrap_number_entry( pass_through, buffer, 4);
}

n_int object_unwrap_two_vect2( n_string pass_through, n_byte * buffer)
{
    return vect2_unwrap_number_entry( pass_through, buffer, 2);
}

n_int object_unwrap_vect2( n_string pass_through, n_byte * buffer)
{
    return vect2_unwrap_number_entry( pass_through, buffer, 1);
}

n_int object_count_name_vect2(n_vect2 * vect_array, n_uint count, object_unwrap * wrap_func, n_string name, n_object * object)
{
    n_string array_string;
    n_int out_value = 0;
    if ( ( array_string = obj_contains( object, name, OBJECT_ARRAY ) ) )
    {
        n_array * array_obj = obj_get_array( array_string );
        memory_list * mem_list = object_unwrap_array(array_obj, sizeof(n_vect2), wrap_func, OBJECT_ARRAY);

        if (mem_list->count == count)
        {
            n_int index = 0;
            n_vect2 * value = (n_vect2 *)mem_list->data;
            while (index < (count * 2))
            {
                vect_array[index].data[0] = value[index].data[0];
                vect_array[index].data[1] = value[index].data[1];
                index ++;

                vect_array[index].data[0] = value[index].data[0];
                vect_array[index].data[1] = value[index].data[1];
                index ++;
            }
            out_value = 1;
        }
        memory_list_free(&mem_list);
    }
    return out_value;
}

static n_array * object_vect2_list(memory_list * vect_list)
{
    n_array * json_array = 0L;
    if (vect_list->unit_size == sizeof(n_vect2))
    {
        return object_vect2_pointer((n_vect2 *)vect_list->data, vect_list->count);
    }
    return json_array;
}


n_string object_type_string(n_object_type objtype)
{
    return n_object_type_string[objtype];
}

n_int object_vect2_from_array(n_array * vect_element, n_vect2 * vect_list)
{
    n_int   loop = 0;
    n_array * arr_follow = 0L;
    while ( ( arr_follow = obj_array_next( vect_element, arr_follow ) ) )
    {
        if (arr_follow->type == OBJECT_NUMBER)
        {
            n_int number = obj_get_number( arr_follow->data );
            vect_list->data[loop++] = number;
        }
        else
        {
            printf("Expected OBJECT_NUMBER not %s\n\n", object_type_string(arr_follow->type));
            return -1;
        }

        if (loop == 2)
        {
            return 1;
        }
    }
    return 0;
}


memory_list * object_list_vect2(n_array * vect_array)
{
    memory_list * vect_list = 0L;
    if (vect_array)
    {
        n_int count_in_array = obj_array_count(vect_array);
        n_array * arr_follow = 0L;
        vect_list = memory_list_new(sizeof(n_vect2), count_in_array);
        while ( ( arr_follow = obj_array_next( vect_array, arr_follow ) ) )
        {
            if (arr_follow->type == OBJECT_ARRAY)
            {
                n_vect2 temp_vect;
                n_array * vect_element = obj_get_array( arr_follow->data );
                n_int error_response = object_vect2_from_array(vect_element, &temp_vect);
                if (error_response == 1)
                {
                    memory_list_copy(vect_list, (n_byte*)&temp_vect, sizeof(temp_vect));
                }

                if (error_response == -1)
                {
                    memory_list_free(&vect_list);
                    return 0L;
                }
            }
        }
        vect_list->count = count_in_array;
    }
    return vect_list;
}

n_object * object_vect2_names(n_string names, memory_list * vect_array)
{
    return object_array(0L, names, object_vect2_list(vect_array));
}

n_object * object_vect2_name( n_object *obj, n_string name, n_vect2 * value)
{
    return object_array( obj, name, object_vect2_array(value));
}

n_int   object_name_vect2(n_string name, n_vect2 * value, n_object * input_json)
{
    n_string str_point = obj_contains(input_json, name, OBJECT_ARRAY);
    if (str_point)
    {
        n_array * point_array = obj_get_array(str_point);
        n_int number_elements = obj_array_count(point_array);
        if (number_elements == 2)
        {
            n_int return_value = obj_contains_array_numbers(input_json, name, (n_int *)value, 2);
            if (return_value == 0)
            {
                return SHOW_ERROR("expecting two integers for point");
            }
            if (return_value == -1)
            {
                return SHOW_ERROR("expecting integers for point");
            }
            return 1;
        }
        return SHOW_ERROR("expecting two integers for point");
    }
    return SHOW_ERROR("expecting point element");
}

memory_list * object_unwrap_array(n_array * general_array, n_uint size, object_unwrap wrap_func, n_object_type type)
{
    memory_list * return_list = 0L;
    if (general_array)
    {
        n_int     general_array_count = obj_array_count(general_array);
        n_array * arr_follow = 0L;
        return_list = memory_list_new(size, general_array_count);
        while ( ( arr_follow = obj_array_next( general_array, arr_follow ) ) )
        {
            if (arr_follow->type == type)
            {
                n_byte * temp_buffer = memory_new(size);
                if (1 == wrap_func(arr_follow->data, temp_buffer))
                {
                    memory_list_copy(return_list, temp_buffer, size);
                }
                memory_free((void**)&temp_buffer);
            }
        }
    }
    return return_list;
}

void object_output_object(n_object * value)
{
    n_file *output = unknown_json( value, OBJECT_OBJECT );
    io_file_debug(output);
}

void object_output_array(n_array * value)
{
    n_file *output = unknown_json( value, OBJECT_ARRAY );
    io_file_debug(output);
}

n_array * object_onionskin(n_object * top, n_string value)
{
    n_string next_level = obj_contains(top, value, OBJECT_ARRAY);
    if (next_level)
    {
        n_array *next_level_array = obj_get_array(next_level);
        if (next_level_array)
        {
            return next_level_array;
        }
        return 0L;
    }
    return 0L;
}


#else // TODO: Find ifdef else






#include "toolkit.h"
#include <stdio.h>

static void object_write_object( n_file *file, n_object *start );
static void object_write_array( n_file *file, n_array *start );

#undef OBJECT_DEBUG

// Enable all string copying to ensure proper memory management
#define STRING_COPY1(value) io_string_copy(value)
#define STRING_COPY2(value) io_string_copy(value)
#define STRING_COPY3(value) io_string_copy(value)

#ifdef OBJECT_DEBUG
#define OBJ_DBG( test, string ) if (test == 0L) printf("%s\n", string)
#else
#define OBJ_DBG( test, string ) /* test string */
#endif

static n_object *object_file_base( n_file *file );

static number_array_list    * object_number_array_list = 0L;
static n_uint * object_hashes = 0L;
static n_uint object_hash_count = 0;

n_uint object_get_hash_count(void)
{
    return object_hash_count;
}

void object_init(n_uint * hashes, n_uint hash_count)
{
    object_number_array_list = number_array_list_new();
    object_hashes = hashes;
    object_hash_count = hash_count;
}

void object_ptr_debug(void * ptr)
{
    n_uint ptr_repr = (n_uint)ptr;
    printf("%ld\n", ptr_repr);
}

void object_close(void)
{
    if (object_number_array_list)
    {
        number_array * checkptr = (number_array *)object_number_array_list->data;
        n_int loop = 0, array_count = object_number_array_list->count;
        printf("\n array_count %ld\n", array_count);
        while (loop < array_count)
        {
            number_array * location = &checkptr[loop];
            int_list * il_repr = location->number;
            printf("\n");
            object_ptr_debug(location->array);
            printf("\n");
            int_list_debug(il_repr);
            loop++;
        }
        number_array_list_free(&object_number_array_list);
    }
    object_number_array_list = 0L;
    object_hashes = 0L;
    object_hash_count = 0;
}

void object_array_add_number(void * array, n_int number)
{
    if (object_number_array_list && array)
    {
        number_array * num_array = number_array_list_find_add(object_number_array_list, array);
        if (num_array)
        {
            number_array_number(num_array, number);
        }
    }
}

void object_array_not_number(void * array)
{
    if (object_number_array_list && array)
    {
        number_array * num_array = number_array_list_find_add(object_number_array_list, array);
        if (num_array)
        {
            number_array_not_number(num_array);
        }
    }
}

static n_object_type object_type( n_array *array )
{
    return array->type;
}

static void object_erase( n_object *object )
{
    if (object)
    {
        memory_erase( (n_byte *)object, sizeof(n_object) );
    }
}

static n_object *object_new( void )
{
    n_object *return_object = (n_object *)memory_new( sizeof(n_object) );
    if (return_object)
    {
        object_erase(return_object);
    }
    return return_object;
}

static void obj_free_array_contents(n_array *array, n_int is_array);

void obj_free( n_object **object )
{
    if (object && *object)
    {
        n_object *obj = *object;
        if (obj->name)
        {
            memory_free((void **)&obj->name);
        }
        
        obj_free_array_contents(&obj->primitive, 0);
        memory_free((void **)object);
    }
}

static void obj_free_array_contents(n_array *array, n_int is_array)
{
    if (!array) return;

    switch (array->type)
    {
        case OBJECT_STRING:
            if (array->data)
            {
                memory_free((void **)&array->data);
            }
            break;
        case OBJECT_ARRAY:
            if (array->data)
            {
                n_array *local_array = obj_get_array(array->data);
                obj_free_array_contents(local_array, 1);
                memory_free((void **)&array->data);
            }
            break;
        case OBJECT_OBJECT:
            if (array->data)
            {
                n_object *object = obj_get_object(array->data);
                obj_free(&object);
            }
            break;
        default:
            break;
    }

    if (array->next)
    {
        if (is_array)
        {
            n_array *next_array = (n_array *)array->next;
            obj_free_array_contents(next_array, 1);
            memory_free((void **)&array->next);
        }
        else
        {
            obj_free((n_object **)&array->next);
        }
    }
}

void object_top_object( n_file *file, n_object *top_level )
{
    if (file && top_level)
    {
        io_write(file, "{", 0);
        object_write_object(file, top_level);
        io_write(file, "}", 0);
    }
}

static void object_top_array( n_file *file, n_array *top_level )
{
    if (file && top_level)
    {
        io_write(file, "[", 0);
        object_write_array(file, top_level);
        io_write(file, "]", 0);
    }
}

static void *object_write_primitive( n_file *file, n_array *primitive )
{
    if (!file || !primitive) return 0L;

    switch (object_type(primitive))
    {
    case OBJECT_NUMBER:
    {
        n_int *int_data = (n_int *)&primitive->data;
        io_writenumber(file, int_data[0], 1, 0);
    }
    break;
    case OBJECT_BOOLEAN:
    {
        n_int *int_data = (n_int *)&primitive->data;
        io_write(file, int_data[0] ? "true" : "false", 0);
    }
    break;
    case OBJECT_STRING:
        io_write(file, "\"", 0);
        io_write(file, primitive->data, 0);
        io_write(file, "\"", 0);
        break;
    case OBJECT_OBJECT:
        object_top_object(file, (n_object *)primitive->data);
        break;
    case OBJECT_ARRAY:
        object_top_array(file, (n_array *)primitive->data);
        break;
    default:
        (void)SHOW_ERROR("Object kind not found");
        return 0L;
    }
    if (primitive->next)
    {
        io_write(file, ",", 0);
    }
    return primitive->next;
}

n_array *obj_get_array(n_string array)
{
    return (n_array *)array;
}

n_object *obj_get_object(n_string object)
{
    return (n_object *)object;
}

n_int obj_get_number(n_string object)
{
    n_int *data = (n_int *)&object;
    return data[0];
}

n_int obj_get_boolean(n_string object)
{
    return obj_get_number(object);
}

static void object_write_object(n_file *file, n_object *start)
{
    n_object *current = start;
    while (current)
    {
        if (current->name)
        {
            io_write(file, "\"", 0);
            io_write(file, current->name, 0);
            io_write(file, "\":", 0);
            current = (n_object *)object_write_primitive(file, &current->primitive);
        }
        else
        {
            break;
        }
    }
}

static void object_write_array(n_file *file, n_array *start)
{
    n_array *current = start;
    while (current)
    {
        current = (n_array *)object_write_primitive(file, current);
    }
}

n_file *unknown_json(void *unknown, n_object_type type)
{
    n_file *output_file = 0L;
    if (!unknown) return 0L;

    output_file = io_file_new();
    if (!output_file) return 0L;

    if (type == OBJECT_OBJECT)
    {
        object_top_object(output_file, (n_object *)unknown);
    }
    else if (type == OBJECT_ARRAY)
    {
        object_top_array(output_file, (n_array *)unknown);
    }
    else
    {
        io_file_free(&output_file);
    }
    return output_file;
}

static n_object *object_end_or_find(n_object *object, n_string name)
{
    if (!name) return 0L;

    n_object *previous_object = 0L;
    n_int string_length = io_length(name, STRING_BLOCK_SIZE);
    if (string_length > 0)
    {
        n_uint hash = math_hash((n_byte *)name, (n_uint)string_length);
        while (object)
        {
            if (hash == object->name_hash)
            {
                return previous_object;
            }
            previous_object = object;
            object = object->primitive.next;
        }
    }
    return previous_object;
}

static n_object *obj_get(n_object *object, n_string name)
{
    if (!name) return 0L;

    n_int string_length = io_length(name, STRING_BLOCK_SIZE);
    if (string_length <= 0) return 0L;

    n_uint hash = math_hash((n_byte *)name, (n_uint)string_length);
    n_object *set_object = 0L;

    if (!object)
    {
        object = set_object = object_new();
        if (!object) return 0L;
    }
    else if (object_type(&object->primitive) == OBJECT_EMPTY)
    {
        set_object = object;
    }
    else
    {
        n_object *previous_object = object_end_or_find(object, name);
        if (!previous_object)
        {
            set_object = object;
        }
        else
        {
            set_object = previous_object->primitive.next;
            if (!set_object)
            {
                set_object = object_new();
                if (!set_object) return 0L;
                previous_object->primitive.next = set_object;
            }
        }
    }

    if (set_object)
    {
        set_object->name = STRING_COPY1(name);
        if (!set_object->name)
        {
            if (set_object != object) memory_free((void **)&set_object);
            return 0L;
        }
        set_object->name_hash = hash;
    }

    return set_object;
}

n_array *array_add(n_array *array, n_array *element)
{
    if (!element) return array;

    if (array)
    {
        n_array *next = array;
        while (next->next)
        {
            next = next->next;
        }
        next->next = element;
        return array;
    }
    return element;
}

void array_add_empty(n_array **array, n_array *element)
{
    if (!array || !element) return;

    if (*array)
    {
        array_add(*array, element);
    }
    else
    {
        *array = element;
    }
}

static void *ar_pass_through(void *ptr)
{
    if (!ptr)
    {
        ptr = memory_new(sizeof(n_array));
        if (ptr)
        {
            memory_erase((n_byte *)ptr, sizeof(n_array));
        }
    }
    return ptr;
}

static void *ar_number(void *ptr, n_int set_number)
{
    n_array *cleaned = (n_array *)ar_pass_through(ptr);
    if (cleaned)
    {
        cleaned->type = OBJECT_NUMBER;
        *(n_int *)&cleaned->data = set_number;
    }
    return (void *)cleaned;
}

static void *ar_boolean(void *ptr, n_int set_boolean)
{
    n_array *cleaned = (n_array *)ar_pass_through(ptr);
    if (cleaned)
    {
        cleaned->type = OBJECT_BOOLEAN;
        *(n_int *)&cleaned->data = set_boolean;
    }
    return (void *)cleaned;
}

static void *ar_string(void *ptr, n_string set_string)
{
    n_array *cleaned = (n_array *)ar_pass_through(ptr);
    if (cleaned)
    {
        cleaned->type = OBJECT_STRING;
        cleaned->data = STRING_COPY2(set_string);
        if (!cleaned->data)
        {
            memory_free((void **)&cleaned);
            return 0L;
        }
    }
    return (void *)cleaned;
}

static void *ar_object(void *ptr, n_object *set_object)
{
    n_array *cleaned = (n_array *)ar_pass_through(ptr);
    if (cleaned)
    {
        cleaned->type = OBJECT_OBJECT;
        cleaned->data = (n_string)set_object;
    }
    return (void *)cleaned;
}

static void *ar_array(void *ptr, n_array *set_array)
{
    n_array *cleaned = (n_array *)ar_pass_through(ptr);
    if (cleaned)
    {
        cleaned->type = OBJECT_ARRAY;
        cleaned->data = (n_string)set_array;
    }
    return (void *)cleaned;
}

n_array *array_boolean(n_int set_boolean)
{
    return ar_boolean(0L, set_boolean);
}

n_array *array_number(n_int set_number)
{
    return ar_number(0L, set_number);
}

n_array *array_string(n_string set_string)
{
    return ar_string(0L, set_string);
}

n_array *array_object(n_object *set_object)
{
    return ar_object(0L, set_object);
}

n_array *array_array(n_array *set_array)
{
    return ar_array(0L, set_array);
}

static n_object *obj_boolean(n_object *obj, n_string name, n_int boolean)
{
    return ar_boolean(obj_get(obj, name), boolean);
}

static n_object *obj_number(n_object *obj, n_string name, n_int number)
{
    return ar_number(obj_get(obj, name), number);
}

static n_object *obj_string(n_object *obj, n_string name, n_string string)
{
    return ar_string(obj_get(obj, name), string);
}

static n_object *obj_object(n_object *obj, n_string name, n_object *object)
{
    return ar_object(obj_get(obj, name), object);
}

static n_object *obj_array(n_object *obj, n_string name, n_array *array)
{
    return ar_array(obj_get(obj, name), array);
}

n_object *object_number(n_object *obj, n_string name, n_int number)
{
    n_string copied_name = io_string_copy(name);
    if (!copied_name) return 0L;
    n_object *result = obj_number(obj, copied_name, number);
    memory_free((void **)&copied_name);
    return result;
}

n_object *object_boolean(n_object *obj, n_string name, n_int boolean)
{
    return obj_boolean(obj, name, boolean);
}

n_object *object_string(n_object *obj, n_string name, n_string string)
{
    n_string copied_name = io_string_copy(name);
    n_string copied_string = io_string_copy(string);
    if (!copied_name || !copied_string)
    {
        memory_free((void **)&copied_name);
        memory_free((void **)&copied_string);
        return 0L;
    }
    n_object *result = obj_string(obj, copied_name, copied_string);
    memory_free((void **)&copied_name);
    memory_free((void **)&copied_string);
    return result;
}

n_object *object_object(n_object *obj, n_string name, n_object *object)
{
    n_string copied_name = io_string_copy(name);
    if (!copied_name) return 0L;
    n_object *result = obj_object(obj, copied_name, object);
    memory_free((void **)&copied_name);
    return result;
}

n_object *object_array(n_object *obj, n_string name, n_array *array)
{
    n_string copied_name = io_string_copy(name);
    if (!copied_name) return 0L;
    n_object *result = obj_array(obj, copied_name, array);
    memory_free((void **)&copied_name);
    return result;
}

static n_int tracking_array_open;
static n_int tracking_object_open;
static n_int tracking_string_quote;

#define CHECK_FILE_SIZE(error_string) if (file->location >= file->size) \
                                    { \
                                        (void)SHOW_ERROR(error_string); \
                                        return 0L; \
                                    }

static n_string object_file_read_string(n_file *file)
{
    if (!file || !file->data) return 0L;

    n_string return_string = 0L;
    n_string_block block_string = {0};
    n_int location = 0;
    
    if (file->data[file->location] != '"')
    {
        (void)SHOW_ERROR("json not string as expected");
        return return_string;
    }

    tracking_string_quote = 1;
    file->location++;

    do
    {
        CHECK_FILE_SIZE("end of json file reach unexpectedly");
        if (file->data[file->location] != '"')
        {
            block_string[location] = (n_char)file->data[file->location];
            location++;
            file->location++;
        }
    } while (file->data[file->location] != '"');

    if (location == 0)
    {
        (void)SHOW_ERROR("blank string in json file");
        return 0L;
    }

    tracking_string_quote = 0;
    file->location++;
    CHECK_FILE_SIZE("end of json file reach unexpectedly");
    
    return_string = STRING_COPY3(block_string);
    return return_string;
}

static n_int object_file_read_number(n_file *file, n_int *with_error)
{
    if (!file || !file->data || !with_error) return 0;

    n_int return_number = 0;
    n_string_block block_string = {0};
    n_int location = 0;
    n_byte read_char = file->data[file->location];
    n_int char_okay = (ASCII_NUMBER(read_char) || (read_char == '-'));
    *with_error = 1;

    if (!char_okay)
    {
        (void)SHOW_ERROR("first character not number or minus");
        return 0;
    }

    CHECK_FILE_SIZE("end of json file reach unexpectedly for number");

    block_string[location] = (n_char)read_char;
    file->location++;
    location++;

    do
    {
        read_char = file->data[file->location];
        char_okay = ASCII_NUMBER(read_char);

        CHECK_FILE_SIZE("end of json file reach unexpectedly for number");

        if (char_okay)
        {
            block_string[location] = (n_char)read_char;
            location++;
            file->location++;
        }
    } while (char_okay);

    n_int actual_value = 1;
    n_int decimal_divisor = 1;
    n_int error_number = io_number((n_string)block_string, &actual_value, &decimal_divisor);

    if (error_number == -1)
    {
        return 0;
    }

    if (decimal_divisor != 0)
    {
        (void)SHOW_ERROR("decimal number in json file");
        return 0;
    }

    return_number = actual_value;
    *with_error = 0;
    return return_number;
}

static n_int object_file_read_boolean(n_file *file, n_int *with_error)
{
    if (!file || !file->data || !with_error) return 0;

    n_int return_number = 0;
    n_byte read_char = file->data[file->location];
    n_char *allowed[2] = {"fals", "true"};
    n_int allowed_advance = 1;
    n_int char_okay;
    *with_error = 1;

    if (read_char == allowed[0][0])
    {
        return_number = 0;
    }
    else if (read_char == allowed[1][0])
    {
        return_number = 1;
    }
    else
    {
        (void)SHOW_ERROR("not valid boolean (first character)");
        return 0;
    }

    file->location++;

    while (allowed_advance < 4)
    {
        CHECK_FILE_SIZE("end of json file reach unexpectedly for boolean");

        read_char = file->data[file->location];
        char_okay = allowed[return_number][allowed_advance] == read_char;

        if (char_okay)
        {
            file->location++;
        }
        else
        {
            (void)SHOW_ERROR("not valid boolean");
            return 0;
        }
        allowed_advance++;
    }

    if (return_number == 0)
    {
        CHECK_FILE_SIZE("end of json file reach unexpectedly for number");
        read_char = file->data[file->location];
        if ('e' != read_char)
        {
            (void)SHOW_ERROR("not valid boolean (false)");
            return 0;
        }
        file->location++;
    }

    *with_error = 0;
    return return_number;
}

static n_object_stream_type object_stream_char(n_byte value)
{
    switch (value)
    {
        case '{': return OBJ_TYPE_OBJECT_OPEN;
        case '}': return OBJ_TYPE_OBJECT_CLOSE;
        case '[': return OBJ_TYPE_ARRAY_OPEN;
        case ']': return OBJ_TYPE_ARRAY_CLOSE;
        case 't':
        case 'f': return OBJ_TYPE_BOOLEAN;
        default:
            if (ASCII_NUMBER(value) || (value == '-')) return OBJ_TYPE_NUMBER;
            if (ASCII_COMMA(value)) return OBJ_TYPE_COMMA;
            if (ASCII_COLON(value)) return OBJ_TYPE_COLON;
            if (ASCII_QUOTE(value)) return OBJ_TYPE_STRING_NOTATION;
            return OBJ_TYPE_EMPTY;
    }
}

n_array *number_base_array = 0L;

static n_array *object_file_array(n_file *file)
{
    if (!file || !file->data) return 0L;

    n_array *base_array = 0L;
    n_object_stream_type stream_type;
    n_object_stream_type stream_type_in_this_array = OBJ_TYPE_EMPTY;

    if (object_stream_char(file->data[file->location]) != OBJ_TYPE_ARRAY_OPEN)
    {
        (void)SHOW_ERROR("json not array as expected");
        return base_array;
    }

    tracking_array_open++;
    file->location++;

    do
    {
        CHECK_FILE_SIZE("end of json file reach unexpectedly");
        stream_type = object_stream_char(file->data[file->location]);

        if (stream_type_in_this_array == OBJ_TYPE_EMPTY)
        {
            stream_type_in_this_array = stream_type;
        }
        else if (stream_type_in_this_array != stream_type)
        {
            (void)SHOW_ERROR("array contains multiple types");
            obj_free_array_contents(base_array, 1);
            return 0L;
        }

        switch (stream_type)
        {
            case OBJ_TYPE_ARRAY_OPEN:
            {
                n_array *array_value = object_file_array(file);
                if (array_value)
                {
                    stream_type = object_stream_char(file->data[file->location]);
                    if ((stream_type == OBJ_TYPE_ARRAY_CLOSE) || (stream_type == OBJ_TYPE_COMMA))
                    {
                        if (!base_array)
                        {
                            base_array = array_array(array_value);
                        }
                        else
                        {
                            array_add(base_array, array_array(array_value));
                        }
                    }
                }
                break;
            }
            case OBJ_TYPE_OBJECT_OPEN:
            {
                n_object *object_value = object_file_base(file);
                OBJ_DBG(object_value, "object value is nil?");
                if (object_value)
                {
                    file->location++;
                    CHECK_FILE_SIZE("end of json file reach unexpectedly");
                    stream_type = object_stream_char(file->data[file->location]);

                    if ((stream_type == OBJ_TYPE_ARRAY_CLOSE) || (stream_type == OBJ_TYPE_COMMA))
                    {
                        if (!base_array)
                        {
                            base_array = array_object(object_value);
                        }
                        else
                        {
                            array_add(base_array, array_object(object_value));
                        }
                    }
                }
                OBJ_DBG(base_array, "base array still nil?");
                CHECK_FILE_SIZE("end of json file reach unexpectedly");
                break;
            }
            case OBJ_TYPE_STRING_NOTATION:
            {
                n_string string_value = object_file_read_string(file);
                if (string_value)
                {
                    stream_type = object_stream_char(file->data[file->location]);
                    if ((stream_type == OBJ_TYPE_ARRAY_CLOSE) || (stream_type == OBJ_TYPE_COMMA))
                    {
                        if (!base_array)
                        {
                            base_array = array_string(string_value);
                        }
                        else
                        {
                            array_add(base_array, array_string(string_value));
                        }
                    }
                    memory_free((void **)&string_value);
                }
                break;
            }
            case OBJ_TYPE_NUMBER:
            {
                n_int with_error;
                n_int number_value = object_file_read_number(file, &with_error);
                if (with_error == 0)
                {
                    stream_type = object_stream_char(file->data[file->location]);
                    if ((stream_type == OBJ_TYPE_ARRAY_CLOSE) || (stream_type == OBJ_TYPE_COMMA))
                    {
                        if (!base_array)
                        {
                            base_array = array_number(number_value);
                        }
                        else
                        {
                            array_add(base_array, array_number(number_value));
                        }
                    }

                    if (!number_base_array)
                    {
                        number_base_array = base_array;
                    }
                    object_array_add_number(number_base_array, number_value);
                }
                break;
            }
            case OBJ_TYPE_BOOLEAN:
            {
                n_int with_error;
                n_int boolean_value = object_file_read_boolean(file, &with_error);
                if (with_error == 0)
                {
                    stream_type = object_stream_char(file->data[file->location]);
                    if ((stream_type == OBJ_TYPE_ARRAY_CLOSE) || (stream_type == OBJ_TYPE_COMMA))
                    {
                        if (!base_array)
                        {
                            base_array = array_boolean(boolean_value);
                        }
                        else
                        {
                            array_add(base_array, array_boolean(boolean_value));
                        }
                    }
                }
                break;
            }
            case OBJ_TYPE_ARRAY_CLOSE:
                tracking_array_open--;
                if (tracking_array_open == 2)
                {
                    object_array_add_number(number_base_array, BIG_INTEGER);
                }
                if (tracking_array_open == 1)
                {
                    number_base_array = 0L;
                }
                break;
            default:
                break;
        }

        file->location++;
        OBJ_DBG(base_array, "base array nil check?");
    } while (stream_type == OBJ_TYPE_COMMA);

    OBJ_DBG(base_array, "base array really nil?");
    return base_array;
}

static n_int object_string_key(n_string string_key)
{
    if (!string_key) return -1;

    n_uint string_hash = math_hash((n_byte *)string_key, io_length(string_key, STRING_BLOCK_SIZE));
    if (object_hash_count == 0 || !object_hashes)
    {
        return -1;
    }

    for (n_uint loop = 0; loop < object_hash_count; loop++)
    {
        if (object_hashes[loop] == string_hash)
        {
            return loop;
        }
    }
    return -1;
}

static n_object *object_file_base(n_file *file)
{
    if (!file || !file->data) return 0L;

    n_object *base_object = 0L;
    n_object_stream_type stream_type;
    CHECK_FILE_SIZE("file read outside end of file");

    stream_type = object_stream_char(file->data[file->location]);

    if (stream_type == OBJ_TYPE_OBJECT_OPEN)
    {
        tracking_object_open++;
        do
        {
            file->location++;
            CHECK_FILE_SIZE("file read outside end of file");
            stream_type = object_stream_char(file->data[file->location]);
            if (stream_type == OBJ_TYPE_STRING_NOTATION)
            {
                n_string string_key = object_file_read_string(file);
                if (string_key)
                {
                    stream_type = object_stream_char(file->data[file->location]);
                    if (stream_type == OBJ_TYPE_COLON)
                    {
                        file->location++;
                        CHECK_FILE_SIZE("file read outside end of file");
                        stream_type = object_stream_char(file->data[file->location]);

                        switch (stream_type)
                        {
                            case OBJ_TYPE_OBJECT_OPEN:
                            {
                                n_object *insert_object = object_file_base(file);
                                if (insert_object)
                                {
                                    if (base_object)
                                    {
                                        obj_object(base_object, string_key, insert_object);
                                    }
                                    else
                                    {
                                        base_object = obj_object(base_object, string_key, insert_object);
                                    }
                                    file->location++;
                                    CHECK_FILE_SIZE("file read outside end of file");
                                }
                                break;
                            }
                            case OBJ_TYPE_NUMBER:
                            {
                                n_int number_error;
                                n_int number_value = object_file_read_number(file, &number_error);
                                if (number_error == 0)
                                {
                                    stream_type = object_stream_char(file->data[file->location]);
                                    if ((stream_type == OBJ_TYPE_OBJECT_CLOSE) || (stream_type == OBJ_TYPE_COMMA))
                                    {
                                        if (base_object)
                                        {
                                            obj_number(base_object, string_key, number_value);
                                        }
                                        else
                                        {
                                            base_object = obj_number(base_object, string_key, number_value);
                                        }
                                    }
                                    CHECK_FILE_SIZE("file read outside end of file");
                                }
                                break;
                            }
                            case OBJ_TYPE_BOOLEAN:
                            {
                                n_int number_error;
                                n_int boolean_value = object_file_read_boolean(file, &number_error);
                                if (number_error == 0)
                                {
                                    stream_type = object_stream_char(file->data[file->location]);
                                    if ((stream_type == OBJ_TYPE_OBJECT_CLOSE) || (stream_type == OBJ_TYPE_COMMA))
                                    {
                                        if (base_object)
                                        {
                                            obj_boolean(base_object, string_key, boolean_value);
                                        }
                                        else
                                        {
                                            base_object = obj_boolean(base_object, string_key, boolean_value);
                                        }
                                    }
                                    CHECK_FILE_SIZE("file read outside end of file");
                                }
                                break;
                            }
                            case OBJ_TYPE_STRING_NOTATION:
                            {
                                n_string string_value = object_file_read_string(file);
                                if (string_value)
                                {
                                    stream_type = object_stream_char(file->data[file->location]);
                                    if ((stream_type == OBJ_TYPE_OBJECT_CLOSE) || (stream_type == OBJ_TYPE_COMMA))
                                    {
                                        if (base_object)
                                        {
                                            obj_string(base_object, string_key, string_value);
                                        }
                                        else
                                        {
                                            base_object = obj_string(base_object, string_key, string_value);
                                        }
                                    }
                                    memory_free((void **)&string_value);
                                    CHECK_FILE_SIZE("file read outside end of file");
                                }
                                break;
                            }
                            case OBJ_TYPE_ARRAY_OPEN:
                            {
                                n_array *array_value = object_file_array(file);
                                if (array_value)
                                {
                                    stream_type = object_stream_char(file->data[file->location]);
                                    if ((stream_type == OBJ_TYPE_OBJECT_CLOSE) || (stream_type == OBJ_TYPE_COMMA))
                                    {
                                        n_int string_key_output = object_string_key(string_key);
                                        if (string_key_output > -1)
                                        {
                                            object_array_add_number(number_base_array, BIG_NEGATIVE_INTEGER + string_key_output);
                                        }

                                        if (base_object)
                                        {
                                            obj_array(base_object, string_key, array_value);
                                        }
                                        else
                                        {
                                            base_object = obj_array(base_object, string_key, array_value);
                                        }
                                    }
                                    CHECK_FILE_SIZE("file read outside end of file");
                                }
                                OBJ_DBG(array_value, "array value nil?");
                                break;
                            }
                            default:
                                break;
                        }
                    }
                    memory_free((void **)&string_key);
                }
            }
            if (stream_type == OBJ_TYPE_OBJECT_CLOSE)
            {
                tracking_object_open--;
            }
        } while (stream_type == OBJ_TYPE_COMMA);
    }
    return base_object;
}

void unknown_free(void **unknown, n_object_type type)
{
    if (!unknown || !*unknown) return;

    if (type == OBJECT_ARRAY)
    {
        n_array **found_array = (n_array **)unknown;
        obj_free_array_contents(*found_array, 1);
        memory_free(unknown);
    }
    else if (type == OBJECT_OBJECT)
    {
        n_object **found_object = (n_object **)unknown;
        obj_free(found_object);
    }
}

#define JSON_WHITESPACE(num) ((((num)>8)&&((num)<14))||((num)==32))

void io_whitespace_json(n_file *input)
{
    if (!input || !input->data) return;

    n_uint loop = 0, out_loop = 0;
    n_uint end_loop = input->size;
    n_byte *local_data = input->data;
    n_int inside_string = 0;

    while (loop < end_loop)
    {
        n_byte temp = local_data[loop++];
        if (temp == '"')
        {
            inside_string ^= 1;
            local_data[out_loop++] = temp;
        }
        else if ((JSON_WHITESPACE(temp) == 0) || inside_string)
        {
            local_data[out_loop++] = temp;
        }
    }

    while (out_loop < end_loop)
    {
        local_data[out_loop++] = 0;
    }
    input->size = out_loop;
    input->location = 0;
}

void *unknown_file_to_tree(n_file *file, n_object_type *type)
{
    if (!file || !type) return 0L;

    n_object *base_object = 0L;
    n_array *base_array = 0L;
    n_int something_wrong = 0;

    tracking_array_open = 0;
    tracking_object_open = 0;
    tracking_string_quote = 0;
    io_whitespace_json(file);
    file->location = 0;

    n_object_stream_type stream_type = object_stream_char(file->data[file->location]);

    if (stream_type == OBJ_TYPE_OBJECT_OPEN)
    {
        *type = OBJECT_OBJECT;
        base_object = object_file_base(file);
    }
    else if (stream_type == OBJ_TYPE_ARRAY_OPEN)
    {
        *type = OBJECT_ARRAY;
        base_array = object_file_array(file);
    }

    if (tracking_array_open != 0)
    {
        (void)SHOW_ERROR("Array json does not match up");
        something_wrong = 1;
    }
    if (tracking_object_open != 0)
    {
        (void)SHOW_ERROR("Object json does not match up");
        something_wrong = 1;
    }
    if (tracking_string_quote != 0)
    {
        (void)SHOW_ERROR("String quote json does not match up");
        something_wrong = 1;
    }

    if (something_wrong)
    {
        printf("\n\n");
        printf("%c", file->data[file->location-3]);
        printf("%c", file->data[file->location-2]);
        printf("%c", file->data[file->location-1]);
        printf("~%c~", file->data[file->location]);
        printf("%c", file->data[file->location+1]);
        printf("%c", file->data[file->location+2]);
        printf("%c", file->data[file->location+3]);
        printf("\n\n");

        if (base_object) obj_free(&base_object);
        if (base_array) obj_free_array_contents(base_array, 1);
        return 0L;
    }

    return (*type == OBJECT_ARRAY) ? (void *)base_array : (void *)base_object;
}

n_string obj_contains(n_object *base, n_string name, n_object_type type)
{
    if (!base || !name) return 0L;

    n_int string_length = io_length(name, STRING_BLOCK_SIZE);
    if (string_length <= 0) return 0L;

    n_uint hash = math_hash((n_byte *)name, (n_uint)string_length);
    n_object *current = base;

    while (current)
    {
        if ((hash == current->name_hash) && (type == object_type(&current->primitive)))
        {
            return current->primitive.data;
        }
        current = current->primitive.next;
    }
    return 0L;
}

n_int obj_contains_number(n_object *base, n_string name, n_int *number)
{
    if (!base || !name || !number) return 0;

    n_string data = obj_contains(base, name, OBJECT_NUMBER);
    if (data)
    {
        *number = obj_get_number(data);
        return 1;
    }
    return 0;
}

n_array *obj_array_next(n_array *array, n_array *element)
{
    if (!element) return array;
    return (n_array *)element->next;
}

n_int obj_array_count(n_array *array_obj)
{
    n_int count = 0;
    n_array *current = array_obj;
    while (current)
    {
        count++;
        current = current->next;
    }
    return count;
}

n_int obj_contains_array_nbyte2(n_object *base, n_string name, n_byte2 *array_numbers, n_int size)
{
    if (!base || !name || !array_numbers || size <= 0) return 0;

    n_string array_string = obj_contains(base, name, OBJECT_ARRAY);
    if (!array_string) return 0;

    n_array *array_obj = obj_get_array(array_string);
    n_int count = 0;
    n_int estimated_size = obj_array_count(array_obj);
    if (estimated_size != size) return -1;

    n_array *current = array_obj;
    while (current && count < size)
    {
        array_numbers[count++] = obj_get_number(current->data);
        current = current->next;
    }
    return (count == size) ? 1 : 0;
}

n_int obj_contains_array_numbers(n_object *base, n_string name, n_int *array_numbers, n_int size)
{
    if (!base || !name || !array_numbers || size <= 0) return 0;

    n_string array_string = obj_contains(base, name, OBJECT_ARRAY);
    if (!array_string) return 0;

    n_array *array_obj = obj_get_array(array_string);
    n_int count = 0;
    n_int estimated_size = obj_array_count(array_obj);
    if (estimated_size != size) return 0;

    n_array *current = array_obj;
    while (current && count < size)
    {
        if (current->type == OBJECT_NUMBER)
        {
            array_numbers[count++] = obj_get_number(current->data);
        }
        else
        {
            return -1;
        }
        current = current->next;
    }
    return (count == size) ? 1 : 0;
}

n_array *object_vect2_array(n_vect2 *value)
{
    if (!value) return 0L;
    n_array *point = array_number(value->x);
    if (point)
    {
        array_add(point, array_number(value->y));
    }
    return point;
}

n_array *object_vect2_pointer(n_vect2 *vect_array, n_uint count)
{
    if (!vect_array || count == 0) return 0L;
    
    n_array *json_array = 0L;
    for (n_uint loop = 0; loop < count; loop++)
    {
        n_array *vect_element = object_vect2_array(&vect_array[loop]);
        if (vect_element)
        {
            array_add_empty(&json_array, array_array(vect_element));
        }
    }
    return json_array;
}

n_int object_unwrap_four_vect2(n_string pass_through, n_byte *buffer)
{
    return vect2_unwrap_number_entry(pass_through, buffer, 4);
}

n_int object_unwrap_two_vect2(n_string pass_through, n_byte *buffer)
{
    return vect2_unwrap_number_entry(pass_through, buffer, 2);
}

n_int object_unwrap_vect2(n_string pass_through, n_byte *buffer)
{
    return vect2_unwrap_number_entry(pass_through, buffer, 1);
}

n_int object_count_name_vect2(n_vect2 *vect_array, n_uint count, object_unwrap *wrap_func, n_string name, n_object *object)
{
    if (!vect_array || !wrap_func || !name || !object) return 0;

    n_string array_string = obj_contains(object, name, OBJECT_ARRAY);
    if (!array_string) return 0;

    n_array *array_obj = obj_get_array(array_string);
    memory_list *mem_list = object_unwrap_array(array_obj, sizeof(n_vect2), wrap_func, OBJECT_ARRAY);
    if (!mem_list || mem_list->count != count)
    {
        memory_list_free(&mem_list);
        return 0;
    }

    n_vect2 *value = (n_vect2 *)mem_list->data;
    for (n_uint i = 0; i < count; i++)
    {
        vect_array[i] = value[i];
    }
    memory_list_free(&mem_list);
    return 1;
}

static n_array *object_vect2_list(memory_list *vect_list)
{
    if (!vect_list || vect_list->unit_size != sizeof(n_vect2)) return 0L;
    return object_vect2_pointer((n_vect2 *)vect_list->data, vect_list->count);
}

n_string object_type_string(n_object_type objtype)
{
    return n_object_type_string[objtype];
}

n_int object_vect2_from_array(n_array *vect_element, n_vect2 *vect_list)
{
    if (!vect_element || !vect_list) return 0;

    n_int loop = 0;
    n_array *current = vect_element;
    while (current && loop < 2)
    {
        if (current->type == OBJECT_NUMBER)
        {
            vect_list->data[loop++] = obj_get_number(current->data);
        }
        else
        {
            printf("Expected OBJECT_NUMBER not %s\n\n", object_type_string(current->type));
            return -1;
        }
        current = current->next;
    }
    return (loop == 2) ? 1 : 0;
}

memory_list *object_list_vect2(n_array *vect_array)
{
    if (!vect_array) return 0L;

    n_int count_in_array = obj_array_count(vect_array);
    memory_list *vect_list = memory_list_new(sizeof(n_vect2), count_in_array);
    if (!vect_list) return 0L;

    n_array *current = vect_array;
    while (current)
    {
        if (current->type == OBJECT_ARRAY)
        {
            n_vect2 temp_vect;
            n_array *vect_element = obj_get_array(current->data);
            n_int error_response = object_vect2_from_array(vect_element, &temp_vect);
            if (error_response == 1)
            {
                memory_list_copy(vect_list, (n_byte*)&temp_vect, sizeof(temp_vect));
            }
            else if (error_response == -1)
            {
                memory_list_free(&vect_list);
                return 0L;
            }
        }
        current = current->next;
    }
    vect_list->count = count_in_array;
    return vect_list;
}

n_object *object_vect2_names(n_string names, memory_list *vect_array)
{
    n_array *list = object_vect2_list(vect_array);
    return list ? object_array(0L, names, list) : 0L;
}

n_object *object_vect2_name(n_object *obj, n_string name, n_vect2 *value)
{
    n_array *array = object_vect2_array(value);
    return array ? object_array(obj, name, array) : 0L;
}

n_int object_name_vect2(n_string name, n_vect2 *value, n_object *input_json)
{
    if (!name || !value || !input_json) return 0;

    n_string str_point = obj_contains(input_json, name, OBJECT_ARRAY);
    if (!str_point) return SHOW_ERROR("expecting point element");

    n_array *point_array = obj_get_array(str_point);
    if (obj_array_count(point_array) != 2)
    {
        return SHOW_ERROR("expecting two integers for point");
    }

    n_int return_value = obj_contains_array_numbers(input_json, name, (n_int *)value, 2);
    if (return_value == 0) return SHOW_ERROR("expecting two integers for point");
    if (return_value == -1) return SHOW_ERROR("expecting integers for point");
    return 1;
}

memory_list *object_unwrap_array(n_array *general_array, n_uint size, object_unwrap wrap_func, n_object_type type)
{
    if (!general_array || !wrap_func) return 0L;

    n_int general_array_count = obj_array_count(general_array);
    memory_list *return_list = memory_list_new(size, general_array_count);
    if (!return_list) return 0L;

    n_array *current = general_array;
    while (current)
    {
        if (current->type == type)
        {
            n_byte *temp_buffer = memory_new(size);
            if (temp_buffer)
            {
                if (1 == wrap_func(current->data, temp_buffer))
                {
                    memory_list_copy(return_list, temp_buffer, size);
                }
                memory_free((void **)&temp_buffer);
            }
        }
        current = current->next;
    }
    return return_list;
}

void object_output_object(n_object *value)
{
    if (!value) return;
    n_file *output = unknown_json(value, OBJECT_OBJECT);
    if (output)
    {
        io_file_debug(output);
        io_file_free(&output);
    }
}

void object_output_array(n_array *value)
{
    if (!value) return;
    n_file *output = unknown_json(value, OBJECT_ARRAY);
    if (output)
    {
        io_file_debug(output);
        io_file_free(&output);
    }
}

n_array *object_onionskin(n_object *top, n_string value)
{
    if (!top || !value) return 0L;
    n_string next_level = obj_contains(top, value, OBJECT_ARRAY);
    if (!next_level) return 0L;
    return obj_get_array(next_level);
}

#endif


/* ./toolkit/vect.c */
/****************************************************************

 vect.c

 =============================================================



 ****************************************************************/

/*! \file   vect.c
 *  \brief  This covers vector math in Simulated Ape.
 */

#include "toolkit.h"
#include "stdio.h"

/** \brief new_sd stands for new sine dump and hold the sine and cosine values for the simulation */
static const n_int	new_sd[256] =
{
    0, 659, 1318, 1977, 2634, 3290, 3944, 4595, 5244, 5889, 6531, 7169, 7802, 8431, 9055, 9673,
    10286, 10892, 11492, 12085, 12671, 13249, 13819, 14380, 14933, 15477, 16012, 16537, 17052, 17557, 18051, 18534,
    19007, 19467, 19916, 20353, 20778, 21190, 21590, 21976, 22349, 22709, 23055, 23387, 23706, 24009, 24299, 24573,
    24833, 25078, 25308, 25523, 25722, 25906, 26074, 26226, 26363, 26484, 26589, 26677, 26750, 26807, 26847, 26871,
    26880, 26871, 26847, 26807, 26750, 26677, 26589, 26484, 26363, 26226, 26074, 25906, 25722, 25523, 25308, 25078,
    24833, 24573, 24299, 24009, 23706, 23387, 23055, 22709, 22349, 21976, 21590, 21190, 20778, 20353, 19916, 19467,
    19007, 18534, 18051, 17557, 17052, 16537, 16012, 15477, 14933, 14380, 13819, 13249, 12671, 12085, 11492, 10892,
    10286, 9673, 9055, 8431, 7802, 7169, 6531, 5889, 5244, 4595, 3944, 3290, 2634, 1977, 1318, 659,
    0, -659, -1318, -1977, -2634, -3290, -3944, -4595, -5244, -5889, -6531, -7169, -7802, -8431, -9055, -9673,
    -10286, -10892, -11492, -12085, -12671, -13249, -13819, -14380, -14933, -15477, -16012, -16537, -17052, -17557, -18051, -18534,
    -19007, -19467, -19916, -20353, -20778, -21190, -21590, -21976, -22349, -22709, -23055, -23387, -23706, -24009, -24299, -24573,
    -24833, -25078, -25308, -25523, -25722, -25906, -26074, -26226, -26363, -26484, -26589, -26677, -26750, -26807, -26847, -26871,
    -26880, -26871, -26847, -26807, -26750, -26677, -26589, -26484, -26363, -26226, -26074, -25906, -25722, -25523, -25308, -25078,
    -24833, -24573, -24299, -24009, -23706, -23387, -23055, -22709, -22349, -21976, -21590, -21190, -20778, -20353, -19916, -19467,
    -19007, -18534, -18051, -17557, -17052, -16537, -16012, -15477, -14933, -14380, -13819, -13249, -12671, -12085, -11492, -10892,
    -10286, -9673, -9055, -8431, -7802, -7169, -6531, -5889, -5244, -4595, -3944, -3290, -2634, -1977, -1318, -659
};

void area2_add( n_area2 *area, n_vect2 *vect, n_byte first )
{
    if ( first )
    {
        area->bottom_right.x = vect->x;
        area->bottom_right.y = vect->y;

        area->top_left.x = vect->x;
        area->top_left.y = vect->y;
        return;
    }

    if ( vect->x < area->top_left.x )
    {
        area->top_left.x = vect->x;
    }
    if ( vect->y < area->top_left.y )
    {
        area->top_left.y = vect->y;
    }

    if ( vect->x > area->bottom_right.x )
    {
        area->bottom_right.x = vect->x;
    }
    if ( vect->y > area->bottom_right.y )
    {
        area->bottom_right.y = vect->y;
    }
}

/**
 * Converts an array of n_byte2 to a 2d vector (n_vect2)
 * @param converter the vector to hold the information.
 * @param input the n_byte2 that is converted to the n_vect2.
 */
void vect2_byte2( n_vect2 *converter, n_byte2 *input )
{
    NA_ASSERT( converter, "converter NULL" );
    NA_ASSERT( input, "input NULL" );

    if ( converter == 0L )
    {
        return;
    }
    if ( input == 0L )
    {
        return;
    }

    converter->x = input[0];
    converter->y = input[1];
}

/**
 * Adds two 2d vectors into a resultant vector.
 * @param equals the vector that holds the result.
 * @param initial the first vector to be added.
 * @param second the second vector to be added.
 */
void vect2_add( n_vect2 *equals, n_vect2 *initial, n_vect2 *second )
{
    NA_ASSERT( equals, "equals NULL" );
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );

    if ( equals == 0L )
    {
        return;
    }
    if ( initial == 0L )
    {
        return;
    }
    if ( second == 0L )
    {
        return;
    }

    equals->x = initial->x + second->x;
    equals->y = initial->y + second->y;
}


void vect2_center( n_vect2 *center, n_vect2 *initial, n_vect2 *second )
{
    vect2_add( center, initial, second );
    center->x = center->x / 2;
    center->y = center->y / 2;
}

void vect2_scalar_multiply( n_vect2 *value, n_int multiplier )
{
    value->x = value->x * multiplier;
    value->y = value->y * multiplier;
}

void vect2_scalar_divide( n_vect2 *value, n_int divisor )
{
    value->x = value->x / divisor;
    value->y = value->y / divisor;
}

void vect2_scalar_bitshiftdown( n_vect2 *value, n_int bitshiftdown )
{
    value->x = value->x >> bitshiftdown;
    value->y = value->y >> bitshiftdown;
}

/**
 * Subtracts one 2d vector from another 2d vector into a resultant vector.
 * @param equals the vector that holds the result.
 * @param initial the first vector.
 * @param second the second vector to be subtracted.
 */
void vect2_subtract( n_vect2 *equals, n_vect2 *initial, n_vect2 *second )
{
    NA_ASSERT( equals, "equals NULL" );
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );

    if ( equals == 0L )
    {
        return;
    }
    if ( initial == 0L )
    {
        return;
    }
    if ( second == 0L )
    {
        return;
    }

    equals->x = initial->x - second->x;
    equals->y = initial->y - second->y;
}

void vect2_divide( n_vect2 *equals, n_vect2 *initial, n_vect2 *second, n_int divisor )
{
    vect2_subtract( equals, second, initial );

    if ( equals == 0L || ( divisor == 0 ) )
    {
        return;
    }
    equals->x = equals->x / divisor;
    equals->y = equals->y / divisor;
}

/**
 * Multiplies one 2d vector with another 2d vector times a multiplier divided by a divisor.
 * @param equals the vector that holds the result.
 * @param initial the first vector.
 * @param second the second vector to be multiplied.
 * @param multiplier the scalar multiplier.
 * @param divisor the the scalar divisor.
 */
void vect2_multiplier( n_vect2 *equals, n_vect2 *initial, n_vect2 *second,
                       n_int multiplier, n_int divisor )
{
    NA_ASSERT( equals, "equals NULL" );
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );
    NA_ASSERT( divisor, "divisor ZERO" );

    if ( equals == 0L )
    {
        return;
    }
    if ( initial == 0L )
    {
        return;
    }
    if ( second == 0L )
    {
        return;
    }
    if ( divisor == 0L )
    {
        return;
    }

    equals->x = ( multiplier * initial->x * second->x ) / divisor;
    equals->y = ( multiplier * initial->y * second->y ) / divisor;
}

/**
 * Adds one 2d vector with another 2d vector times a multiplier divided by a divisor.
 * @param initial the first vector that takes the summation of the second vector.
 * @param second the second vector to be multiplied.
 * @param multiplier the scalar multiplier.
 * @param divisor the the scalar divisor.
 */
void vect2_d( n_vect2 *initial, n_vect2 *second, n_int multiplier, n_int divisor )
{
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );
    NA_ASSERT( divisor, "divisor ZERO" );

    if ( initial == 0L )
    {
        return;
    }
    if ( second == 0L )
    {
        return;
    }
    if ( divisor == 0L )
    {
        return;
    }

    initial->x += ( ( multiplier * second->x ) / divisor );
    initial->y += ( ( multiplier * second->y ) / divisor );
}

/**
 This produces the dot product of two vectors with the scalar multiplier
 and divisor noted.
 @param initial The first vector
 @param second  The second vector
 @param multiplier The numerator multiplier
 @param divisor The divisor multiplier
 @return The resultant scalar
 */
n_int vect2_dot( n_vect2 *initial, n_vect2 *second,
                 n_int multiplier, n_int divisor )
{
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );
    NA_ASSERT( divisor, "divisor ZERO" );

    if ( initial == 0L )
    {
        return 0;
    }
    if ( second == 0L )
    {
        return 0;
    }

    return ( multiplier * ( ( initial->x * second->x ) + ( initial->y * second->y ) ) ) / divisor;
}

n_int vect2_distance_under( n_vect2 *first, n_vect2 *second, n_int distance )
{
    n_vect2 difference = {{0, 0}};
    n_int   distance_squ;
    vect2_subtract( &difference, first, second );
    distance_squ = ( difference.x * difference.x ) + ( difference.y * difference.y );
    return ( distance * distance ) > distance_squ;
}

/**
 This produces a sine value
 @param direction 256 units per rotation
 @param divisor The divisor for the output value
 @return The sine value
 */
n_int math_sine( n_int direction, n_int divisor )
{
    NA_ASSERT( divisor, "divisor ZERO" );
    return new_sd[( direction ) & 255] / ( divisor );
}

void vect2_rotate90( n_vect2 *rotation )
{
    n_int  temp = rotation->y;
    rotation->y = 0 - rotation->x;
    rotation->x = temp;
}

/**
 This produces a direction vector
 @param initial The vector output
 @param direction 256 units per rotation
 @param divisor The divisor for the output value
 */
void vect2_direction( n_vect2 *initial, n_int direction, n_int divisor )
{
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( divisor, "divisor ZERO" );
    initial->x = ( ( new_sd[( ( direction ) + 64 ) & 255] ) / ( divisor ) );
    initial->y = ( ( new_sd[( direction ) & 255] ) / ( divisor ) );
}

void vect2_delta( n_vect2 *initial, n_vect2 *delta )
{
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( delta, "delta NULL" );

    if ( initial == 0L )
    {
        return;
    }
    if ( delta == 0L )
    {
        return;
    }

    initial->x += delta->x;
    initial->y += delta->y;
}

void vect2_offset( n_vect2 *initial, n_int dx, n_int dy )
{
    NA_ASSERT( initial, "initial NULL" );

    if ( initial == 0L )
    {
        return;
    }

    initial->x += dx;
    initial->y += dy;
}

void vect2_back_byte2( n_vect2 *converter, n_byte2 *output )
{
    NA_ASSERT( converter, "converter NULL" );
    NA_ASSERT( output, "output NULL" );

    if ( converter == 0L )
    {
        return;
    }
    if ( output == 0L )
    {
        return;
    }

    if ( converter->x > 65535 )
    {
        converter->x = 65535;
    }
    if ( converter->y > 65535 )
    {
        converter->y = 65535;
    }
    if ( converter->x < 0 )
    {
        converter->x = 0;
    }
    if ( converter->y < 0 )
    {
        converter->y = 0;
    }

    output[0] = ( n_byte2 ) converter->x;
    output[1] = ( n_byte2 ) converter->y;
}

void  vect2_copy( n_vect2 *to, n_vect2 *from )
{
    to->x = from->x;
    to->y = from->y;
}

void  vect2_populate( n_vect2 *value, n_int x, n_int y )
{
    value->x = x;
    value->y = y;
}

void vect2_rotation( n_vect2 *location, n_vect2 *rotation )
{
    n_vect2 temp;

    temp.x = ( ( location->x * rotation->x ) + ( location->y * rotation->y ) ) / SINE_MAXIMUM;
    temp.y = ( ( location->x * rotation->y ) - ( location->y * rotation->x ) ) / SINE_MAXIMUM;

    location->x = temp.x;
    location->y = temp.y;
}

void vect2_rotation_bitshift( n_vect2 *location, n_vect2 *rotation )
{
    n_vect2 temp;

    temp.x = ( ( location->x * rotation->x ) + ( location->y * rotation->y ) ) >> 15;
    temp.y = ( ( location->x * rotation->y ) - ( location->y * rotation->x ) ) >> 15;

    location->x = temp.x;
    location->y = temp.y;
}

n_int vect2_nonzero( n_vect2 *nonzero )
{
    return ( ( nonzero->x != 0 ) || ( nonzero->y != 0 ) );
}

n_vect2 *vect2_min_max_init( void )
{
    n_vect2 *min_max = memory_new( 2 * sizeof( n_vect2 ) );
    if ( min_max == 0L )
    {
        return 0L;
    }
    vect2_populate( &min_max[0], BIG_INTEGER, BIG_INTEGER );
    vect2_populate( &min_max[1], BIG_NEGATIVE_INTEGER, BIG_NEGATIVE_INTEGER );
    return min_max;
}

void vect2_min_max_permutation( n_vect2 * points, n_vect2 * minmax)
{
    n_int px = points->x;
    n_int py = points->y;
    if ( px < minmax[0].x )
    {
        minmax[0].x = px;
    }
    if ( py < minmax[0].y )
    {
        minmax[0].y = py;
    }

    if ( px > minmax[1].x )
    {
        minmax[1].x = px;
    }
    if ( py > minmax[1].y )
    {
        minmax[1].y = py;
    }
}

void vect2_min_max( n_vect2 *points, n_int number, n_vect2 *maxmin )
{
    n_int loop = 0;

    while ( loop < number )
    {
        n_int px = points[loop].x;
        n_int py = points[loop].y;
        if ( px < maxmin[0].x )
        {
            maxmin[0].x = px;
        }
        if ( py < maxmin[0].y )
        {
            maxmin[0].y = py;
        }

        if ( px > maxmin[1].x )
        {
            maxmin[1].x = px;
        }
        if ( py > maxmin[1].y )
        {
            maxmin[1].y = py;
        }
        loop++;
    }
}

void vect3_double( n_vect3 *converter, n_double *input )
{
    NA_ASSERT( converter, "converter NULL" );
    NA_ASSERT( input, "input NULL" );

    if ( converter == 0L )
    {
        return;
    }
    if ( input == 0L )
    {
        return;
    }

    converter->x = input[0];
    converter->y = input[1];
    converter->z = input[1];
}

void vect3_add( n_vect3 *equals, n_vect3 *initial, n_vect3 *second )
{
    NA_ASSERT( equals, "equals NULL" );
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );

    if ( equals == 0L )
    {
        return;
    }
    if ( initial == 0L )
    {
        return;
    }
    if ( second == 0L )
    {
        return;
    }

    equals->x = initial->x + second->x;
    equals->y = initial->y + second->y;
    equals->z = initial->z + second->z;
}


void vect3_center( n_vect3 *center, n_vect3 *initial, n_vect3 *second )
{
    vect3_add( center, initial, second );
    center->x = center->x / 2;
    center->y = center->y / 2;
    center->z = center->z / 2;
}

void vect3_subtract( n_vect3 *equals, n_vect3 *initial, n_vect3 *second )
{
    NA_ASSERT( equals, "equals NULL" );
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );

    if ( equals == 0L )
    {
        return;
    }
    if ( initial == 0L )
    {
        return;
    }
    if ( second == 0L )
    {
        return;
    }

    equals->x = initial->x - second->x;
    equals->y = initial->y - second->y;
    equals->z = initial->z - second->z;
}

void vect3_divide( n_vect3 *equals, n_vect3 *initial, n_vect3 *second, n_double divisor )
{
    vect3_subtract( equals, second, initial );

    if ( equals == 0L || ( divisor == 0 ) )
    {
        return;
    }
    equals->x = equals->x / divisor;
    equals->y = equals->y / divisor;
    equals->z = equals->z / divisor;
}

void vect3_multiplier( n_vect3 *equals, n_vect3 *initial, n_vect3 *second,
                       n_double multiplier, n_double divisor )
{
    NA_ASSERT( equals, "equals NULL" );
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );
    NA_ASSERT( divisor != 0, "divisor ZERO" );

    if ( equals == 0L )
    {
        return;
    }
    if ( initial == 0L )
    {
        return;
    }
    if ( second == 0L )
    {
        return;
    }
    if ( divisor == 0L )
    {
        return;
    }

    equals->x = ( multiplier * initial->x * second->x ) / divisor;
    equals->y = ( multiplier * initial->y * second->y ) / divisor;
    equals->z = ( multiplier * initial->z * second->z ) / divisor;
}

void vect3_d( n_vect3 *initial, n_vect3 *second, n_double multiplier, n_double divisor )
{
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );
    NA_ASSERT( divisor != 0, "divisor ZERO" );

    if ( initial == 0L )
    {
        return;
    }
    if ( second == 0L )
    {
        return;
    }
    if ( divisor == 0L )
    {
        return;
    }

    initial->x += ( ( multiplier * second->x ) / divisor );
    initial->y += ( ( multiplier * second->y ) / divisor );
    initial->z += ( ( multiplier * second->z ) / divisor );
}

n_double vect3_dot( n_vect3 *initial, n_vect3 *second,
                    n_double multiplier, n_double divisor )
{
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( second, "second NULL" );
    NA_ASSERT( divisor != 0, "divisor ZERO" );

    if ( initial == 0L )
    {
        return 0;
    }
    if ( second == 0L )
    {
        return 0;
    }

    return ( multiplier * ( ( initial->x * second->x ) + ( initial->y * second->y ) + ( initial->z * second->z ) ) ) / divisor;
}

void vect3_delta( n_vect3 *initial, n_vect3 *delta )
{
    NA_ASSERT( initial, "initial NULL" );
    NA_ASSERT( delta, "delta NULL" );

    if ( initial == 0L )
    {
        return;
    }
    if ( delta == 0L )
    {
        return;
    }

    initial->x += delta->x;
    initial->y += delta->y;
    initial->z += delta->z;
}

void vect3_offset( n_vect3 *initial, n_double dx, n_double dy, n_double dz )
{
    NA_ASSERT( initial, "initial NULL" );

    if ( initial == 0L )
    {
        return;
    }

    initial->x += dx;
    initial->y += dy;
    initial->z += dz;
}

void vect3_back_double( n_vect3 *converter, n_double *output )
{
    NA_ASSERT( converter, "converter NULL" );
    NA_ASSERT( output, "output NULL" );

    if ( converter == 0L )
    {
        return;
    }
    if ( output == 0L )
    {
        return;
    }

    output[0] = converter->x;
    output[1] = converter->y;
    output[2] = converter->z;
}

void  vect3_copy( n_vect3 *to, n_vect3 *from )
{
    to->x = from->x;
    to->y = from->y;
    to->z = from->z;
}

void  vect3_populate( n_vect3 *value, n_double x, n_double y, n_double z )
{
    value->x = x;
    value->y = y;
    value->z = z;
}

n_int vect3_nonzero( n_vect3 *nonzero )
{
    return ( ( nonzero->x != 0 ) || ( nonzero->y != 0 ) || ( nonzero->z != 0 ) );
}

n_array * vect2_memory_list_number_array(memory_list * list, n_int number)
{
    n_array * array = 0L;
    if ((list == 0L) || (number == 0))
    {
        return 0L;
    }
    if (list->count)
    {
        n_int count = 0;
        while (count < list->count)
        {
            n_vect2 * vects = (n_vect2 *) list->data;
            array_add_empty(&array, array_array(object_vect2_pointer(&vects[count * number], number)));
            count++;
        }
    }
    return array;
}


n_int vect2_unwrap_number( n_array * array, n_vect2 * entry, n_int number)
{
    n_int     out_value = 0;
    if (array)
    {
        memory_list * elements = object_list_vect2(array);
        if (elements->count == number)
        {
            n_vect2 * vect = (n_vect2 *)elements->data;
            n_int count = 0;
            while (count < number)
            {
                entry[count].data[0] = vect[count].data[0];
                entry[count].data[1] = vect[count].data[1];
                count++;
            }
            out_value = 1;
        }
        memory_list_free(&elements);
    }
    return out_value;
}

n_int vect2_unwrap_number_entry( n_string pass_through, n_byte * buffer, n_int number)
{
    return vect2_unwrap_number( (n_array *) pass_through, (n_vect2 *) buffer, number);
}

n_int vect2_unwrap_quad( n_string pass_through, n_byte * buffer)
{
    return vect2_unwrap_number_entry( pass_through, buffer, 4);

}

n_int vect2_unwrap_line( n_string pass_through, n_byte * buffer)
{
    return vect2_unwrap_number_entry( pass_through, buffer, 2);
}



/* ./script/interpret.c */
/****************************************************************

 interpret.c

 =============================================================



 ****************************************************************/

/*! \file   interpret.c
 *  \brief  This handles the interpretation end of ApeScript (i.e. after parsing).
    Unlike the parsing code that should be run only once in general use, the
    interpretation code is run multiple times in a simulation cycle. Thus slightly
    more care must be taken in optimizing the interpret code.
 */

#include "toolkit.h"

#include "script.h"

/**
 * Makes sure all the data associated with the interpreter is freed etc.
 * @param individual pointer to the interpreter structure that is being executed.
 * @param eval pointer execution points being executed.
 * @param location the location in the execution points.
 * @return minus one on failure, zero on success.
 */
static	n_int	interpret_braces( n_individual_interpret *individual, n_byte *eval, n_int location )
{
    n_int		local_b_count;

    NA_ASSERT( individual, "individual NULL" );

    local_b_count = individual->braces_count;
    if ( location == -1 )
    {
        if ( local_b_count == 0 )
        {
            return APESCRIPT_ERROR( individual, AE_TOO_MANY_CLOSE_BRACES );
        }
        individual->braces_count--;
    }
    else
    {
        n_uint		loop = 0;
        n_byte		*local_evaluate;
        if ( local_b_count == BRACES_MAX )
        {
            return APESCRIPT_ERROR( individual, AE_MAXIMUM_BRACES_REACHED );
        }
        local_evaluate = individual->braces[ local_b_count ].evaluate;
        while ( loop < SIZE_OF_EVALUATE )
        {
            n_byte	eval_val = 0;
            if ( eval != 0L )
            {
                eval_val = eval[loop];
            }
            local_evaluate[ loop++ ] = eval_val;
        }
        individual->braces[ local_b_count ].braces_start = location;
        individual->braces_count++;
    }
    return 0;
}

/**
 * Makes sure all the data associated with the interpreter is freed etc.
 * @param code pointer to the interpreter structure that is being executed.
 * @param evaluate pointer execution points being executed.
 * @param number the pointer to the result of the execution block.
 * @param end_char the end character expected.
 * @return minus one on failure, otherwise the number of execution points to advance.
 */
static n_int interpret_apply( n_interpret *code, n_individual_interpret *individual, n_byte *evaluate, n_int *number, n_byte end_char )
{
    n_int	val_a, val_b, val_c;

    NA_ASSERT( code, "code NULL" );
    NA_ASSERT( evaluate, "evaluate NULL" );
    NA_ASSERT( number, "number NULL" );

    if ( code == 0L )
    {
        return SHOW_ERROR( "No code provided" );
    }
    if ( evaluate == 0L )
    {
        return SHOW_ERROR( "Nothing to evaluate" );
    }
    if ( number == 0L )
    {
        return SHOW_ERROR( "No numbers provided" );
    }

    if ( code->sc_output( code, individual, evaluate, &val_a ) == -1 )
    {
        return APESCRIPT_ERROR( individual, AE_FIRST_VALUE_FAILED );
    }
    if ( evaluate[2] == end_char )
    {
        *number = val_a;
        return 3;
    }
    if ( evaluate[2] != APESCRIPT_OPERATOR )
    {
        return APESCRIPT_ERROR( individual, AE_UNKNOWN_SYNTAX_MISSING_EQUALS );
    }
    if ( code->sc_output( code, individual, &evaluate[4], &val_b ) == -1 )
    {
        return APESCRIPT_ERROR( individual, AE_SECOND_VALUE_FAILED );
    }
    val_c = val_a - val_b;
    switch ( evaluate[3] )
    {
    case SYNTAX_MINUS:
        *number = val_c;
        break;
    case SYNTAX_ADDITION:
        *number = ( val_a + val_b );
        break;
    case SYNTAX_MULTIPLY:
        *number = ( val_a * val_b );
        break;
    case SYNTAX_AND:
        *number = ( val_a & val_b );
        break;
    case SYNTAX_XOR:
        *number = ( val_a ^ val_b );
        break;
    case SYNTAX_OR:
        *number = ( val_a | val_b );
        break;
    case SYNTAX_GREATER_THAN:
        *number = ( ( 0 - val_c ) < 0 );
        break;
    case SYNTAX_LESS_THAN:
        *number = ( val_c < 0 );
        break;
    case SYNTAX_EQUAL_TO:
        *number = ( val_c == 0 );
        break;
    case SYNTAX_NOT_EQUAL_TO:
        *number = ( val_c != 0 );
        break;
    case SYNTAX_CONDITIONAL_AND:
        *number = ( val_a && val_b );
        break;
    case SYNTAX_CONDITIONAL_OR:
        *number = ( val_a || val_b );
        break;
    case SYNTAX_DIVISION:
        if ( val_b == 0 )
        {
            *number = 0;
        }
        else
        {
            *number = ( val_a / val_b );
        }
        break;
    case SYNTAX_MODULUS:
        if ( val_b == 0 )
        {
            *number = 0;
        }
        else
        {
            *number = ( val_a % val_b );
        }
        break;
    case SYNTAX_GREATER_EQUAL:
        *number = ( ( 0 - val_c ) <= 0 );
        break;
    case SYNTAX_LESS_EQUAL:
        *number = ( val_c <= 0 );
        break;
    case SYNTAX_BITSHIFT_RIGHT:
        val_b = 0 - val_b;
    case SYNTAX_BITSHIFT_LEFT:
        if ( val_b == 0 )
        {
            *number = val_a;
        }
        else
        {
            if ( val_b < 0 )
            {
                *number = val_a << val_b;
            }
            else
            {
                val_b = 0 - val_b;
                *number = val_a >> val_b;
            }
        }
        break;
    default:
        return APESCRIPT_ERROR( individual, AE_UNKNOWN_SYNTAX_NO_COMMAND );
        break;
    }

    if ( evaluate[6] == end_char )
    {
        return 7;
    }
    return APESCRIPT_ERROR( individual, AE_WRONG_END );
}

/**
 * Makes sure all the data associated with the interpreter is freed etc.
 * @param code pointer to the interpreter structure that is being executed.
 * @param value pointer execution points being executed.
 * @param location the location in the execution points.
 * @return minus one on failure, otherwise the number of execution points to advance.
 */
static n_int interpret_syntax( n_interpret *code, n_individual_interpret *individual, n_byte *value, n_int location )
{
    n_byte	first_value;
    n_byte	second_value;
    n_int	output_number = 0;

    NA_ASSERT( code, "code NULL" );
    NA_ASSERT( value, "value NULL" );

    if ( code == 0L )
    {
        return SHOW_ERROR( "No code provided" );
    }
    if ( value == 0L )
    {
        return SHOW_ERROR( "No values provided" );
    }

    first_value = value[0];
    second_value = value[1];

    if ( first_value == APESCRIPT_CLOSE_BRACE ) /* what do you do with the tailing brace? */
    {
        n_brace	*local_brace;
        n_int	brace_value = ( individual->braces_count ) - 1;
        if ( brace_value < 0 )
        {
            return APESCRIPT_ERROR( individual, AE_TOO_MANY_CLOSE_BRACES );
        }
        local_brace = &( individual->braces[brace_value] );
        if ( local_brace->evaluate[0] == 0 ) /* exit if */
        {
            if ( interpret_braces( individual, 0L, -1 ) == -1 )
            {
                return -1; /* Enough error information provided by this point */
            }
            SC_DEBUG_STRING( individual->interpret_data, "}" );
            SC_DEBUG_DOWN( individual->interpret_data );
            SC_DEBUG_NEWLINE( individual->interpret_data );
            return 1;
        }
        return 0; /* exit while and run function */
    }
    if ( first_value != APESCRIPT_TEXT )
    {
        return APESCRIPT_ERROR( individual, AE_LINE_START_INCORRECT );
    }

    if ( ( second_value > VARIABLE_IF ) && ( second_value <= code->input_greater ) )
    {
        return APESCRIPT_ERROR( individual, AE_OUTPUT_SET_AS_INPUT_VARIABLE );
    }

    if ( VARIABLE_SPECIAL( second_value, code ) ) /* if/while/function/run( something ){} */
    {
        n_int	return_value;
        n_int	error_value = -1;
        if ( value[2] != APESCRIPT_OPEN_BRACKET )
        {
            return APESCRIPT_ERROR( individual, AE_IF_WHILE_NOT_FOLLOWED_BY_BRACKET );
        }
        return_value = interpret_apply( code, individual, &value[3], &output_number, APESCRIPT_CLOSE_BRACKET );
        if ( return_value == -1 )
        {
            return -1; /* Enough information presented by this point */
        }
        if ( second_value == VARIABLE_FUNCTION || second_value == VARIABLE_RUN )
        {
            if ( value[3] != APESCRIPT_TEXT )
            {
                return APESCRIPT_ERROR( individual, AE_FUNCTION_ISNT_VARIABLE );
            }
            if ( return_value != 3 )
            {
                return APESCRIPT_ERROR( individual, AE_NON_FUNCTION_APPLIED );
            }
        }
        else
        {
            SC_DEBUG_STRING( individual->interpret_data, scdebug_variable( second_value ) );
            SC_DEBUG_STRING( individual->interpret_data, " ( ) {" );
            if ( output_number == 0 )
            {
                SC_DEBUG_STRING( individual->interpret_data, " }" );
            }
            else
            {
                SC_DEBUG_UP( individual->interpret_data );
            }
            SC_DEBUG_NEWLINE( individual->interpret_data );
        }
        if ( second_value == VARIABLE_FUNCTION )
        {
            if ( output_number != 0 )
            {
                return APESCRIPT_ERROR( individual, AE_FUNCTION_DEFINED_PRIOR );
            }
        }
        if ( second_value == VARIABLE_RUN )
        {
            if ( ( output_number < 1 ) || ( output_number > 0xFFFF ) )
            {
                return APESCRIPT_ERROR( individual, AE_FUNCTION_OUT_OF_RANGE );
            }
            if ( value[3 + return_value] != APESCRIPT_SEMICOLON )
            {
                return APESCRIPT_ERROR( individual, AE_WITHOUT_SEMICOLON );
            }
            {
                n_byte	function_location[SIZE_OF_EVALUATE] = {APESCRIPT_FUNCTION, 0};
                n_byte	*location_write = ( n_byte * )&function_location[1];
                n_int	continuation = return_value + 4 + location;
                io_int_to_bytes( output_number, location_write );
                location_write = ( n_byte * )&function_location[1 + SIZEOF_NUMBER_WRITE];
                io_int_to_bytes( continuation, location_write );

                NA_ASSERT( ( n_byte * )function_location, "eval function_location" );
                if ( interpret_braces( individual, ( n_byte * )function_location, 0 ) == -1 )
                {
                    return -1; /* Enough information presented by this point */
                }
            }
            SC_DEBUG_STRING( individual->interpret_data, "run( " );
            SC_DEBUG_STRING( individual->interpret_data, scdebug_variable( value[4] ) );
            SC_DEBUG_STRING( individual->interpret_data, " ){" );
            SC_DEBUG_UP( individual->interpret_data );
            SC_DEBUG_NEWLINE( individual->interpret_data );
            return 0; /* want to trigger while check */
        }
        /* if the future code will contain if()run(); then the if should be checked here */
        if ( value[3 + return_value] != APESCRIPT_OPEN_BRACE )
        {
            return APESCRIPT_ERROR( individual, AE_WITHOUT_OPEN_BRACE );
        }
        if ( second_value == VARIABLE_FUNCTION )
        {
            if ( code->sc_input( individual, value[4], ( 4 + return_value + location ) ) == -1 )
            {
                return APESCRIPT_ERROR( individual, AE_FUNCTION_SETTING_FAILED );
            }
            if ( value[4] == code->main_entry )
            {
                if ( interpret_braces( individual, 0L, 0 ) == -1 )
                {
                    return APESCRIPT_ERROR( individual, AE_ERROR_STARTING_MAIN );
                }
                individual->main_status = MAIN_RUN;
                SC_DEBUG_STRING( individual->interpret_data, "function( " );
                SC_DEBUG_STRING( individual->interpret_data, scdebug_variable( value[4] ) );
                SC_DEBUG_STRING( individual->interpret_data, " ){" );
                SC_DEBUG_UP( individual->interpret_data );
                SC_DEBUG_NEWLINE( individual->interpret_data );
                return 3 + 4; /* tF(tf){*/
            }
            if ( individual->main_status != MAIN_NOT_RUN )
            {
                return APESCRIPT_ERROR( individual, AE_CODE_AFTER_MAIN );
            }
        }
        /* if the result is zero find the end of the correctly nested } */
        if ( output_number == 0 )
        {
            n_int	loop = return_value + 4;
            n_int	braces_open = 1;
            n_int   remaining_bytes = ( n_int )code->binary_code->location;
            do
            {
                n_byte	actual_value = value[loop++];
                /* get actual point, avoid text variable numerical reference to { } */
                if ( CODE_VALUE_REQUIRED( actual_value ) )
                {
                    loop++;
                }
                if ( actual_value == APESCRIPT_OPEN_BRACE )
                {
                    braces_open ++;
                }
                if ( actual_value == APESCRIPT_CLOSE_BRACE )
                {
                    braces_open --;
                }
                if ( ( loop + location ) > remaining_bytes )
                {
                    return APESCRIPT_ERROR( individual, AE_NO_CLOSE_BRACE_TO_END_OF_FILE );
                }
            }
            while ( braces_open != 0 );
            return loop;
        }
        /* evaulate accordingly */
        if ( second_value == VARIABLE_IF )
        {
            error_value = interpret_braces( individual, 0L, 0 );
        }
        if ( second_value == VARIABLE_WHILE )
        {
            NA_ASSERT( &value[3], "eval value[3]" );
            error_value = interpret_braces( individual, &value[3], location + return_value + 4 );
        }
        if ( error_value == -1 )
        {
            return -1; /* Enough information presented by this point */
        }
        return return_value + 4;
    }
    if ( individual->main_status == MAIN_NOT_RUN )
    {
        return APESCRIPT_ERROR( individual, AE_CODE_OUTSIDE_FUNCTION );
    }
    if ( VARIABLE_INPUT( second_value, code ) ) /* x = y + z; */
    {
        n_int	return_value;
        if ( ( value[2] != APESCRIPT_OPERATOR ) || ( value[3] != SYNTAX_EQUALS ) )
        {
            return APESCRIPT_ERROR( individual, AE_INPUT_VARIABLE_WITHOUT_EQUALS );
        }
        return_value = interpret_apply( code, individual, &value[4], &output_number, APESCRIPT_SEMICOLON );
        if ( return_value == -1 )
        {
            return -1; /* Enough information presented by this point */
        }
        if ( code->sc_input( individual, second_value, output_number ) == -1 )
        {
            return APESCRIPT_ERROR( individual, AE_ASSIGN_VALUE_FAILED );
        }
        SC_DEBUG_STRING( individual->interpret_data, scdebug_variable( second_value ) );
        SC_DEBUG_STRING( individual->interpret_data, " = " );
        SC_DEBUG_NUMBER( individual->interpret_data, output_number );
        SC_DEBUG_STRING( individual->interpret_data, " ;" );
        SC_DEBUG_NEWLINE( individual->interpret_data );
        return return_value + 4;
    }
    return APESCRIPT_ERROR( individual, AE_UNKNOWN_SYNTAX_FROM_INTERPRET );
}

/**
 * The start of the interpreter cycle.
 * @param interp pointer to the interpreter structure that is being executed.
 */
static void interpret_start( n_interpret *interp, n_individual_interpret *individual )
{
    n_byte	*local_data     = interp->binary_code->data;
    n_int	*local_number   = interp->number_buffer;
    n_int	*local_variable = individual->variable_references;
    n_int	 end_loop = io_bytes_to_int( local_data );
    n_byte	*start_numbers = &local_data[end_loop];
    n_int	 local_number_num = io_bytes_to_int( start_numbers );
    n_int	 loop = 0;
    individual->main_status = MAIN_NOT_RUN;
    individual->braces_count = 0;
    while ( loop++ < BRACES_MAX )
    {
        ( void )interpret_braces( individual, 0L, 0 ); /* No errors in this initialisation */
    }
    individual->braces_count = 0;
    loop = 1;
    local_number[0] = 0;
    while ( loop < local_number_num )
    {
        local_number[loop] = ( n_int )io_bytes_to_int( &start_numbers[loop * ( n_int )SIZEOF_NUMBER_WRITE] );
        loop++;
    }
    loop = 0;
    while ( loop < ( VARIABLE_MAX ) )
    {
        local_variable[loop++] = 0;
    }
}

/**
 * Makes sure all the data associated with the interpreter is freed etc.
 * @param interp pointer to the interpreter structure that is being executed.
 * @return zero on success, minus one on failure.
 */
static n_int	interpret_code( n_interpret *interp, n_individual_interpret *individual )
{
    n_byte	*local_data  = interp->binary_code->data;
    n_int	 loop        = SIZEOF_NUMBER_WRITE;
    n_int	 cycle_count = 0;
    n_int	 end_loop    = io_bytes_to_int( local_data );

    if ( individual->interpret_location != 0 )
    {
        loop = individual->interpret_location;
        individual->interpret_location = 0;
    }

    /* this is the interpret loop */
    do
    {
        n_int	result = interpret_syntax( interp, individual, &local_data[loop], loop );
        if ( result == -1 )
        {
            return -1; /* Enough information presented by this point */
        }

        if ( result != 0 )
        {
            loop += result;
        }
        else     /* This is the while check conditional */
        {
            n_brace *local_brace;
            n_int	  brace_number = ( individual->braces_count - 1 );
            n_byte	  first_evaluate;
            if ( brace_number < 0 )
            {
                return APESCRIPT_ERROR( individual, AE_TOO_MANY_CLOSE_BRACES );
            }
            local_brace = &( individual->braces[brace_number] );
            first_evaluate = local_brace->evaluate[0];
            if ( first_evaluate == APESCRIPT_RUN || first_evaluate == APESCRIPT_FUNCTION ) /* check the function run */
            {
                if ( first_evaluate == APESCRIPT_FUNCTION )
                {
                    local_brace->evaluate[0] = APESCRIPT_RUN;
                    loop = io_bytes_to_int( &( local_brace->evaluate[1] ) );
                }
                else   /* end of the run function , put back to where 'run' is called */
                {
                    loop = io_bytes_to_int( &( local_brace->evaluate[1 + SIZEOF_NUMBER_WRITE] ) );
                    if ( interpret_braces( individual, 0L, -1 ) == -1 ) /* remove the run function from braces */
                    {
                        return -1; /* Enough information presented by this point */
                    }
                    SC_DEBUG_STRING( individual->interpret_data, "}" );
                    SC_DEBUG_DOWN( individual->interpret_data );
                    SC_DEBUG_NEWLINE( individual->interpret_data );
                }
            }
            else
            {
                n_int	  return_value = 0;

                if ( interpret_apply( interp, individual, local_brace->evaluate, &return_value, APESCRIPT_CLOSE_BRACKET ) == -1 )
                {
                    return -1; /* Enough information presented by this point */
                }
                if ( return_value == 0 )
                {
                    if ( interpret_braces( individual, 0L, -1 ) == -1 )
                    {
                        return -1; /* Enough information presented by this point */
                    }
                    SC_DEBUG_STRING( individual->interpret_data, "}" );
                    SC_DEBUG_DOWN( individual->interpret_data );
                    SC_DEBUG_NEWLINE( individual->interpret_data );
                    loop++;
                }
                else
                {
                    loop = local_brace->braces_start;
                }
            }
        }

        cycle_count++;
    }
    while ( ( loop < end_loop ) && ( cycle_count < CYCLE_COUNT_RESET ) && ( individual->leave == 0 ) );

    if ( ( individual->leave != 0 ) || ( cycle_count == CYCLE_COUNT_RESET ) )
    {
        individual->interpret_location = loop;
    }
    else
    {
        if ( individual->main_status == MAIN_NOT_RUN )
        {
            return APESCRIPT_ERROR( individual, AE_NO_MAIN_CODE );
        }

        SC_DEBUG_OFF( individual->interpret_data ); /* turn off debugging after first cycle */
    }

    return 0;
}

void interpret_individual( n_individual_interpret *individual )
{
    individual->interpret_location = 0;
    individual->leave = 0;
    individual->localized_leave = 0;
}

/**
 Makes sure all the data associated with the interpreter is freed etc.
 @param to_clean The pointer to the n_interpret struct that is being expunged.
 */
void interpret_cleanup( n_interpret **to_clean )
{
#ifdef SCRIPT_DEBUG
    scdebug_file_cleanup();
#endif
    if ( *to_clean == 0L )
    {
        return;
    }
    if ( ( *to_clean )->binary_code != 0L )
    {
        io_file_free( &( ( *to_clean )->binary_code ) );
    }
    memory_free( ( void ** )to_clean );
}

/**
 * This processes a single cycle of the ApeScript interpreter.
 * @param code the ApeScript code to be executed.
 * @param exit_offset if greater than minus one, the value entry to indicate exiting interpreter.
 * @param structure the structure to be passed into the start and end functions.
 * @param start the function to be run at the start of the ApeScript cycle.
 * @param end the function to be run at the end of the ApeScript cycle.
 * @return -1 in error case, 0 in leave and don't cycle back, 1 in leave and continue to cycle back.
 */
n_int interpret_cycle( n_interpret *code, n_individual_interpret *individual, n_int exit_offset,
                       void *structure, void *data,
                       script_external *start, script_external *end )
{
    if ( code == 0L )
    {
        return 0;
    }

    individual->interpret_data = data;

    if ( individual->localized_leave )
    {
        individual->localized_leave--;
    } /* the localized_leave = 1 case is where the interpreter was left initially */
    if ( individual->localized_leave )
    {
        return 1;
    }

    if ( individual->interpret_location == 0 )
    {
        interpret_start( code, individual );
        if ( start != 0L )
        {
            ( *start )( individual, structure, data );
        }
    }

    if ( interpret_code( code, individual ) == -1 )
    {
        return -1;
    }

    if ( individual->interpret_location == 0 )
    {
        if ( ( code != 0L ) && ( end != 0L ) )
        {
            ( *end )( individual, structure, data );
        }
    }

    individual->localized_leave = individual->leave;

    if ( exit_offset > -1 )
    {
        n_int *variables = individual->variable_references;
        if ( variables[exit_offset] == 0 )
        {
            return 1;
        }
    }
    return 0;
}

n_int apescript_error( n_individual_interpret *individual, AE_ENUM value, n_constant_string location, n_int line_number )
{
    n_int    loop = 0;
    AE_ENUM  local_enum;
    n_constant_string local_error;
    do
    {
        local_enum = apescript_errors[loop].enum_value;
        local_error = apescript_errors[loop].error_string;
        if ( value == local_enum )
        {
            if ( individual->interpret_data )
            {
                SC_DEBUG_STRING( individual->interpret_data, " [ ERROR : " );
                SC_DEBUG_STRING( individual->interpret_data, local_error );
                SC_DEBUG_STRING( individual->interpret_data, " ]" );
                SC_DEBUG_NEWLINE( individual->interpret_data );
                SC_DEBUG_OFF( individual->interpret_data );
            }
            return SHOW_ERROR_FILE_LINE( local_error, location, line_number );
        }
        loop++;
    }
    while ( ( local_enum != AE_NO_ERROR ) && ( local_error != 0L ) );

    return apescript_error( individual, AE_UNKNOWN_ERROR, location, line_number );
}



/* ./script/parse.c */
/****************************************************************

 parse.c

 =============================================================



 ****************************************************************/

/*! \file   parse.c
 *  \brief  This parses ApeScript and produces the ApeScript byte-code.
 */

#include "toolkit.h"

#include "script.h"

#if defined(ROUGH_CODE_OUT) || defined(COMMAND_LINE_DEBUG)

#include <stdio.h>

#endif

#define	SYNTAX_NUM				19
#define	SYNTAX_WIDTH			4
static const n_byte	syntax_codes[SYNTAX_NUM][SYNTAX_WIDTH] =
{
    "-",
    "+",
    "*",
    "&",
    "^",
    "|",

    ">",
    "<",
    "==",
    "!=",
    "&&",
    "||",
    "/",

    "%",

    ">>",
    "<<",

    "<=",
    ">=",

    "="
};

static n_int	variable_num;
static n_int	number_num;

static n_int    quote_up;

#ifdef SCRIPT_DEBUG

static n_int	          tab_step = 0;
static variable_string	 *local_var_codes;

n_file                   *file_debug = 0L;
static n_int              single_entry = 1;

static void              *writable_selection;

n_file *scdebug_file_ready( void )
{
    return io_file_ready( single_entry, file_debug );
}

void scdebug_file_cleanup( void )
{
    io_file_cleanup( &single_entry, &file_debug );
}

void scdebug_writeon( void *ptr )
{
    writable_selection = ptr;
    io_file_writeon( &single_entry, &file_debug, 1 );
}

void scdebug_writeoff( void *ptr )
{
    if ( ptr != writable_selection )
    {
        return;
    }

    io_file_writeoff( &single_entry, file_debug );
}

void scdebug_string( void *ptr, n_constant_string string )
{
    if ( ptr != writable_selection )
    {
        return;
    }

    io_file_string( single_entry, file_debug, string );
}

n_string scdebug_variable( n_int variable )
{
    n_string return_value = 0L;
    if ( ( variable < VARIABLE_MAX )
#ifndef COMMAND_LINE_DEBUG
            && ( file_debug  != 0L )
#endif
       )
    {
        return_value = ( n_string ) local_var_codes[variable];
    }
    return return_value;
}

void scdebug_int( void *ptr, n_int number )
{
    if ( single_entry == 0 )
    {
        return;
    }

    if ( ptr != writable_selection )
    {
        return;
    }

#ifndef COMMAND_LINE_DEBUG
    if ( file_debug  != 0L )
    {
        io_writenumber( file_debug, number, 1, 0 );
    }
#else
    printf( "%d", ( int )number );
#endif
}

void scdebug_newline( void *ptr )
{
    if ( single_entry == 0 )
    {
        return;
    }

    if ( ptr != writable_selection )
    {
        return;
    }

#ifndef COMMAND_LINE_DEBUG
    if ( file_debug != 0L )
#endif
    {
        n_int loop = 0;
#ifndef COMMAND_LINE_DEBUG
        io_write( file_debug, "", 1 );
#else
        printf( "\n" );
#endif
        if ( tab_step > 0 )
        {
            while ( loop < tab_step )
            {
#ifndef COMMAND_LINE_DEBUG
                io_write( file_debug, "  ", 0 );
#else
                printf( "  " );
#endif
                loop++;
            }
        }
    }
}

void scdebug_tabstep( void *ptr, n_int steps )
{
    if ( ptr != writable_selection )
    {
        return;
    }

#ifndef COMMAND_LINE_DEBUG
    if ( file_debug != 0L )
#endif
    {
        tab_step += steps;
    }
}
#endif


static n_int parse_number_add( n_interpret *interpret, n_int out_value )
{
    n_int 	loop = 0;

    /* is this number already stored? */
    while ( loop < number_num )
    {
        if ( interpret->number_buffer[loop] == out_value )
        {
            return loop;
        }
        loop++;
    }
    /* if not, add it to the number store */
    interpret->number_buffer[loop] = out_value;
    if ( number_num < NUMBER_MAX )
    {
        number_num++;
    }
    else
    {
        return APESCRIPT_ERROR( 0L, AE_MAXIMUM_NUMBERS_REACHED );
    }
    return loop;
}

/* outputs the number of bytes to advance in the interpret stream */
static n_int parse_number( n_interpret *interpret, const n_byte *number )
{
    n_int 	out_value = 0;
    n_int 	point_counter = 0;

    /* read out the number from the interpret stream */
    do
    {
        n_byte temp = number[point_counter++];
        if ( ( !ASCII_NUMBER( temp ) ) && ( temp != 0 ) )
        {
            return APESCRIPT_ERROR( 0L, AE_NUMBER_EXPECTED ); /* this error should never occur */
        }
        out_value = ( out_value * 10 ) + ( temp - '0' );
    }
    while ( ( number[point_counter] != 0 ) && ( out_value > -1 ) );

    if ( ( out_value < 0 ) || ( out_value > 0x7fffffff ) )
    {
        return APESCRIPT_ERROR( 0L, AE_NUMBER_OUT_OF_RANGE );
    }

    return parse_number_add( interpret, out_value );
}

static n_int parse_quoted_string( n_interpret *interpret, n_constant_string string )
{
    return parse_number_add( interpret, ( n_int )math_hash_fnv1( string ) );
}

static n_byte parse_character( n_byte temp )
{
    if ( ASCII_QUOTE( temp ) )
    {
        quote_up ^= 1;
        return APESCRIPT_STRING;
    }

    if ( quote_up )
    {
        return APESCRIPT_STRING;
    }
    if ( ASCII_BRACES( temp ) || ASCII_BRACKET( temp ) )
    {
        return temp;
    }
    if ( ( ASCII_EQUAL( temp ) || ASCII_LOGICAL( temp ) ) || ( ASCII_ARITHMETIC( temp ) || ASCII_DIRECTIONAL( temp ) ) )
    {
        return APESCRIPT_OPERATOR;
    }
    if ( ASCII_NUMBER( temp ) )
    {
        return APESCRIPT_NUMBER;
    }
    if ( ASCII_TEXT( temp ) )
    {
        return APESCRIPT_TEXT;
    }
    if ( ASCII_SEMICOLON( temp ) )
    {
        return APESCRIPT_SEMICOLON;
    }
    return APESCRIPT_FAILURE;
}

static n_int parse_write_code( n_interpret *final_prog, n_byte value, n_byte code )
{
#ifdef ROUGH_CODE_OUT
    printf( "%c ", value );
#endif

    if ( io_file_write( final_prog->binary_code, value ) == -1 )
    {
        return APESCRIPT_ERROR( 0L, AE_MAXIMUM_SCRIPT_SIZE_REACHED );
    }
    if ( CODE_VALUE_REQUIRED( value ) )
    {
        if ( io_file_write( final_prog->binary_code, code ) == -1 )
        {
            return APESCRIPT_ERROR( 0L, AE_MAXIMUM_SCRIPT_SIZE_REACHED );
        }

#ifdef ROUGH_CODE_OUT
        printf( "%d ", code );
#endif
    }

#ifdef ROUGH_CODE_OUT
    if ( value == APESCRIPT_SEMICOLON || value == APESCRIPT_OPEN_BRACE || value == APESCRIPT_CLOSE_BRACE )
    {
        printf( "\n" );
    }
#endif
    return 0;
}

static n_int parse_string( const n_byte *test, const n_byte *compare, n_int number )
{
    n_int		loop = 0;
    while ( loop < number )
    {
        if ( test[loop] != compare[loop] )
        {
            return -1;
        }
        loop++;
    }
    return 1;
}

static n_int parse_buffer( n_interpret *final_prog, n_byte previous, const n_byte *buffer )
{
    variable_string *variable_codes = final_prog->variable_strings;
    n_int			 result = -1;
    n_int			 loop = 0;
    switch ( previous )
    {
    case ( APESCRIPT_NUMBER ):
        result = parse_number( final_prog, buffer ); /* this loads the number into the number buffer */
        if ( result == -1 )
        {
            return -1;
        }
        if ( parse_write_code( final_prog, previous, ( n_byte )result ) == -1 ) /* this writes the number allocation code */
        {
            return -1;
        }
        break;

    case ( APESCRIPT_STRING ):
        result = parse_quoted_string( final_prog, ( n_constant_string )buffer ); /* this loads the number into the number buffer */
        if ( result == -1 )
        {
            return -1;
        }
        if ( parse_write_code( final_prog, APESCRIPT_NUMBER, ( n_byte )result ) == -1 ) /* this writes the number allocation code */
        {
            return -1;
        }
        break;
    case ( APESCRIPT_TEXT ):
        while ( ( loop < variable_num ) && ( result == -1 ) )
        {
            if ( parse_string( variable_codes[loop], buffer, VARIABLE_WIDTH ) == 1 )
            {
                result = loop;
            }
            loop++;
        }
        if ( result == -1 )
        {
            if ( variable_num < VARIABLE_MAX )
            {
                n_int loop2 = 0;
                while ( loop2 < ( VARIABLE_WIDTH ) )
                {
                    variable_codes[variable_num][loop2] = buffer[loop2];
                    loop2++;
                }
                variable_num++;
            }
            else
            {
                return APESCRIPT_ERROR( 0L, AE_MAXIMUM_VARIABLES_REACHED );
            }
            result = loop;
        }
        if ( parse_write_code( final_prog, previous, ( n_byte )result ) == -1 )
        {
            return -1;
        }
        break;
    case ( APESCRIPT_OPERATOR ):
        while ( ( loop < SYNTAX_NUM ) && ( result == -1 ) )
        {
            if ( parse_string( syntax_codes[loop], buffer, SYNTAX_WIDTH ) == 1 )
            {
                result = loop;
            }
            loop++;
        }
        if ( result == -1 ) /* no error reported up until now */
        {
            return APESCRIPT_ERROR( 0L, AE_UNKNOWN_SYNTAX_PARSER_BUFFER );
        }
        if ( parse_write_code( final_prog, previous, ( n_byte )result ) == -1 )
        {
            return -1;
        }
        break;
    default:
    {
        n_byte	value;
        while ( ( value = buffer[loop++] ) != 0 )
        {
            if ( parse_write_code( final_prog, value, 0 ) == -1 )
            {
                return -1;
            }
        }
    }
    break;
    }
    return 0;
}

/**
 Turns an input file into an interpret-able pointer.
 @param input The file pointer containing the ApeScript text data.
 @param main_entry The variable defined as main. In the case of this implementation
 of ApeScript, being.
 @param variables The pointer to the variable string used for debugging to output the
 actual variable names.
 @return The interpreter pointer created from the file pointer.
 */
n_interpret 	*parse_convert( n_file *input, n_int main_entry, variable_string *variables )
{
    n_interpret *final_prog = 0L;
    n_byte	     *local_data;
    n_uint	      end_loop;
    n_uint	      loop = 0;
    n_int	     *local_number;
    n_byte	      buffer[ VARIABLE_WIDTH ];
    n_int	      buffer_size = 0;
    n_byte	      previous = 0;

    /* remove the white space from the input file */

    io_whitespace( input );

    /* perform the initial allocations */

    if ( ( final_prog = memory_new( sizeof( n_interpret ) ) ) == 0L )
    {
        return 0L;
    }

    if ( ( final_prog->binary_code = io_file_new() ) == 0L )
    {
        memory_free( ( void ** )&final_prog );
        return 0L;
    }

    if ( final_prog->binary_code->data == 0L )
    {
        interpret_cleanup( &final_prog );
        return 0L;
    }

    /* allow for the space for the size to be written after everything else has been written/calculated */

    final_prog->binary_code->location = SIZEOF_NUMBER_WRITE;

    final_prog->variable_strings = variables;
    final_prog->special_less    = ( VARIABLE_IF + 1 );
    final_prog->main_entry      = main_entry;

    local_number = final_prog->number_buffer;

    variable_num = main_entry + 1;

    number_num = 1;

    quote_up = 0;

    /* clear everything initially */

    while ( loop < NUMBER_MAX )
    {
        local_number[ loop++ ] = 0;
    }
    loop = 0;
    memory_erase( buffer, VARIABLE_WIDTH );

    local_data = input->data;
    end_loop = input->size;

    /* work through each character in the input file */

    while ( loop < end_loop )
    {
        n_byte	temp = local_data[ loop++ ];
        /* each character has a particular type */
        n_byte	convert = parse_character( temp );
        /* if it is a failure type i.e. not to be used, then fail */
        if ( convert == APESCRIPT_FAILURE )
        {
            interpret_cleanup( &final_prog );
            ( void )APESCRIPT_ERROR( 0L, AE_UNKNOWN_SYNTAX_PARSER_CONVERT );
            return 0L;
        }
        /* if there is a change in type, then parse the previous buffer */
        if ( ( previous != convert ) && ( previous != 0 ) )
        {
            if ( parse_buffer( final_prog, previous, buffer ) == -1 )
            {
                interpret_cleanup( &final_prog );
                return 0L;
            }

            /* clear the buffer for new characters coming in */
            buffer_size = 0;
            memory_erase( buffer, VARIABLE_WIDTH );
        }

        /* add the character to the buffer */
        buffer[buffer_size++] = temp;

        /* if the buffer gets to big, it's a problem */
        if ( buffer_size == ( VARIABLE_WIDTH -  1 ) )
        {
            interpret_cleanup( &final_prog );
            ( void )APESCRIPT_ERROR( 0L, AE_MAXIMUM_SCRIPT_SIZE_REACHED );
            return 0L;
        }

        /* track the previous type */
        previous = convert;
    }
    /* handle the last type case at the end of the input file */
    if ( parse_buffer( final_prog, previous, buffer ) == -1 )
    {
        interpret_cleanup( &final_prog );
        return 0L;
    }
    {
        n_byte	local_numbers[SIZEOF_NUMBER_WRITE];
        n_uint   loop_sizeof_number;
        /* this is the one special case for direct writing as the original stamp size was allowed */
        io_int_to_bytes( final_prog->binary_code->location, final_prog->binary_code->data ); /* write the basic size header */
        end_loop = number_num;
        loop = 1;
        io_int_to_bytes( number_num, local_numbers ); /* write the number of numbers */
        loop_sizeof_number = 0;
        while ( loop_sizeof_number < SIZEOF_NUMBER_WRITE )
        {
            if ( io_file_write( final_prog->binary_code, local_numbers[loop_sizeof_number] ) == -1 )
            {
                interpret_cleanup( &final_prog );
                return 0L;
            }
            loop_sizeof_number++;
        }
        while ( loop < end_loop )
        {
            io_int_to_bytes( ( final_prog->number_buffer[loop] ), local_numbers ); /* write the numbers */
            loop_sizeof_number = 0;
            while ( loop_sizeof_number < SIZEOF_NUMBER_WRITE )
            {
                if ( io_file_write( final_prog->binary_code, local_numbers[loop_sizeof_number] ) == -1 )
                {
                    interpret_cleanup( &final_prog );
                    return 0L;
                }
                loop_sizeof_number++;
            }
            loop++;
        }
    }
#ifdef SCRIPT_DEBUG
    local_var_codes = variables;
#endif
    return final_prog;
}



/* ./sim/audio.c */
/****************************************************************

 audio.c

 =============================================================



 ****************************************************************/

/*! \file   audio.c
 *  \brief  Handles audio output for the ApeSDK Toolkit

 */

#include "toolkit.h"
#include <math.h>
#include <stdio.h>

static n_double frequency[AUDIO_FFT_MAX_BUFFER];
static n_double timedomain[AUDIO_FFT_MAX_BUFFER];
static n_double frequencyi[AUDIO_FFT_MAX_BUFFER];
static n_double timedomaini[AUDIO_FFT_MAX_BUFFER];


void audio_buffer_clear( n_audio *buffer, n_int size )
{
    n_int loop = 0;
    while ( loop < size )
    {
        buffer[loop++] = 0;
    }
}

void audio_buffer_double_clear( n_double *buffer, n_int size )
{
    n_int loop = 0;
    while ( loop < size )
    {
        buffer[loop++] = 0E+00;
    }
}

void audio_buffer_copy_to_audio( n_double *buffer_double, n_audio *buffer_audio, n_int size )
{
    n_int loop = 0;
    while ( loop < size )
    {
        buffer_audio[loop] = ( n_audio )buffer_double[loop];
        loop++;
    }
}

void audio_buffer_copy_to_double( n_audio *buffer_audio, n_double *buffer_double, n_int size )
{
    n_int loop = 0;
    while ( loop < size )
    {
        buffer_double[loop] = ( n_double )buffer_audio[loop] ;
        loop++;
    }
}

void audio_buffer_copy_to_double_double( n_double *buffer_double_to, n_double *buffer_double_from, n_int size )
{
    n_int loop = 0;
    while ( loop < size )
    {
        buffer_double_to[loop] = buffer_double_from[loop];
        loop++;
    }
}


/**
 * Creates a bit reversed value of a particular index value.
 * @param index value to be bit reversed.
 * @param power_sample the size in bits of the value to be reversed.
 * @return reversed bit value.
 */
static n_uint	audio_reverse_bits ( n_uint index, n_uint power_sample )
{
    n_uint i = 0;
    n_uint rev = 0;
    while ( i < power_sample )
    {
        rev = ( rev << 1 ) | ( index & 1 );
        index >>= 1;
        i++;
    }
    return rev;
}

/*
 * Complex Fast Fourier Transform
 */

void audio_new_fft(
    n_uint     NumBits,
    n_int      InverseTransform,
    n_double    *RealIn,
    n_double    *ImagIn,
    n_double    *RealOut,
    n_double    *ImagOut )
{
    n_uint NumSamples = 1 << NumBits;
    n_uint i, j;
    n_uint k, n;
    n_uint BlockSize, BlockEnd;

    n_double angle_numerator = TWO_PI;
    n_double tr, ti;     /* temp real, temp imaginary */

    if ( InverseTransform )
    {
        angle_numerator = -angle_numerator;
    }

    /*
     **   Do simultaneous data copy and bit-reversal ordering into outputs...
     */

    for ( i = 0; i < NumSamples; i++ )
    {
        j = audio_reverse_bits ( i, NumBits );
        RealOut[j] = RealIn[i];
        ImagOut[j] = ImagIn[i];
    }

    /*
     **   Do the FFT itself...
     */

    BlockEnd = 1;
    for ( BlockSize = 2; BlockSize <= NumSamples; BlockSize <<= 1 )
    {

        n_double delta_angle = angle_numerator / ( double )BlockSize;

        n_double sm2 = sin ( -2 * delta_angle );
        n_double sm1 = sin ( -delta_angle );
        n_double cm2 = cos ( -2 * delta_angle );
        n_double cm1 = cos ( -delta_angle );
        n_double w = 2 * cm1;
        n_double ar0, ar1, ar2, ai0, ai1, ai2;

        for ( i = 0; i < NumSamples; i += BlockSize )
        {
            ar2 = cm2;
            ar1 = cm1;

            ai2 = sm2;
            ai1 = sm1;

            for ( j = i, n = 0; n < BlockEnd; j++, n++ )
            {
                ar0 = w * ar1 - ar2;
                ar2 = ar1;
                ar1 = ar0;

                ai0 = w * ai1 - ai2;
                ai2 = ai1;
                ai1 = ai0;

                k = j + BlockEnd;
                tr = ar0 * RealOut[k] - ai0 * ImagOut[k];
                ti = ar0 * ImagOut[k] + ai0 * RealOut[k];

                RealOut[k] = RealOut[j] - tr;
                ImagOut[k] = ImagOut[j] - ti;

                RealOut[j] += tr;
                ImagOut[j] += ti;
            }
        }
        BlockEnd = BlockSize;
    }

    /*
     **   Need to normalize if inverse transform...
     */

    if ( InverseTransform )
    {
        float denom = ( float )NumSamples;
        for ( i = 0; i < NumSamples; i++ )
        {
            RealOut[i] /= denom;
            ImagOut[i] /= denom;
        }
    }
}

/**
 * Perform a fast fourier transform.
 * @param inverse if this is an inverse FFT.
 * @param power_sample the number of bits of the FFT cell size.
 */
void audio_fft( n_byte inverse, n_uint power_sample )
{
    n_uint		NumSamples = 1 << power_sample;    /* Number of bits needed to store indices */
    n_uint		i;
    n_uint		BlockSize, BlockEnd;

    n_double   *d_in, *d_ini, *d_out, *d_outi;

    n_double angle_numerator = TWO_PI;

    if ( inverse )
    {
        angle_numerator = -angle_numerator;

        d_in  = frequency;
        d_ini = frequencyi;

        d_out  = timedomain;
        d_outi = timedomaini;
    }
    else
    {
        d_in  = timedomain;
        d_ini = timedomaini;

        d_out  = frequency;
        d_outi = frequencyi;
    }

    /*
     **   Do simultaneous data copy and bit-reversal ordering into outputs...
     */

    i = 0;
    while ( i < NumSamples )
    {
        n_uint j = audio_reverse_bits ( i, power_sample );
        d_outi[j] = d_in[i];
        d_out[j]  = d_ini[i];
        i++;
    }

    /*
     **   Do the FFT itself...
     */

    BlockEnd = 1;
    BlockSize = 2;
    while ( BlockSize <= NumSamples )
    {
        n_double delta_angle = angle_numerator / ( n_double )BlockSize;
        n_double sm2 = sin ( ( n_double ) - 2.0f * delta_angle );
        n_double sm1 = sin ( ( n_double ) - delta_angle );
        n_double cm2 = cos ( ( n_double ) - 2.0f * delta_angle );
        n_double cm1 = cos ( ( n_double ) - delta_angle );
        n_double w = 2 * cm1;

        i = 0;

        while (  i < NumSamples )
        {
            n_uint j = i;
            n_uint n = 0;

            n_double ar2 = cm2;
            n_double ar1 = cm1;

            n_double ai2 = sm2;
            n_double ai1 = sm1;

            while ( n < BlockEnd )
            {
                n_double ar0 = w * ar1 - ar2;
                n_double ai0 = w * ai1 - ai2;

                ar2 = ar1;
                ar1 = ar0;

                ai2 = ai1;
                ai1 = ai0;

                {
                    n_uint   k = j + BlockEnd;

                    n_double tr = ar0 * d_outi[k] - ai0 * d_out[k];
                    n_double ti = ar0 * d_out[k] + ai0 * d_outi[k];

                    d_outi[k] = d_outi[j] - tr;
                    d_out[k] = d_out[j] - ti;

                    d_outi[j] += tr;
                    d_out[j] += ti;
                }
                j++;
                n++;
            }
            i += BlockSize;
        }

        BlockEnd = BlockSize;
        BlockSize <<= 1;
    }
    /*
     **   Need to normalize if inverse transform...
     */
    if ( inverse )
    {
        n_double denom = ( n_double ) NumSamples;
        i = 0;
        while  ( i < NumSamples )
        {
            d_outi[i] /= denom;
            d_out[i] /= denom;
            i++;
        }
    }
}

/**
 * Clears all the buffers associated with the FFT.
 * @param length the length of the buffer to be cleared.
 */
void audio_clear_buffers( n_uint length )
{
    n_uint     loop = 0;
    while ( loop < length )
    {
        frequency[loop] = 0;
        timedomain[loop] = 0;
        frequencyi[loop] = 0;
        timedomaini[loop] = 0;
        loop++;
    }
}

/**
 * Clears an audio output buffer
 * @param audio the audio buffer to be cleared.
 * @param length the length of the buffer to be cleared.
 */
void audio_clear_output( n_audio *audio, n_uint length )
{
    n_uint     loop = 0;
    while ( loop < length )
    {
        audio[loop] = 0;
        loop++;
    }
}

/**
* Sets an audio ouput buffer to the FFT time-domain buffer.
* @param audio the audio buffer to be set.
* @param length the length of the buffer to be set.
*/
void audio_equal_output( n_audio *audio, n_uint length )
{
    n_uint     loop = 0;
    while ( loop < length )
    {
        audio[loop] = ( n_audio )timedomain[loop];
        loop++;
    }
}

/**
 * Sets an audio ouput buffer to the FFT time-domain buffer.
 * @param audio the audio buffer to be set.
 * @param length the length of the buffer to be set.
 */
static void audio_equal_input( n_audio *audio, n_uint length )
{
    n_uint     loop = 0;
    while ( loop < length )
    {
        timedomain[loop] = ( n_double )audio[loop];
        loop++;
    }
}

/**
 * Multiplies an audio ouput buffer to the FFT time-domain buffer.
 * @param audio the audio buffer to be multiplied.
 * @param length the length of the buffer to be multiplied.
 */
void audio_multiply_output( n_audio *audio, n_uint length )
{
    n_uint     loop = 0;
    while ( loop < length )
    {
        audio[loop] *= timedomain[loop];
        loop++;
    }
}

/**
 * Sets frequency values in the frequency FFT buffer.
 * @param entry the frequency entry point.
 * @param value the specific value to set in the frequency entry.
 */
void audio_set_frequency( n_uint entry, n_uint value )
{
    frequency[entry] = value / 1E+00;
    frequencyi[entry] = 0E+00;
}


void audio_low_frequency( n_audio *buffer, n_int number_freq, n_int debug )
{
    audio_equal_input( buffer, AUDIO_FFT_MAX_BUFFER );
    audio_fft( 0, 15 );

    audio_fft( 1, 15 );
    audio_equal_output( buffer, AUDIO_FFT_MAX_BUFFER );
}

static void audio_aiff_uint( n_byte *buffer, n_uint value )
{
    buffer[0] = ( value & 0xff000000 ) >> 24;
    buffer[1] = ( value & 0x00ff0000 ) >> 16;
    buffer[2] = ( value & 0x0000ff00 ) >> 8;
    buffer[3] = ( value & 0x000000ff ) >> 0;
}

static n_uint audio_aiff_byte( n_byte *buffer )
{
    n_uint value = buffer[3];
    value |= ( n_uint )( buffer[2] << 8 );
    value |= ( n_uint )( buffer[1] << 16 );
    value |= ( n_uint )( buffer[0] << 24 );
    return value;
}

void audio_aiff_body( void *fptr, n_audio *samples, n_uint number_samples )
{
    fwrite( samples, number_samples, sizeof( n_audio ), ( FILE * )fptr );
}

static void audio_header( n_byte *header )
{
    header[0] =  'F';
    header[1] =  'O';
    header[2] =  'R';
    header[3] =  'M';

    header[8]  = 'A';
    header[9]  = 'I';
    header[10] = 'F';
    header[11] = 'F';

    header[12] = 'C';
    header[13] = 'O';
    header[14] = 'M';
    header[15] = 'M';

    header[19] = 18;

    header[21] = 1;

    header[27] = 16;

    header[28] = 0x40;
    header[29] = 0x0e;
    header[30] = 0xac;
    header[31] = 0x44;

    header[38] = 'S';
    header[39] = 'S';
    header[40] = 'N';
    header[41] = 'D';
}

static n_uint audio_total_size( n_uint total_samples )
{
    return ( sizeof( n_audio ) * total_samples ) + 46;
}

static n_uint audio_sound_size( n_uint total_samples )
{
    return ( sizeof( n_audio ) * total_samples ) + 8;
}

void audio_aiff_header( void *fptr, n_uint total_samples )
{
    n_byte header[54] = {0};
    audio_header( header );
    audio_aiff_uint( &header[4],  audio_total_size( total_samples ) );
    audio_aiff_uint( &header[22], total_samples );
    audio_aiff_uint( &header[42], audio_sound_size( total_samples ) );
    fwrite( header, 54, 1, ( FILE * )fptr );
}

static n_int audio_aiff_comparison( n_byte *compare1, n_byte *compare2, n_int start, n_int end )
{
    n_int loop_section = start;

    while ( loop_section < end )
    {
        if ( compare1[loop_section] != compare2[loop_section] )
        {
            printf( "failed at point %ld\n", loop_section );
            return loop_section;
        }
        loop_section++;
    }
    return -1;
}

n_int audio_aiff_is_header( void *fptr, n_uint *samples )
{
    n_byte read_header[54] = {0};
    n_byte compare_header[54] = {0};

    audio_header( compare_header );

    fread( read_header, 54, 1, ( FILE * )fptr );

    if ( audio_aiff_comparison( read_header, compare_header, 0, 4 ) != -1 )
    {
        return 0;
    }
    if ( audio_aiff_comparison( read_header, compare_header, 8, 22 ) != -1 )
    {
        return 0;
    }
    if ( audio_aiff_comparison( read_header, compare_header, 26, 42 ) != -1 )
    {
        return 0;
    }
    if ( audio_aiff_comparison( read_header, compare_header, 46, 54 ) != -1 )
    {
        return 0;
    }

    *samples = audio_aiff_byte( &read_header[22] );

    return 1;
}


/* ./sim/console.c */
/****************************************************************

 console.c

 =============================================================



 ****************************************************************/

/*! \file   n_console.c
 *  \brief  Covers the low level input and output relating to console.
 */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "toolkit.h"

simulated_console_command *local_commands = 0L;

static n_int command_line_execution;
static n_int command_line_external_exit = 0;

void  io_command_line_execution_set( void )
{
    command_line_execution = 1;
}

n_int io_command_line_execution( void )
{
    return command_line_execution;
}

void io_entry_execution( n_int argc, n_string *argv )
{
    if ( argv )
    {
        if ( ( argc == 2 ) && ( argv[1][1] == 'c' ) )
        {
            io_command_line_execution_set();
        }
    }
}


void io_help_line( simulated_console_command *specific, n_console_output output_function )
{
    n_string_block  string_line = {0};
    io_three_string_combination( string_line, specific->command, specific->addition, specific->help_information, 28 );
    output_function( string_line );
}

n_int io_help( void *ptr, n_string response, n_console_output output_function )
{
    n_int loop = 0;
    n_int response_len = 0;
    n_int found = 0;

    if ( response != 0L )
    {
        response_len = io_length( response, 1024 );
    }

    if ( response_len == 0 )
    {
        output_function( "Commands:" );
    }

    do
    {
        if ( local_commands[loop].function != 0L )
        {
            if ( ( local_commands[loop].help_information ) && ( local_commands[loop].help_information[0] != 0 ) )
            {
                if ( response_len == 0 )
                {
                    io_help_line( &local_commands[loop], output_function );
                }
                else
                {
                    n_int command_len = io_length( local_commands[loop].command, 1024 );
                    n_int count = io_find( response, 0, response_len, local_commands[loop].command, command_len );
                    if ( count == command_len )
                    {
                        io_help_line( &local_commands[loop], output_function );
                        found = 1;
                    }
                }
            }
            loop++;
        }
    }
    while ( local_commands[loop].function != 0L );
    if ( ( response_len != 0 ) && ( found == 0 ) )
    {
        ( void )SHOW_ERROR( "Command not found, type help for more information" );
    }
    return 0;
}

n_int io_quit( void *ptr, n_string response, n_console_output output_function )
{
    return 1;
}

n_string io_console_entry_clean( n_string string, n_int length )
{
    return fgets( string, ( int )length, stdin );
}

n_string io_console_entry( n_string string, n_int length )
{
    return io_console_entry_clean( string, length );
}

void io_console_out( n_constant_string value )
{
    printf( "%s\n", value );
    fflush( stdout );
}

void io_console_quit( void )
{
    command_line_external_exit = 1;
}

n_int io_console( void *ptr, simulated_console_command *commands, n_console_input input_function, n_console_output output_function )
{
    n_string_block buffer;

    local_commands = commands;

    if ( ( input_function )( buffer, STRING_BLOCK_SIZE ) != 0L )
    {
        n_int  loop = 0;
        n_int buffer_len = io_length( buffer, STRING_BLOCK_SIZE );

        if ( ( commands[0].command == 0L ) && ( commands[0].function == 0L ) )
        {
            return SHOW_ERROR( "No commands provided" );
        }

        /* captures linux, mac and windows line ending issue */
        if ( IS_RETURN( buffer[buffer_len - 1] ) )
        {
            buffer[buffer_len - 1] = 0;
            buffer_len--;
        }
        if ( IS_RETURN( buffer[buffer_len - 1] ) )
        {
            buffer[buffer_len - 1] = 0;
            buffer_len--;
        }

        if ( buffer_len != 0 )
        {
            do
            {
                n_int command_len = io_length( commands[loop].command, 1024 );
                n_int count = io_find( ( n_string )buffer, 0, buffer_len, commands[loop].command, command_len );
                if ( count != -1 )
                {
                    n_int return_value;
                    n_console *function = commands[loop].function;
                    if ( IS_SPACE( buffer[count] ) )
                    {
                        return_value = ( *function )( ptr, ( n_string )&buffer[count + 1], output_function );
                        if ( command_line_external_exit )
                        {
                            return 1;
                        }
                        return return_value;
                    }
                    else if ( buffer[count] == 0 )
                    {
                        return_value = ( *function )( ptr, 0L, output_function );
                        if ( command_line_external_exit )
                        {
                            return 1;
                        }
                        return return_value;
                    }
                }
                loop++;
            }
            while ( ( commands[loop].command != 0L ) && ( commands[loop].function != 0L ) );

            ( void )SHOW_ERROR( "Command not found, type help for more information" );

            return 0;
        }
        else
        {
            return 0;
        }
    }
    return SHOW_ERROR( "Console failure" );
}

#if 0

#include <stdio.h>
#include <sys/termios.h>
#include <unistd.h>

int mygetch(void) {
    char ch;
    int error;
    static struct termios Otty, Ntty;

    fflush(stdout);
    tcgetattr(0, &Otty);
    Ntty = Otty;

    Ntty.c_iflag  =  0;     /* input mode       */
    Ntty.c_oflag  =  0;     /* output mode      */
    Ntty.c_lflag &= ~ICANON;    /* line settings    */

#if 1
    /* disable echoing the char as it is typed */
    Ntty.c_lflag &= ~ECHO;  /* disable echo     */
#else
    /* enable echoing the char as it is typed */
    Ntty.c_lflag |=  ECHO;  /* enable echo      */
#endif

    Ntty.c_cc[VMIN]  = CMIN;    /* minimum chars to wait for */
    Ntty.c_cc[VTIME] = CTIME;   /* minimum wait time    */

#if 1
    /*
    * use this to flush the input buffer before blocking for new input
    */
    #define FLAG TCSAFLUSH
#else
    /*
    * use this to return a char from the current input buffer, or block if
    * no input is waiting.
    */
    #define FLAG TCSANOW

#endif

    if ((error = tcsetattr(0, FLAG, &Ntty)) == 0) {
        error  = read(0, &ch, 1 );        /* get char from stdin */
        error += tcsetattr(0, FLAG, &Otty);   /* restore old settings */
    }

    return (error == 1 ? (int) ch : -1 );
}

#endif



/* ./sim/land.c */
/****************************************************************

 land.c

 =============================================================



 ****************************************************************/

#include "toolkit.h"

#include "sim.h"

/*

 Resources

 Wood
 Meat - Fish
 Meat - Animals
 Gold
 Silver
 Tin
 Lead
 Copper
 Stone
 Limestone

 Landscape Changes

 Path
 Road
 Hut
 Smelter/Blacksmith
 Boat Building
 Boat

 Posessions

 ?
 */

static n_land      m_land;

n_byte *land_topography_highdef( void )
{
    return m_land.topography_highdef;
}

n_byte4 land_date( void )
{
    return m_land.date;
}

n_byte4 land_time( void )
{
    return m_land.time;
}

n_byte land_tide_level( void )
{
    return m_land.tide_level;
}


n_byte4 *land_highres_tide( void )
{
    return ( n_byte4 * )m_land.highres_tide;
}

void land_cycle( void )
{
    m_land.time++;
    if ( m_land.time == TIME_DAY_MINUTES )
    {
        m_land.time = 0;
        m_land.date++;
    }

    land_tide();
}

/* all this hardcoding will need to be de-hardcoded in the future */
static void math_bilinear_8_times( n_byte *side512, n_byte *data, n_byte double_spread )
{
    n_int loop_y = 0;

    NA_ASSERT( side512, "side512 NULL" );
    NA_ASSERT( data, "data NULL" );

    if ( side512 == 0L )
    {
        return;
    }
    if ( data == 0L )
    {
        return;
    }

    while ( loop_y < HI_RES_MAP_DIMENSION )
    {
        n_int loop_x = 0;
        while ( loop_x < HI_RES_MAP_DIMENSION )
        {
            /* find the micro x (on the map used for bilinear interpolation) */
            n_int mic_x = ( loop_x & 7 );
            /* find the micro y (on the map used for bilinear interpolation) */
            n_int mic_y = ( loop_y & 7 );

            n_int mac_x = ( loop_x >> 3 );
            n_int mac_y = ( loop_y >> 3 );

            n_uint px0 = ( n_uint )( mac_x );
            n_uint py0 = ( n_uint )( mac_y * MAP_DIMENSION );

            n_uint px1 = ( mac_x + 1 ) & ( MAP_DIMENSION - 1 );
            n_uint py1 = ( ( mac_y + 1 ) & ( MAP_DIMENSION - 1 ) ) * MAP_DIMENSION;

            n_int z00 = side512[px0 | py0];

            n_int z01 = side512[px1 | py0];
            n_int z10 = side512[px0 | py1] - z00;
            n_int z11 = side512[px1 | py1] - z01 - z10;
            n_uint point = ( n_uint )( loop_x + ( loop_y * HI_RES_MAP_DIMENSION ) );
            n_byte value;

            z01 = ( z01 - z00 ) << 3;
            z10 = z10 << 3;

            value = ( n_byte )( ( z00 + ( ( ( z01 * mic_x ) + ( z10 * mic_y ) + ( z11 * mic_x * mic_y ) ) >> 6 ) ) );
            if ( double_spread )
            {
                data[( point << 1 ) | 1] = data[point << 1] = value;
            }
            else
            {
                data[point] = value;
            }
            loop_x++;
        }
        loop_y++;
    }
}

#define    OPERATOR_AREA(fg, dfg, fdg)                 ((((dfg) * (dfg)) + ((fdg) * (fdg))) >> 6)
#define    OPERATOR_HEIGHT(fg, dfg, fdg)               (((WATER_MAP + fg) * (WATER_MAP + fg)) >> 8 )
#define    OPERATOR_WATER(fg, dfg, fdg)                (((WATER_MAP - fg) * (WATER_MAP - fg)) >> 8 )
#define    OPERATOR_SUN(fg, dfg, fdg, ct, st)          (((((ct) * (fg)) + ((st) * (dfg))) >> 4) + WATER_MAP)
#define    OPERATOR_SALT(fg, dfg, fdg, fs)             (((fs*fs)+(dfg*fdg))>>4)

#define    WATER_MAP2                                  (WATER_MAP * 2)

static n_int land_operator( n_int locx, n_int locy, n_byte *specific_kind )
{
    n_int    temp = 0, temp_add;
    n_int    number_sum = 0;

    n_int    fg;
    n_int    dfg;
    n_int    fdg;

    NA_ASSERT( specific_kind, "specific_kind NULL" );

    fg  = land_location( locx, locy );
    dfg = land_location( locx + 1, locy );
    fdg = land_location( locx, locy + 1 );

    dfg = ( dfg - fg ) * 8;
    fdg = ( fdg - fg ) * 8;

    fg = fg - WATER_MAP;

    if ( specific_kind[0] != '.' )
    {
        number_sum ++;
        temp_add = OPERATOR_AREA( fg, dfg, fdg ); /* A */
        if ( specific_kind[0] == '+' )
        {
            temp += temp_add;
        }
        else
        {
            temp += WATER_MAP2 - temp_add;
        }
    }
    if ( specific_kind[1] != '.' )
    {
        number_sum ++;
        temp_add = OPERATOR_HEIGHT( fg, dfg, fdg ); /* H */
        if ( specific_kind[1] == '+' )
        {
            temp += temp_add;
        }
        else
        {
            temp += WATER_MAP2 - temp_add;
        }
    }
    if ( specific_kind[2] != '.' )
    {
        number_sum ++;
        temp_add = OPERATOR_WATER( fg, dfg, fdg ); /* W */
        if ( specific_kind[2] == '+' )
        {
            temp += temp_add;
        }
        else
        {
            temp += WATER_MAP2 - temp_add;
        }
    }
    if ( specific_kind[3] != '.' )
    {
        if ( IS_NIGHT( m_land.time ) == 0 )
        {
            /* 180 is minutes in the day / 8 */
            n_int hr = ( ( ( ( m_land.time << 6 ) / 180 ) + 32 ) & 255 );

            n_int weather = weather_seven_values( MAPSPACE_TO_APESPACE( locx ), MAPSPACE_TO_APESPACE( locy ) );

            n_int   weather_divide = ( 105 + ( ( weather % 3 ) * 30 ) );
            n_vect2 time_weather;

            vect2_direction( &time_weather, hr, weather_divide * 32 );
            vect2_offset( &time_weather, 840 / weather_divide, 840 / weather_divide );

            number_sum ++;
            temp_add = OPERATOR_SUN( fg, dfg, fdg, time_weather.x, time_weather.y ); /* O */
            if ( specific_kind[3] == '+' )
            {
                temp += temp_add;
            }
            else
            {
                temp += WATER_MAP2 - temp_add;
            }
        }
    }
    if ( specific_kind[4] != '.' )
    {
        number_sum ++;
        temp_add = OPERATOR_SUN( fg, dfg, fdg, 11, 11 ); /* U */
        if ( specific_kind[4] == '+' )
        {
            temp += temp_add;
        }
        else
        {
            temp += WATER_MAP2 - temp_add;
        }
    }
    if ( specific_kind[5] != '.' )
    {
        n_int fs = -( fg - TIDE_AMPLITUDE_LUNAR - TIDE_AMPLITUDE_SOLAR );
        if ( ( fs < 0 ) || ( fs > ( TIDE_AMPLITUDE_LUNAR + TIDE_AMPLITUDE_SOLAR ) * 2 ) )
        {
            if ( specific_kind[5] == '+' )
            {
                temp = 0;
            }
        }
        else
        {
            number_sum ++;
            if ( specific_kind[5] == '+' )
            {
                temp += OPERATOR_SALT( fg, dfg, fdg, fs );    /* S */
            }
        }
    }
    NA_ASSERT( number_sum, "number_sum is ZERO" );
    if ( number_sum != 0 )
    {
        temp = temp / number_sum;
    }
    return ( temp );
}

n_int land_operator_interpolated( n_int locx, n_int locy, n_byte *kind )
{
    n_int map_dimension = land_map_dimension();
    n_int map_x = APESPACE_TO_MAPSPACE( locx );
    n_int map_y = APESPACE_TO_MAPSPACE( locy );
    n_int interpolated;
    NA_ASSERT( kind, "kind NULL" );

    /*  Not bilinear interpolation but linear interpolation. Probably should replace with bilinear (ie each value has x and y dependency) */
    interpolated  = ( land_operator( ( map_x + 1 ) & ( map_dimension - 1 ), map_y, kind ) * ( locx - ( map_x << APE_TO_MAP_BIT_RATIO ) ) ) >> APE_TO_MAP_BIT_RATIO;
    interpolated += ( land_operator( ( map_x - 1 ) & ( map_dimension - 1 ), map_y, kind ) * ( ( ( map_x + 1 ) << APE_TO_MAP_BIT_RATIO ) - locx ) ) >> APE_TO_MAP_BIT_RATIO;
    interpolated += ( land_operator( map_x, ( map_y + 1 ) & ( map_dimension - 1 ), kind ) * ( locy - ( map_y << APE_TO_MAP_BIT_RATIO ) ) ) >> APE_TO_MAP_BIT_RATIO;
    interpolated += ( land_operator( map_x, ( map_y - 1 ) & ( map_dimension - 1 ), kind ) * ( ( ( map_y + 1 ) << APE_TO_MAP_BIT_RATIO ) - locy ) ) >> APE_TO_MAP_BIT_RATIO;

    return interpolated >> 1;
}

n_int land_location_vect( n_vect2 *value )
{
    return land_location( value->x, value->y );
}

weather_values    weather_seven_values( n_int px, n_int py )
{
    n_byte  ret_val;
    n_int   val;
    n_int   map_x = POSITIVE_LAND_COORD( APESPACE_TO_MAPSPACE( px ) );
    n_int   map_y = POSITIVE_LAND_COORD( APESPACE_TO_MAPSPACE( py ) );

    if ( IS_DAWNDUSK( m_land.time ) )
    {
        return WEATHER_SEVEN_DAWN_DUSK;
    }
    if ( IS_NIGHT( m_land.time ) )
    {
        ret_val = WEATHER_SEVEN_CLEAR_NIGHT;
    }
    else
    {
        ret_val = WEATHER_SEVEN_SUNNY_DAY;
    }

    val = weather_pressure( map_x, map_y );

    if ( val == -1 )
    {
        return WEATHER_SEVEN_ERROR; /* Error has already been shown */
    }

    if ( val > WEATHER_RAIN )
    {
        return ret_val + 2;
    }
    if ( val > WEATHER_CLOUD )
    {
        return ret_val + 1;
    }

    return ret_val;
}

n_int land_map_dimension( void )
{
    return MAP_DIMENSION;
}

n_int land_map_bits( void )
{
    return MAP_BITS;
}


n_byte2 *land_genetics( void )
{
    return ( n_byte2 * )m_land.tiles[0].genetics;
}

n_byte *land_topography( void )
{
    return ( n_byte * )m_land.tiles[0].topography;
}

n_c_int *land_weather( n_int tile )
{
    return ( n_c_int * )m_land.tiles[tile].atmosphere;
}

void weather_cycle( void )
{
    tile_cycle( &m_land );
    /*
        tile_cycle(&m_land);
        tile_cycle(&m_land);
     */

    tile_wind( &m_land );
}

void weather_init( void )
{
    tile_weather_init( &m_land );
}

n_int weather_pressure( n_int px, n_int py )
{
    return tiles_atmosphere( &m_land, 0, 0, px, py );
}

/*
 * The weather is maintained in a 18-bit band from bits_neg
 */


void  weather_wind_vector( n_vect2 *pos, n_vect2 *wind )
{
    n_int    local_pressure;
    NA_ASSERT( pos, "pos NULL" );
    NA_ASSERT( wind, "wind NULL" );

    if ( pos == 0L )
    {
        return;
    }
    if ( wind == 0L )
    {
        return;
    }

    local_pressure = weather_pressure( pos->x, pos->y );
    wind->x = local_pressure - weather_pressure( pos->x - WEATHER_TO_MAPSPACE( 1 ), pos->y );
    wind->y = local_pressure - weather_pressure( pos->x, pos->y  - WEATHER_TO_MAPSPACE( 1 ) );
}

n_byte *land_location_tile( n_int tile )
{
    return tiles_topography_map( &m_land, tile, 0 );

}

n_int land_location( n_int px, n_int py )
{
    return tiles_topography( &m_land, 0, 0, px, py );
}

void land_tide( void )
{
    n_int current_time    = m_land.time + ( m_land.date * TIME_DAY_MINUTES );
    n_int lunar_mins      = current_time % LUNAR_ORBIT_MINS;
    n_int lunar_angle_256 = ( ( ( m_land.time * 255 ) / 720 ) + ( ( lunar_mins * 255 ) / LUNAR_ORBIT_MINS ) );
    n_int solar_mins      =  current_time    % ( TIME_DAY_MINUTES * TIME_YEAR_DAYS );
    n_int solar_angle_256 = ( solar_mins * 255 ) / ( TIME_DAY_MINUTES * TIME_YEAR_DAYS );

    n_int lunar = math_sine( lunar_angle_256, NEW_SD_MULTIPLE / TIDE_AMPLITUDE_LUNAR );
    n_int solar = math_sine( solar_angle_256, NEW_SD_MULTIPLE / TIDE_AMPLITUDE_SOLAR );

    NA_ASSERT( ( ( ( WATER_MAP + lunar + solar ) > -1 ) && ( ( WATER_MAP + lunar + solar ) < 256 ) ), "(WATER_MAP + lunar + solar) outside byte boundaries" );

    m_land.tide_level = ( n_byte )( WATER_MAP + lunar + solar );
}

void land_clear( KIND_OF_USE kind, n_byte4 start )
{
    tile_land_erase( &m_land );
    if ( kind != KIND_LOAD_FILE )
    {
        m_land.time = 5 * TIME_HOUR_MINUTES;
        m_land.date = start;
    }
}

void land_seed_genetics( n_byte2 *local_random )
{
    tile_land_random( &m_land, local_random );
}

void land_init( void )
{
    tile_land_init( &m_land );
}

void land_init_high_def( n_byte double_spread )
{
    n_uint   lp = 0;
    n_byte4  value_setting = 0;

    math_bilinear_8_times( ( n_byte * )m_land.tiles[0].topography[0], m_land.topography_highdef, double_spread );
    memory_erase( ( n_byte * )m_land.highres_tide, sizeof( n_byte4 ) * HI_RES_MAP_AREA / 32 );

    while ( lp < HI_RES_MAP_AREA )
    {
        n_byte val = m_land.topography_highdef[lp << 1];
        if ( ( val > 105 ) && ( val < 151 ) )
        {
            value_setting |= 1 << ( lp & 31 );
        }

        if ( ( lp & 31 ) == 31 )
        {
            m_land.highres_tide[ lp >> 5 ] = value_setting;
            value_setting = 0;
        }
        lp++;

    }
}


void land_vect2( n_vect2 *output, n_int *actual_z, n_vect2 *location )
{
    n_int loc_x;
    n_int loc_y;
    n_int z;

    NA_ASSERT( output, "output NULL" );
    NA_ASSERT( actual_z, "actual_z NULL" );
    NA_ASSERT( location, "location NULL" );

    if ( output == 0L )
    {
        return;
    }
    if ( location == 0L )
    {
        return;
    }

    loc_x = location->x;
    loc_y = location->y;

    z = land_location( APESPACE_TO_MAPSPACE( loc_x ), APESPACE_TO_MAPSPACE( loc_y ) );

    if ( actual_z != 0L )
    {
        *actual_z = z;
    }
    output->x = ( z - land_location( ( APESPACE_TO_MAPSPACE( loc_x ) + 1 ), APESPACE_TO_MAPSPACE( loc_y ) ) );
    output->y = ( z - land_location( APESPACE_TO_MAPSPACE( loc_x ), ( APESPACE_TO_MAPSPACE( loc_y ) + 1 ) ) );
}




/* ./sim/spacetime.c */
/****************************************************************

 spacetime.c

 =============================================================



 ****************************************************************/

#include "toolkit.h"

#include "sim.h"

void spacetime_to_string( n_string value )
{
    n_int minutes = land_time();
    n_int days = land_date();
    n_int military_time = ( minutes % 60 );
    n_int hours = ( minutes / 60 );
    n_int days_month = ( days % 28 ) + 1;
    n_int month = ( ( days / 28 ) % 13 ) + 1;
    n_int years = days / ( 28 * 13 );

    military_time += hours * 100;

    value[0] = '0' + ( military_time / 1000 ) % 10;
    value[1] = '0' + ( military_time / 100 ) % 10;
    value[2] = ':';
    value[3] = '0' + ( military_time / 10 ) % 10;
    value[4] = '0' + ( military_time / 1 ) % 10;
    value[5] = ' ';
    value[6] = '0' + ( days_month / 10 ) % 10;
    value[7] = '0' + ( days_month / 1 ) % 10;
    value[8] = '/';
    value[9] = '0' + ( month / 10 ) % 10;
    value[10] = '0' + ( month / 1 ) % 10;
    value[11] = '/';
    io_number_to_string( &value[12], ( n_uint )years );
}


n_int spacetime_after( n_spacetime *initial, n_spacetime *second )
{
    if ( initial->date < second->date )
    {
        return 0;
    }
    if ( initial->date > second->date )
    {
        return 1;
    }
    if ( initial->time > second->time )
    {
        return 1;
    }
    return 0;
}

n_int spacetime_before_now( n_spacetime *initial )
{
    if ( initial->date > land_date() )
    {
        return 0;
    }
    if ( initial->date < land_date() )
    {
        return 1;
    }
    if ( initial->time < land_time() )
    {
        return 1;
    }
    return 0;
}

void spacetime_copy( n_spacetime *to, n_spacetime *from )
{
    to->location[0] = from->location[0];
    to->location[1] = from->location[1];

    to->date = from->date;
    to->time = from->time;
}

void spacetime_set( n_spacetime *set, n_byte2 *location )
{
    set->location[0] = location[0];
    set->location[1] = location[1];
    set->time        = land_time();
    set->date        = land_date();
}

void spacetime_convert_to_map( n_vect2 *value )
{
    value->x = APESPACE_TO_MAPSPACE( value->x );
    value->y = APESPACE_TO_MAPSPACE( value->y );
}



/* ./sim/territory.c */
/****************************************************************

 territory.c

 =============================================================



 ****************************************************************/

#include "toolkit.h"

#include "sim.h"

typedef enum
{
    NAME_UNKNOWN,

    NAME_ATOLL,
    NAME_BASIN,
    NAME_BAY,
    NAME_BEACH,
    NAME_CLIFF,
    NAME_FLATLAND,
    NAME_HEADLAND,
    NAME_HILL,
    NAME_LAGOON,
    NAME_LAKE,
    NAME_MOUNTAIN,
    NAME_PENINSULA,
    NAME_POND,
    NAME_RIDGE,
    NAME_RIVER,
    NAME_SPRING,
    NAME_STREAM,
    NAME_SUMMIT,
    NAME_TRENCH,
    NAME_VALLEY,
    NAME_TOTAL
} territory_name;

#if 0

static n_string territory_description( territory_name value )
{
    n_string territory_names[NAME_TOTAL] =
    {
        " ",
        "Atoll",
        "Basin",
        "Bay",
        "Beach",
        "Cliff",
        "Flatland",
        "Headland",
        "Hill",
        "Lagoon",
        "Lake",
        "Mountain",
        "Peninsula",
        "Pond",
        "Ridge",
        "River",
        "Spring",
        "Stream",
        "Summit",
        "Trench",
        "Valley"
    };
    return territory_names[value];
}

static void territory_description_init( n_byte *land, territory_name *set_names )
{
    n_int tx = 0;
    while ( tx < TERRITORY_DIMENSION )
    {
        n_int ty = 0;
        while ( ty < TERRITORY_DIMENSION )
        {
            n_byte2 count[16];

            n_int   dx = 0;
            n_int   dy = 0;

            n_byte  highest_value = 0;
            n_byte  loweest_value = 255;

            n_int   center_average = 0;

            n_byte  top_right;
            n_byte  bottom_right;

            n_byte  top_left;
            n_byte  bottom_left;

            n_int mx = 0;
            while ( mx < ( MAP_DIMENSION / TERRITORY_DIMENSION ) )
            {
                n_int my = 0;
                n_int normalx = mx + ( tx * ( MAP_DIMENSION / TERRITORY_DIMENSION ) );
                while ( my < ( MAP_DIMENSION / TERRITORY_DIMENSION ) )
                {
                    n_int normaly = my + ( ty * ( MAP_DIMENSION / TERRITORY_DIMENSION ) );
                    n_byte value = land[normalx + ( normaly * MAP_DIMENSION )];

                    count[value >> 4]++;
                    if ( value > highest_value )
                    {
                        highest_value = value;
                    }
                    if ( value < loweest_value )
                    {
                        loweest_value = value;
                    }

                    if ( mx == 0 )
                    {
                        dx -= ( n_int )value;

                        if ( my == 0 )
                        {
                            top_left = value;
                        }
                        if ( my == ( ( MAP_DIMENSION / TERRITORY_DIMENSION ) - 1 ) )
                        {
                            bottom_left = value;
                        }
                    }
                    if ( my == 0 )
                    {
                        dy -= ( n_int )value;
                    }
                    if ( mx == ( ( MAP_DIMENSION / TERRITORY_DIMENSION ) - 1 ) )
                    {
                        dx += ( n_int )value;

                        if ( my == 0 )
                        {
                            top_right = value;
                        }
                        if ( my == ( ( MAP_DIMENSION / TERRITORY_DIMENSION ) - 1 ) )
                        {
                            bottom_right = value;
                        }
                    }
                    if ( my == ( ( MAP_DIMENSION / TERRITORY_DIMENSION ) - 1 ) )
                    {
                        dy += ( n_int )value;
                    }

                    if ( ( ( mx / 2 ) == ( my / 2 ) ) && ( ( mx / 2 ) == ( ( MAP_DIMENSION / TERRITORY_DIMENSION ) / 2 ) ) )
                    {
                        center_average += ( n_int )value;
                    }

                    my++;
                }
                mx++;
            }
            /* naming logic goes here */
            {
                territory_name return_name = NAME_UNKNOWN;

                *( set_names++ ) = return_name;
            }

            ty++;
        }
        tx++;
    }
}

#endif


/* ./sim/tile.c */
/****************************************************************

 tile.c

 =============================================================



 ****************************************************************/

#include "toolkit.h"

#include "sim.h"

#define tile_wind_aim (-96 + (math_random(land->genetics) % 194))
#define tile_wind_dissipation (math_random(land->genetics) & 3)
#define bits_neg ((-131072 * 254) / 256)
#define bits_pos (( 131071 * 254) / 256)

/*         +---------+
           |    C    |
           |A   0   B|
      A    |         |    B         C
 +---------+---------+---------+---------+
 |         |         |         |         |
 |    1    |    2    |    3    |    4    |
 |         |         |         |         |
 +---------+---------+---------+---------+
      D    |         |    E         F
           |D   5   E|
           |    F    |
           +---------+                       */

static void tile_coordinate_rotate( n_tile_coordinates *coordinates, n_int rotate90, n_int tile )
{
    n_int pos_x = ( coordinates->x + MAP_DIMENSION ) & ( MAP_DIMENSION - 1 );
    n_int pos_y = ( coordinates->y + MAP_DIMENSION ) & ( MAP_DIMENSION - 1 );
    n_uint pos_facing = coordinates->facing;

    if ( rotate90 == 0 )
    {
        coordinates->x = pos_x;
        coordinates->y = pos_y;
    }
    if ( rotate90 == 1 )
    {
        coordinates->facing = ( pos_facing + 64 ) & 255;
        coordinates->x = pos_y;
        coordinates->y = MAP_DIMENSION - 1 - pos_x;
    }
    if ( rotate90 == 2 )
    {
        coordinates->facing = ( pos_facing + 128 ) & 255;
        coordinates->x = MAP_DIMENSION - 1 - pos_x;
        coordinates->y = MAP_DIMENSION - 1 - pos_y;
    }
    if ( rotate90 == 3 )
    {
        coordinates->facing = ( pos_facing + 64 + 128 ) & 255;
        coordinates->x = MAP_DIMENSION - 1 - pos_y;
        coordinates->y = pos_x;
    }
    coordinates->tile = tile;
}

void tile_resolve_coordinates( n_tile_coordinates *coordinates )
{
    n_int pos_x = ( coordinates->x >= MAP_DIMENSION ) - ( coordinates->x < 0 );
    n_int pos_y = ( coordinates->y >= MAP_DIMENSION ) - ( coordinates->y < 0 );

    if ( ( pos_x == 0 ) && ( pos_y == 0 ) )
    {
        return;
    }
    if ( pos_y == 0 )
    {
        if ( ( coordinates->tile > 0 ) && ( coordinates->tile < 5 ) )
        {
            n_int new_x = ( coordinates->x + MAP_DIMENSION ) & ( MAP_DIMENSION - 1 );
            n_int new_tile = coordinates->tile;
            if ( pos_x < 0 )
            {
                if ( new_tile == 1 ) /* moving leftwards */
                {
                    new_tile = 4;
                }
                else
                {
                    new_tile--;
                }
            }
            else
            {
                if ( new_tile == 4 ) /* moving rightwards */
                {
                    new_tile = 1;
                }
                else
                {
                    new_tile++;
                }
            }
            coordinates->tile = new_tile;
            coordinates->x = new_x;
        }
        else
        {
            if ( coordinates->tile == 0 )
            {
                if ( pos_x < 0 )
                {
                    /* A */ tile_coordinate_rotate( coordinates, 3, 1 );
                }
                else
                {
                    /* B */ tile_coordinate_rotate( coordinates, 1, 3 );
                }
            }
            else /* coordinates->tile == 5 */
            {
                if ( pos_x < 0 )
                {
                    /* D */ tile_coordinate_rotate( coordinates, 3, 1 );
                }
                else
                {
                    /* E */ tile_coordinate_rotate( coordinates, 1, 3 );
                }
            }
            /*         +---------+
                       |    C    |
                       |A   0   B|
                  A    |         |    B         C
             +---------+---------+---------+---------+
             |         |         |         |         |
             |    1    |    2    |    3    |    4    |
             |         |         |         |         |
             +---------+---------+---------+---------+
                  D    |         |    E         F
                       |D   5   E|
                       |    F    |
                       +---------+                       */
        }
    }
    else if ( pos_x == 0 )
    {
        if ( ( coordinates->tile == 0 ) || ( coordinates->tile == 2 ) || ( coordinates->tile == 5 ) )
        {
            n_int new_y = ( coordinates->y + MAP_DIMENSION ) & ( MAP_DIMENSION - 1 );
            n_int new_tile = -1;
            if ( pos_y < 0 )
            {
                if ( coordinates->tile == 0 )
                {
                    tile_coordinate_rotate( coordinates, 2, 4 );
                }
                if ( coordinates->tile == 2 )
                {
                    new_tile = 0;
                }
                if ( coordinates->tile == 5 )
                {
                    new_tile = 2;
                }
            }
            else
            {
                if ( coordinates->tile == 0 )
                {
                    new_tile = 2;
                }
                if ( coordinates->tile == 2 )
                {
                    new_tile = 5;
                }
                if ( coordinates->tile == 5 ) /* F */
                {
                    tile_coordinate_rotate( coordinates, 2, 4 );
                }
            }

            if ( new_tile != -1 )
            {
                coordinates->tile = new_tile;
                coordinates->y = new_y;
            }
        }
        else
        {
            /*         +---------+
                       |    C    |
                       |A   0   B|
                  A    |         |    B         C
             +---------+---------+---------+---------+
             |         |         |         |         |
             |    1    |    2    |    3    |    4    |
             |         |         |         |         |
             +---------+---------+---------+---------+
                  D    |         |    E         F
                       |D   5   E|
                       |    F    |
                       +---------+                       */

            if ( pos_y < 0 )
            {
                if ( coordinates->tile == 1 )
                {
                    /* A */ tile_coordinate_rotate( coordinates, 1, 0 );
                }
                if ( coordinates->tile == 3 )
                {
                    /* B */ tile_coordinate_rotate( coordinates, 3, 0 );
                }
                if ( coordinates->tile == 4 )
                {
                    /* C */ tile_coordinate_rotate( coordinates, 2, 0 );
                }
            }
            else
            {
                if ( coordinates->tile == 1 )
                {
                    /* D */ tile_coordinate_rotate( coordinates, 3, 5 );
                }
                if ( coordinates->tile == 3 )
                {
                    /* E */ tile_coordinate_rotate( coordinates, 1, 5 );
                }
                if ( coordinates->tile == 4 )
                {
                    /* F */ tile_coordinate_rotate( coordinates, 2, 5 );
                }
            }

        }
    }
    else
    {
        if ( coordinates->x > ( MAP_DIMENSION - 1 ) )
        {
            coordinates->x = ( MAP_DIMENSION - 1 );
        }
        else if ( coordinates->x < 0 )
        {
            coordinates->x = 0;
        }
        if ( coordinates->y > ( MAP_DIMENSION - 1 ) )
        {
            coordinates->y = ( MAP_DIMENSION - 1 );
        }
        else if ( coordinates->y < 0 )
        {
            coordinates->y = 0;
        }
    }
}


static void tile_wrap( n_land *land, n_int tile )
{
    n_c_int *section = land->tiles[tile].atmosphere[1];
    n_int placement = 0;
    while ( placement < ( MAP_AREA ) )
    {
        n_c_int value = section[placement];
        section[placement++] = ( value * 253 ) / 256;
    }
}

static void tile_wind_calculation( n_land *land )
{
    if ( ( math_random( land->genetics ) & 31 ) == 0 )
    {
        land->wind_aim_x = tile_wind_aim;
        math_random3( land->genetics );
        land->wind_aim_y = tile_wind_aim;

        land->wind_dissipation = tile_wind_dissipation;
    }

    if ( land->wind_aim_x > land->wind_value_x )
    {
        land->wind_value_x++;
    }
    if ( land->wind_aim_x < land->wind_value_x )
    {
        land->wind_value_x--;
    }

    if ( land->wind_aim_y > land->wind_value_y )
    {
        land->wind_value_y++;
    }
    if ( land->wind_aim_y < land->wind_value_y )
    {
        land->wind_value_y--;
    }
}

static void tile_pressure_range( n_tile *tile, n_byte2 value )
{
    if ( value > tile->delta_pressure_highest )
    {
        tile->delta_pressure_highest = value;
    }
    if ( value < tile->delta_pressure_lowest )
    {
        tile->delta_pressure_lowest = value;
    }
}

static void tile_atmosphere_range( n_land *land, n_int tile, n_c_int value )
{
    n_tile *tilePtr = &land->tiles[tile];

    if ( value > tilePtr->atmosphere_highest )
    {
        tilePtr->atmosphere_highest = value;
    }
    if ( value < tilePtr->atmosphere_lowest )
    {
        tilePtr->atmosphere_lowest = value;
    }
}

static n_uint tiles_non_planet( n_int lx, n_int ly )
{
    n_int converted_x = ( lx + MAP_DIMENSION ) & ( MAP_DIMENSION - 1 );
    n_int converted_y = ( ly + MAP_DIMENSION ) & ( MAP_DIMENSION - 1 );
    return ( n_uint )( converted_x | ( converted_y * MAP_DIMENSION ) );
}

n_c_int tiles_atmosphere( n_land *land, n_int tile, n_int buffer, n_int lx, n_int ly )
{
#ifdef SIMULATED_PLANET
    n_tile_coordinates coord;
    coord.facing = 0;
    coord.tile = tile;
    coord.x = lx;
    coord.y = ly;

    tile_resolve_coordinates( &coord );
    return land->tiles[coord.tile].atmosphere[buffer][tiles_non_planet( coord.x, coord.y )];

#else
    return land->tiles[tile].atmosphere[buffer][tiles_non_planet( lx, ly )];
#endif
}

static void tiles_set_atmosphere( n_land *land, n_int tile, n_int buffer, n_int lx, n_int ly, n_c_int value )
{
#ifdef SIMULATED_PLANET
    n_tile_coordinates coord;

    coord.facing = 0;
    coord.tile = tile;
    coord.x = lx;
    coord.y = ly;

    tile_resolve_coordinates( &coord );
    land->tiles[coord.tile].atmosphere[buffer][tiles_non_planet( coord.x, coord.y )] = value;

#else
    land->tiles[tile].atmosphere[buffer][tiles_non_planet( lx, ly )] = value;
#endif
}

static void tiles_swap_atmosphere( n_land *land, n_int tile )
{
    memory_copy( ( n_byte * )land->tiles[tile].atmosphere[1], ( n_byte * )land->tiles[tile].atmosphere[0], ( sizeof( n_c_int ) * MAP_AREA ) );
}

static n_byte2 tiles_pressure( n_land *land, n_int tile, n_int lx, n_int ly )
{
#ifdef SIMULATED_PLANET
    n_tile_coordinates coord;
    coord.facing = 0;
    coord.tile = tile;
    coord.x = lx;
    coord.y = ly;

    tile_resolve_coordinates( &coord );
    return land->tiles[coord.tile].delta_pressure[tiles_non_planet( coord.x, coord.y )];
#else
    return land->tiles[tile].delta_pressure[tiles_non_planet( lx, ly )];
#endif
}

static void tiles_set_pressure( n_land *land, n_int tile, n_int lx, n_int ly, n_byte2 value )
{
#ifdef SIMULATED_PLANET
    n_tile_coordinates coord;

    coord.facing = 0;
    coord.tile = tile;
    coord.x = lx;
    coord.y = ly;

    tile_resolve_coordinates( &coord );
    land->tiles[coord.tile].delta_pressure[tiles_non_planet( coord.x, coord.y )] = value;
#else
    land->tiles[tile].delta_pressure[tiles_non_planet( lx, ly )] = value;
#endif
}

n_byte *tiles_topography_map( n_land *land, n_int tile, n_int buffer )
{
    return ( n_byte * ) land->tiles[tile].topography[buffer];
}

n_byte tiles_topography( n_land *land, n_int tile, n_int buffer, n_int lx, n_int ly )
{
#ifdef SIMULATED_PLANET
    n_tile_coordinates coord;
    coord.facing = 0;
    coord.tile = tile;
    coord.x = lx;
    coord.y = ly;

    tile_resolve_coordinates( &coord );
    return land->tiles[coord.tile].topography[buffer][tiles_non_planet( coord.x, coord.y )];
#else
    return land->tiles[tile].topography[buffer][tiles_non_planet( lx, ly )];
#endif
}

static void tiles_set_topography( n_land *land, n_int tile, n_int buffer, n_int lx, n_int ly, n_byte value )
{
#ifdef SIMULATED_PLANET
    n_tile_coordinates coord;

    coord.facing = 0;
    coord.tile = tile;
    coord.x = lx;
    coord.y = ly;

    tile_resolve_coordinates( &coord );
    land->tiles[coord.tile].topography[buffer][tiles_non_planet( coord.x, coord.y )] = value;
#else
    land->tiles[tile].topography[buffer][tiles_non_planet( lx, ly )] = value;
#endif
}

static void tiles_swap_topography( n_land *land, n_int tile )
{
    memory_copy( ( n_byte * )&land->tiles[tile].topography[0], ( n_byte * )&land->tiles[tile].topography[1], MAP_AREA );
}

static void tile_pack_atmosphere( n_land *land, n_int tile )
{
    n_int loop = 0;
    while ( loop < MAP_AREA )
    {
        land->tiles[tile].atmosphere[0][loop] = 0;
        loop++;
    }
}

static void tile_pack_topography( n_land *land, n_int tile )
{
    n_int loop = 0;
    while ( loop < MAP_AREA )
    {
        land->tiles[tile].topography[0][loop] = 128;
        loop++;
    }
}

static void tile_atmosphere_topography( n_land *land, n_int tile )
{
    n_int loop = 0;

    while ( loop < MAP_AREA )
    {
        land->tiles[tile].atmosphere[0][ loop ] = ( n_c_int )( land->tiles[tile].topography[0][ loop ] * 4 );
        loop++;
    }
}

void tile_cycle( n_land *land )
{
    const n_c_int dissipation = ( n_c_int )( land->wind_dissipation + 1020 );
    n_int  tile = 0;
/*
    n_int  max_atm = 0;
    n_int  max_x = -1, max_y = -1;

    n_int  min_atm = 0;
    n_int  min_x = -1, min_y = -1;
*/
    while ( tile < MAP_TILES )
    {
        n_int  new_delta = 0;
        n_int  ly = 0;

        land->tiles[tile].atmosphere_lowest = bits_pos;
        land->tiles[tile].atmosphere_highest = bits_neg;

        while ( ly < MAP_DIMENSION )
        {
            n_int    lx = 0;
            while ( lx < MAP_DIMENSION )
            {
                n_c_int  value = ( dissipation * tiles_atmosphere( land, tile, 0, lx, ly ) ) >> 10;

                n_int    local_atm =
                    ( 2 * tiles_atmosphere( land, tile, 0, lx, ly - 1 ) )
                    + ( 2 * tiles_atmosphere( land, tile, 0, lx - 1, ly ) )
                    - ( 2 * tiles_atmosphere( land, tile, 0, lx + 1, ly ) )
                    - ( 2 * tiles_atmosphere( land, tile, 0, lx, ly + 1 ) );
#if 0
                if (local_atm > max_atm)
                {
                    max_atm = local_atm;
                    max_x = lx;
                    max_y = ly;
                }
                if (min_atm > local_atm)
                {
                    min_atm = local_atm;
                    min_x = lx;
                    min_y = ly;
                }
#endif
                value += ( n_c_int ) ( ( local_atm - land->tiles[tile].local_delta ) >> MAP_BITS ) + tiles_pressure( land, 0, lx, ly );

                tiles_set_atmosphere( land, tile, 1, lx, ly, value );
                new_delta += value;
                tile_atmosphere_range( land, tile, value );
                lx++;
            }
            ly++;
        }

        land->tiles[tile].local_delta = new_delta >> MAP_BITS;
        tile++;
    }
    tile = 0;
    while ( tile < MAP_TILES )
    {
        tiles_swap_atmosphere( land, tile );
        tile++;
    }
}

static void tile_wind_pp( n_land *land )
{
    n_int  tile = 0;
    /* Add dynamic wind */
    const n_int   p01 = land->wind_value_x, p10 = land->wind_value_y;
    while ( tile < MAP_TILES )
    {
        n_int         ly = 0;
        while ( ly < MAP_DIMENSION )
        {
            n_int    lx = 0;
            while ( lx < MAP_DIMENSION )
            {
                n_int    delta_pressure = tiles_pressure( land, tile, lx, ly );
                n_int    tp01 = ( p01 * delta_pressure ) / land->tiles[tile].delta_pressure_highest;
                n_int    tp10 = ( p10 * delta_pressure ) / land->tiles[tile].delta_pressure_highest;
                n_int    tp00 = 256 - tp01 - tp10;
                n_int    local_atm =
                    ( tp00 * tiles_atmosphere( land, tile, 0, lx, ly ) ) +
                    ( tp10 * tiles_atmosphere( land, tile, 0, lx, ly + 1 ) ) +
                    ( tp01 * tiles_atmosphere( land, tile, 0, lx + 1, ly ) );
                tiles_set_atmosphere( land, tile, 1, lx, ly, ( n_c_int )local_atm >> 8 );
                lx++;
            }
            ly++;
        }
        tile++;
    }
}

static void tile_wind_np( n_land *land )
{
    n_int  tile = 0;
    /* Add dynamic wind */
    const n_int   p01 = land->wind_value_x, p10 = 0 - land->wind_value_y;
    while ( tile < MAP_TILES )
    {
        n_int         ly = 0;
        while ( ly < MAP_DIMENSION )
        {
            n_int    lx = 0;
            while ( lx < MAP_DIMENSION )
            {
                n_int    delta_pressure = tiles_pressure( land, tile, lx, ly );
                n_int    tp01 = ( p01 * delta_pressure ) / land->tiles[tile].delta_pressure_highest;
                n_int    tp10 = ( p10 * delta_pressure ) / land->tiles[tile].delta_pressure_highest;
                n_int    tp00 = 256 - tp01 - tp10;
                n_int    local_atm =
                    ( tp00 * tiles_atmosphere( land, tile, 0, lx, ly ) ) +
                    ( tp10 * tiles_atmosphere( land, tile, 0, lx, ly - 1 ) ) +
                    ( tp01 * tiles_atmosphere( land, tile, 0, lx + 1, ly ) );
                tiles_set_atmosphere( land, tile, 1, lx, ly, ( n_c_int )local_atm >> 8 );
                lx++;
            }
            ly++;
        }
        tile++;
    }
}

static void tile_wind_pn( n_land *land )
{
    n_int  tile = 0;
    /* Add dynamic wind */
    const n_int   p01 = 0 - land->wind_value_x, p10 = land->wind_value_y;
    while ( tile < MAP_TILES )
    {
        n_int         ly = 0;
        while ( ly < MAP_DIMENSION )
        {
            n_int    lx = 0;
            while ( lx < MAP_DIMENSION )
            {
                n_int    delta_pressure = tiles_pressure( land, tile, lx, ly );
                n_int    tp01 = ( p01 * delta_pressure ) / land->tiles[tile].delta_pressure_highest;
                n_int    tp10 = ( p10 * delta_pressure ) / land->tiles[tile].delta_pressure_highest;
                n_int    tp00 = 256 - tp01 - tp10;
                n_int    local_atm =
                    ( tp00 * tiles_atmosphere( land, tile, 0, lx, ly ) ) +
                    ( tp10 * tiles_atmosphere( land, tile, 0, lx, ly + 1 ) ) +
                    ( tp01 * tiles_atmosphere( land, tile, 0, lx - 1, ly ) );
                tiles_set_atmosphere( land, tile, 1, lx, ly, ( n_c_int )local_atm >> 8 );
                lx++;
            }
            ly++;
        }
        tile++;
    }
}

static void tile_wind_nn( n_land *land )
{
    n_int  tile = 0;
    /* Add dynamic wind */
    const n_int   p01 = 0 - land->wind_value_x, p10 = 0 - land->wind_value_y;
    while ( tile < MAP_TILES )
    {
        n_int         ly = 0;
        while ( ly < MAP_DIMENSION )
        {
            n_int    lx = 0;
            while ( lx < MAP_DIMENSION )
            {
                n_int    delta_pressure = tiles_pressure( land, tile, lx, ly );
                n_int    tp01 = ( p01 * delta_pressure ) / land->tiles[tile].delta_pressure_highest;
                n_int    tp10 = ( p10 * delta_pressure ) / land->tiles[tile].delta_pressure_highest;
                n_int    tp00 = 256 - tp01 - tp10;
                n_int    local_atm =
                    ( tp00 * tiles_atmosphere( land, tile, 0, lx, ly ) ) +
                    ( tp10 * tiles_atmosphere( land, tile, 0, lx, ly - 1 ) ) +
                    ( tp01 * tiles_atmosphere( land, tile, 0, lx - 1, ly ) );
                tiles_set_atmosphere( land, tile, 1, lx, ly, ( n_c_int )local_atm >> 8 );
                lx++;
            }
            ly++;
        }
        tile++;
    }
}

void tile_wind( n_land *land )
{
    n_int  tile = 0, p01, p10;
    tile_wind_calculation( land );
    p01 = land->wind_value_x;
    p10 = land->wind_value_y;
    if ( p01 > -1 )
    {
        if ( p10 > -1 )
        {
            tile_wind_pp( land );
        }
        else
        {
            tile_wind_np( land );
        }
    }
    else
    {
        if ( p10 > -1 )
        {
            tile_wind_pn( land );
        }
        else
        {
            tile_wind_nn( land );
        }
    }
    while ( tile < MAP_TILES )
    {
        if ( ( land->tiles[tile].atmosphere_lowest < bits_neg ) || ( land->tiles[tile].atmosphere_highest > bits_pos ) )
        {
            tile_wrap( land, tile );
        }
        tile++;
    }
    tile = 0;
    while ( tile < MAP_TILES )
    {
        tiles_swap_atmosphere( land, tile );
        tile++;
    }
}

void tile_weather_init( n_land *land )
{
    n_int tile = 0;

    land->wind_value_x = tile_wind_aim;
    land->wind_aim_y = tile_wind_aim;
    math_random3( land->genetics );
    land->wind_value_y = tile_wind_aim;
    land->wind_aim_x = tile_wind_aim;

    land->wind_dissipation = tile_wind_dissipation;

    while ( tile < MAP_TILES )
    {
        n_tile *tilePtr = &land->tiles[tile];

        math_random3( tilePtr->genetics );

        tilePtr->local_delta = 0;

        tilePtr->delta_pressure_lowest = 0xffff;
        tilePtr->delta_pressure_highest = 1;


        memory_erase( ( n_byte * )tilePtr->atmosphere, sizeof( n_c_int ) * MAP_AREA );
        memory_erase( ( n_byte * )tilePtr->delta_pressure, sizeof( n_byte2 ) * MAP_AREA );

        tile_atmosphere_topography( land, tile );

        tile++;
    }
    tile = 0;
    while ( tile < MAP_TILES )
    {
        n_int ly = 0;
        while ( ly < MAP_DIMENSION )
        {
            n_int       lx = 0;
            while ( lx < MAP_DIMENSION )
            {
                n_byte2 value
                    = ( n_byte2 )(
                          tiles_atmosphere( land, tile, 0, lx + 1, ly )
                          - tiles_atmosphere( land, tile, 0, lx - 1, ly )
                          + tiles_atmosphere( land, tile, 0, lx, ly + 1 )
                          - tiles_atmosphere( land, tile, 0, lx, ly - 1 )
                          + 512 );
                tiles_set_pressure( land, tile, lx, ly, value );
                tile_pressure_range( &land->tiles[tile], value );
                lx++;
            }
            ly++;
        }
        tile++;
    }
    tile = 0;
#ifndef FAST_START_UNREALISTIC_INITIAL_WEATHER
    while ( tile < MAP_TILES )
#else
    while ( tile < ( MAP_TILES / 2 ) )
#endif
    {
        tile_pack_atmosphere( land, tile );
        tile++;
    }
}


void tile_land_erase( n_land *land )
{
    n_byte2 save_genetics[MAP_TILES][2];
    n_int   tile = 0;
    while ( tile < MAP_TILES )
    {
        save_genetics[tile][0] = land->tiles[tile].genetics[0];
        save_genetics[tile][1] = land->tiles[tile].genetics[1];
        tile++;
    }

    memory_erase( ( n_byte * )land, sizeof( n_land ) );

    tile = 0;
    while ( tile < MAP_TILES )
    {
        land->tiles[tile].genetics[0] = save_genetics[tile][0];
        land->tiles[tile].genetics[1] = save_genetics[tile][1];
        tile_pack_topography( land, tile );
        tile++;
    }
}

static void tile_round( n_land *land, n_int tile )
{
    n_int    local_tile_dimension = 1 << MAP_BITS;
    n_int    span_minor = 0;
    /** Perform four nearest neighbor blur runs */

    while ( span_minor < 6 )
    {
        n_int    py = 0;

        while ( py < local_tile_dimension )
        {
            n_int    px = 0;
            while ( px < local_tile_dimension )
            {
                n_int    sum = 0;
                n_int    ty = -1;
                while ( ty < 2 )
                {
                    n_int    tx = -1;
                    while ( tx < 2 )
                    {
                        sum += tiles_topography( land, tile, ( span_minor & 1 ), px + tx, py + ty );
                        tx++;
                    }
                    ty++;
                }
                tiles_set_topography( land, tile, ( span_minor & 1 ) ^ 1, px, py, ( n_byte )( sum / 9 ) );
                px ++;
            }
            py ++;
        }
        span_minor ++;
    }
}

static void tile_patch( n_land *land, n_int tile, n_int refine )
{
    /** size of the local tiles */
    /** number of 256 x 256 tiles in each dimension */
    const n_int local_tiles = 1 << ( MAP_BITS - 8 );
    const n_int span_minor = ( 64 >> ( ( refine & 7 ) ^ 7 ) );
    const n_int span_major = ( 1 << ( ( refine & 7 ) ^ 7 ) );
    n_int tile_y = 0;

    /** begin the tile traversal in the y dimension */
    while ( tile_y < local_tiles )
    {
        /** begin the tile traversal in the x dimension */
        n_int tile_x = 0;
        while ( tile_x < local_tiles )
        {
            /** scan through the span_minor values */
            n_int    py = 0;
            while ( py < span_minor )
            {
                n_int    px = 0;
                while ( px < span_minor )
                {
                    /** each of the smaller tiles are based on 256 * 256 tiles */
                    n_int    val1 = ( ( px << 2 ) + ( py << 10 ) );
                    n_int    ty = 0;
                    n_int    tseed = math_random( land->tiles[tile].genetics );

                    while ( ty < 4 )
                    {
                        n_int    tx = 0;
                        while ( tx < 4 )
                        {
                            n_int    val2 = ( tseed >> ( tx | ( ty << 2 ) ) );
                            n_int    val3 = ( ( ( ( val2 & 1 ) << 1 ) - 1 ) * 20 );
                            n_int    my = 0;

                            val2 = ( tx | ( ty << 8 ) );

                            while ( my < span_major )
                            {
                                n_int    mx = 0;
                                while ( mx < span_major )
                                {
                                    n_int    point = ( ( mx | ( my << 8 ) ) + ( span_major * ( val1 + val2 ) ) );
                                    n_int    pointx = ( point & 255 );
                                    n_int    pointy = ( point >> 8 );
                                    /** perform rotation on 2,3,6,7,10,11 etc */
                                    if ( refine & 2 )
                                    {
                                        n_int pointx_tmp = pointx + pointy;
                                        pointy = pointx - pointy;
                                        pointx = pointx_tmp;
                                    }
                                    {
                                        /** include the wrap around for the 45 degree rotation cases in particular */
                                        n_int    local_map_point = tiles_topography( land, tile, 0, pointx + ( tile_x << 8 ), pointy + ( tile_y << 8 ) ) + val3;

                                        if ( local_map_point < 0 )
                                        {
                                            local_map_point = 0;
                                        }
                                        if ( local_map_point > 255 )
                                        {
                                            local_map_point = 255;
                                        }

                                        tiles_set_topography( land, tile, 0, pointx + ( tile_x << 8 ), pointy + ( tile_y << 8 ), ( n_byte )local_map_point );
                                    }
                                    mx++;
                                }
                                my++;
                            }
                            tx++;
                        }
                        ty++;
                    }
                    px++;
                }
                py++;
            }
            tile_x++;
        }
        tile_y++;
    }

}

#if 0
static n_int tile_memory_location( n_int px, n_int py )
{
#define    POSITIVE_TILE_COORD(num)      ((num+(3*MAP_DIMENSION))&(MAP_DIMENSION-1))
    return POSITIVE_TILE_COORD( px ) + ( POSITIVE_TILE_COORD( py ) << MAP_BITS );
}
#endif

void tile_land_init( n_land *land )
{
    n_int refine = 0;
    while ( refine < 7 )
    {
        n_int tile = 0;
        while ( tile < MAP_TILES )
        {
            tile_patch( land, tile, refine );
            tile++;
        }
        tile = 0;
        while ( tile < MAP_TILES )
        {
            tile_round( land, tile );
            tile++;
        }
        tile = 0;
        while ( tile < MAP_TILES )
        {
            tiles_swap_topography( land, tile );
            tile++;
        }
        refine++;
    }
}

void tile_land_random( n_land *land, n_byte2 *random )
{
    n_int tile = 0;
    while ( tile < MAP_TILES )
    {
        land->tiles[tile].genetics[0] = ( n_byte2 )( ( ( math_random( random ) & 255 ) << 8 ) | ( math_random( random ) & 255 ) );
        land->tiles[tile].genetics[1] = ( n_byte2 )( ( ( math_random( random ) & 255 ) << 8 ) | ( math_random( random ) & 255 ) );
        math_random3( random );
        tile++;
    }
    land->genetics[0] = ( n_byte2 )( ( ( math_random( random ) & 255 ) << 8 ) | ( math_random( random ) & 255 ) );
    land->genetics[1] = ( n_byte2 )( ( ( math_random( random ) & 255 ) << 8 ) | ( math_random( random ) & 255 ) );
}


/* ./entity/being.c */
/****************************************************************

 being.c

 =============================================================



 ****************************************************************/

/*! \file   being.c
 *  \brief  Historically this represented the Simulated Ape but moreso
    now it represents the Simulated Ape's interface to something external.
    being.c also now connects to the social, brain, body and metabolim
    simulations through to external simulations.
 */

#include "entity.h"
#include "entity_internal.h"

#include <stdio.h>
#include <stdlib.h>

/*#pragma mark - macros*/

/** checks the being's line of sight to a point

    NB: As the direction of scanning can't be determined, the breaking sight point
        can't be detected through tracking the being_ground results.
*/

/** returning 0 - not in line of sight, 1 - in line of sight */

typedef    struct
{
    n_int         start_z;
    n_int         offset_x;
    n_int         offset_y;
    n_int       visibility_delta;
    n_int       visibility_total;
}
being_draw;

/*#pragma mark - can_move*/

static simulated_being_can_move *being_can_move_local = 0L;

n_byte being_can_move( n_vect2 *location, n_vect2 *delta )
{
    if ( being_can_move_local )
    {
        return being_can_move_local( location, delta );
    }
    return 1;
}

void being_can_move_override( simulated_being_can_move *new_can_move )
{
    being_can_move_local = new_can_move;
}

/*#pragma mark - wrap*/

static simulated_being_wrap *being_wrap_local = 0L;

void being_wrap( n_vect2 *location )
{
    if ( being_wrap_local )
    {
        being_wrap_local( location );
    }
    else
    {
        n_int px = location->x;
        n_int py = location->y;

        px = ( px + APESPACE_BOUNDS + 1 ) & APESPACE_BOUNDS;
        py = ( py + APESPACE_BOUNDS + 1 ) & APESPACE_BOUNDS;

        location->x = px;
        location->y = py;
    }
}

void being_wrap_override( simulated_being_wrap *new_move )
{
    being_wrap_local = new_move;
}

/*#pragma mark - initial_location*/

static simulated_being_initial_location *being_local_initial_location_local = 0L;

void being_initial_location( n_vect2 *location, n_byte2 *seed )
{
    if ( being_local_initial_location_local )
    {
        being_local_initial_location_local( location, seed );
    }
    else
    {
        n_int loop = 0;

        do
        {
            n_vect2 location_vector;

            location->x = math_random( seed ) & APESPACE_BOUNDS;
            location->y = math_random( seed ) & APESPACE_BOUNDS;

            being_wrap( &location_vector );

            loop ++;
        }
        while ( ( loop < 20 ) && ( WATER_TEST( land_location( APESPACE_TO_MAPSPACE( location->x ),
                                               APESPACE_TO_MAPSPACE( location->y ) ), land_tide_level() ) ) );

    }
}

void being_initial_location_override( simulated_being_initial_location *new_initial_location )
{
    being_local_initial_location_local = new_initial_location;
}

/**
 This checks to see if a Simulated Ape can see a particular point
 @param local The simulated_being pointer
 @param location The location of the point to be seen.
 @return 1 can see, 0 can not see
 */
static n_byte being_los( simulated_being *local, n_vect2 *location )
{
    n_int   local_facing = ( ( being_facing( local ) ) >> 5 );
    n_vect2 temp_location;

    temp_location.x = location->x;
    temp_location.y = location->y;

    /* There is probably a logical simplification of this
     as I can't think of it here is the brute force method.

     The Simulated Ape Simulation universe wraps around in all
     directions you need to calculate the line of site off the map too. */

    /*
     6
     5   7
     4       0
     3   1
     2
     */

    if ( being_los_projection( local, &temp_location ) == 1 )
    {
        return 1;
    }

    if ( ( local_facing == 6 ) || ( local_facing == 7 ) || ( local_facing == 0 ) || ( local_facing == 1 ) || ( local_facing == 2 ) )
    {
        temp_location.x = location->x + MAP_APE_RESOLUTION_SIZE;
        temp_location.y = location->y;

        if ( being_los_projection( local, &temp_location ) == 1 )
        {
            return 1;
        }
    }

    if ( ( local_facing == 7 ) || ( local_facing == 0 ) || ( local_facing == 1 ) || ( local_facing == 2 ) || ( local_facing == 3 ) )
    {
        temp_location.x = location->x + MAP_APE_RESOLUTION_SIZE;
        temp_location.y = location->y + MAP_APE_RESOLUTION_SIZE;
        if ( being_los_projection( local, &temp_location ) == 1 )
        {
            return 1;
        }
    }
    if ( ( local_facing == 0 ) || ( local_facing == 1 ) || ( local_facing == 2 ) || ( local_facing == 3 ) || ( local_facing == 4 ) )
    {
        temp_location.x = location->x;
        temp_location.y = location->y + MAP_APE_RESOLUTION_SIZE;
        if ( being_los_projection( local, &temp_location ) == 1 )
        {
            return 1;
        }
    }
    if ( ( local_facing == 1 ) || ( local_facing == 2 ) || ( local_facing == 3 ) || ( local_facing == 4 ) || ( local_facing == 5 ) )
    {
        temp_location.x = location->x - MAP_APE_RESOLUTION_SIZE;
        temp_location.y = location->y + MAP_APE_RESOLUTION_SIZE;
        if ( being_los_projection( local, &temp_location ) == 1 )
        {
            return 1;
        }
    }
    if ( ( local_facing == 2 ) || ( local_facing == 3 ) || ( local_facing == 4 ) || ( local_facing == 5 ) || ( local_facing == 6 ) )
    {
        temp_location.x = location->x - MAP_APE_RESOLUTION_SIZE;
        temp_location.y = location->y;
        if ( being_los_projection( local, &temp_location ) == 1 )
        {
            return 1;
        }
    }
    if ( ( local_facing == 3 ) || ( local_facing == 4 ) || ( local_facing == 5 ) || ( local_facing == 6 ) || ( local_facing == 7 ) )
    {
        temp_location.x = location->x - MAP_APE_RESOLUTION_SIZE;
        temp_location.y = location->y - MAP_APE_RESOLUTION_SIZE;
        if ( being_los_projection( local, &temp_location ) == 1 )
        {
            return 1;
        }
    }
    if ( ( local_facing == 4 ) || ( local_facing == 5 ) || ( local_facing == 6 ) || ( local_facing == 7 ) || ( local_facing == 0 ) )
    {
        temp_location.x = location->x;
        temp_location.y = location->y - MAP_APE_RESOLUTION_SIZE;
        if ( being_los_projection( local, &temp_location ) == 1 )
        {
            return 1;
        }
    }
    if ( ( local_facing == 5 ) || ( local_facing == 6 ) || ( local_facing == 7 ) || ( local_facing == 0 ) || ( local_facing == 1 ) )
    {
        temp_location.x = location->x + MAP_APE_RESOLUTION_SIZE;
        temp_location.y = location->y - MAP_APE_RESOLUTION_SIZE;
        if ( being_los_projection( local, &temp_location ) == 1 )
        {
            return 1;
        }
    }
    return 0;
}

/*#pragma mark - random*/

static void being_random3( simulated_being *value )
{
    math_random3( value->delta.random_seed );
}

n_byte2 being_random( simulated_being *value )
{
    return math_random( value->delta.random_seed );
}

static void being_set_random( simulated_being *value, n_byte2 *seed )
{
    value->delta.random_seed[0] = seed[0];
    value->delta.random_seed[1] = seed[1];
}

static void being_set_random1( simulated_being *value, n_byte2 seed1 )
{
    value->delta.random_seed[1] = seed1;
}

static n_byte2 *being_get_random( simulated_being *value )
{
    return value->delta.random_seed;
}

static n_uint being_genetic_count_zeros( n_genetics count )
{
    n_uint loop = 0;
    n_uint addition = 0;
    while ( loop < sizeof( n_genetics ) * 8 )
    {
        if ( ( ( count >> loop ) & 1 ) == 0 )
        {
            addition++;
        }
        loop++;
    }
    return addition;
}

n_uint being_genetic_comparison( n_genetics *primary, n_genetics *secondary, n_int parse_requirements )
{
    n_int   loop = 0;
    n_uint  addition = 0;

    if ( FIND_SEX( secondary[CHROMOSOME_Y] ) != SEX_FEMALE )
    {
        if ( parse_requirements == 1 )
        {
            return 0;
        }
    }
    else
    {
        if ( parse_requirements == 0 )
        {
            return 0;
        }
    }

    while ( loop < CHROMOSOMES )
    {
        n_genetics comparison = primary[loop] ^ secondary[loop];
        addition += being_genetic_count_zeros( comparison );
        loop++;
    }
    return addition;
}

static simulated_being_line_of_sight *being_line_of_sight_local = 0L;

void being_line_of_sight_override( simulated_being_line_of_sight *new_line_of_sight )
{
    being_line_of_sight_local = new_line_of_sight;
}

n_byte being_line_of_sight( simulated_being *local, n_vect2 *location )
{
    if ( being_line_of_sight_local )
    {
        return being_line_of_sight_local( local, location );
    }
    else
    {
        return being_los( local, location );
    }
}

static simulated_being_brain_cycle *being_brain_cycle_local = 0L;

void being_brain_cycle_override( simulated_being_brain_cycle *new_brain_cycle )
{
    being_brain_cycle_local = new_brain_cycle;
}

void being_brain_cycle( n_byte *local, n_byte2 *constants )
{
    if ( being_brain_cycle_local )
    {
        being_brain_cycle_local( local, constants );
    }
    else
    {
        brain_cycle( local, constants );
    }
}
/*#pragma mark - braincode*/

#ifdef BRAINCODE_ON

n_byte *being_braincode_external( simulated_being *value )
{
    simulated_isocial *social_value = being_social( value );
    return social_value[ATTENTION_EXTERNAL].braincode;
}

void being_clear_attention( simulated_being *value )
{
    memory_erase( ( n_byte * )( value->braindata.attention ), ATTENTION_SIZE );
}

void being_set_attention( simulated_being *value, n_int index, n_int attention )
{
    value->braindata.attention[index] = ( n_byte )attention;
}

n_byte being_attention( simulated_being *value, n_int index )
{
    return value->braindata.attention[index];
}

n_byte *being_braincode_internal( simulated_being *value )
{
    simulated_isocial *social_value = being_social( value );
    n_int          attention_location = being_attention( value, ATTENTION_ACTOR );
    return social_value[attention_location].braincode;
}

#else

void being_clear_attention( simulated_being *value )
{
}

void being_set_attention( simulated_being *value, n_int index, n_int attention )
{
}

n_byte being_attention( simulated_being *value, n_int index )
{
    return 0;
}

#endif

/* ape names */
#define NAMES_SURNAMES              256
#define NAMES_FIRST                 256


const n_string english_last_names[256] =
{
    "Abbott", "Adams", "Allen", "Arnold", "Ashton", "Atkins", "Austin", "Bailey", "Baird", "Baker", "Ball", "Banks", "Barker",
    "Barlow", "Barnes", "Barton", "Bates", "Baxter", "Begum", "Bell", "Benson", "Berry", "Bird", "Bishop", "Black", "Blair",
    "Blake", "Bloggs", "Bolton", "Bond", "Booth", "Bowden", "Bowen", "Boyd", "Brennan", "Briggs", "Brown", "Browne", "Bryant",
    "Bull", "Burke", "Burns", "Burton", "Butler", "Byrne", "Carr", "Carroll", "Carter", "Clark", "Clarke", "Coates", "Cole",
    "Coles", "Cook", "Cooke", "Cooper", "Cox", "Cross", "Cullen", "Curtis", "Dale", "Davey", "Davis", "Dawson", "Day", "Dean",
    "Dennis", "Dixon", "Doyle", "Duffy", "Duncan", "Dunn", "Ellis", "Evans", "Farrell", "Field", "Finch", "Fisher", "Flynn",
    "Ford", "Foster", "Fowler", "Fox", "Fraser", "French", "Frost", "Fuller", "Garner", "George", "Gibson", "Giles", "Gill",
    "Glover", "Gordon", "Gough", "Graham", "Grant", "Gray", "Green", "Haines", "Hall", "Hardy", "Harper", "Harris", "Hart",
    "Harvey", "Hayes", "Haynes", "Heath", "Hewitt", "Higgins", "Hill", "Hilton", "Hobbs", "Holden", "Holmes", "Holt", "Hooper",
    "Hope", "Howard", "Howe", "Hudson", "Hughes", "Hunt", "Hunter", "Jacobs", "James", "Jarvis", "Jones", "Jordan", "Kemp",
    "Kent", "Kerr", "King", "Kirk", "Knight", "Lane", "Lawson", "Leach", "Lee", "Leigh", "Lewis", "Little", "Lloyd", "Long",
    "Lord", "Love", "Lowe", "Lucas", "Lynch", "Mann", "Marsh", "Mason", "May", "Mellor", "Miles", "Miller", "Mills", "Moore",
    "Moran", "Morgan", "Morris", "Morton", "Moss", "Murphy", "Murray", "Nash", "Naylor", "Nelson", "Newman", "Newton", "Norman",
    "Owens", "Page", "Palmer", "Park", "Parker", "Parry", "Patel", "Payne", "Pearce", "Perry", "Peters", "Poole", "Porter",
    "Potter", "Powell", "Power", "Price", "Quinn", "Randall", "Read", "Reed", "Rees", "Reid", "Reilly", "Rhodes", "Rice", "Riley",
    "Robson", "Rogers", "Rose", "Ross", "Rossi", "Rowe", "Ryan", "Savage", "Scott", "Shah", "Sharma", "Sharp", "Shaw", "Silva",
    "Simmons", "Singh", "Slater", "Smart", "Smith", "Steele", "Stewart", "Stevens", "Stone", "Stuart", "Sutton", "Swift", "Tait",
    "Taylor", "Thomas", "Thorne", "Todd", "Tucker", "Turner", "Walker", "Wall", "Wallace", "Walsh", "Walton", "Ward", "Warren",
    "Watson", "Watts", "Weaver", "Webb", "Welch", "Wells", "West", "Whelan", "White", "Willis", "Wilson", "Wood", "Woods",
    "Wright", "Wyatt", "Yates", "Young"
};

const n_string english_female_first_names[256] =
{
    "Ada", "Agatha", "Agnes", "Aileen", "Aimee", "Alanna", "Alda", "Alice", "Alina", "Alison", "Alma", "Amanda", "Amber", "Andrea", "Angela",
    "Anita", "Anthea", "April", "Ariana", "Arleen", "Astrid", "Audrey", "Beata", "Becky", "Beryl", "Bess", "Bianca", "Blair", "Blythe",
    "Bonnie", "Brenda", "Briana", "Brooke", "Carla", "Carly", "Carmen", "Cheryl", "Chloe", "Coral", "Daphne", "Davida", "Dawn", "Denise",
    "Donna", "Dora", "Doris", "Echo", "Eda", "Edana", "Edith", "Edlyn", "Edna", "Edwina", "Effie", "Eileen", "Elaine", "Elena", "Elga",
    "Elise", "Eliza", "Ella", "Ellen", "Eloise", "Elsie", "Elvira", "Emily", "Emma", "Erika", "Erin", "Estra", "Ethel", "Eudora", "Eunice",
    "Faith", "Fannie", "Fawn", "Faye", "Fedora", "Fern", "Fiona", "Flora", "Gale", "Gaye", "Geneva", "Gilda", "Gladys", "Gloria", "Grace",
    "Gwynne", "Harley", "Hattie", "Hazel", "Hetty", "Hilda", "Holly", "Honey", "Hope", "Ingrid", "Irene", "Iris", "Ivory", "Ivy", "Jade",
    "Jane", "Janet", "Janice", "Jeanne", "Jemima", "Jewel", "Joan", "Joanna", "Joy", "June", "Kacey", "Kara", "Kate", "Kay", "Keely", "Kelsey",
    "Kendra", "Kerri", "Kyla", "Lacey", "Lane", "Lara", "Larina", "Leanne", "Leslie", "Linda", "Livia", "Lizzie", "Lois", "Lorena", "Lulu",
    "Luna", "Lynn", "Mabel", "Madge", "Maggie", "Maia", "Maisie", "Mandy", "Marcia", "Margot", "Marnia", "Mary", "Maude", "Maura", "Mavis",
    "Maxine", "Megan", "Melody", "Mercy", "Meris", "Merle", "Miriam", "Misty", "Moira", "Molly", "Mona", "Monica", "Mora", "Morgan", "Muriel",
    "Myra", "Myrtle", "Nancy", "Naomi", "Nell", "Nerita", "Nina", "Noelle", "Nola", "Norma", "Nydia", "Odette", "Olga", "Opal", "Oprah", "Orva",
    "Page", "Pamela", "Pansy", "Patty", "Pearl", "Phoebe", "Polly", "Quenna", "Questa", "Rachel", "Ramona", "Regina", "Rhea", "Rhoda", "Rita",
    "Robin", "Rosa", "Rowena", "Ruby", "Ruth", "Sacha", "Sadie", "Salena", "Sally", "Salome", "Sandra", "Sarah", "Serena", "Shana", "Sharon",
    "Sheila", "Sibley", "Silver", "Sirena", "Talia", "Tamara", "Tammy", "Tanya", "Tara", "Tasha", "Tatum", "Tess", "Thalia", "Thea", "Thelma",
    "Thora", "Tilda", "Tina", "Tracy", "Trina", "Trista", "Tyne", "Udele", "Ula", "Ulrica", "Ulva", "Una", "Unity", "Ursa", "Ursula", "Valda",
    "Vania", "Veleda", "Vera", "Verda", "Violet", "Vita", "Wanda", "Wilda", "Willa", "Willow", "Wynne", "Zea", "Zelda", "Zera", "Zoe"
};

const n_string english_male_first_names[256] =
{
    "Aaron", "Abbott", "Abel", "Adam", "Albern", "Albert", "Alfie", "Alfred", "Alvin", "Amery", "Amos", "Andrew", "Angus", "Ansel", "Arlen",
    "Arnold", "Arvel", "Austin", "Axel", "Baird", "Barry", "Basil", "Bert", "Blair", "Blake", "Boris", "Brent", "Brian", "Brice", "Brock",
    "Bruce", "Bruno", "Bryant", "Buck", "Bud", "Burton", "Byron", "Calvin", "Carl", "Carter", "Carver", "Cary", "Casey", "Casper", "Cecil",
    "Cedric", "Claude", "Clive", "Clyde", "Colin", "Conan", "Connor", "Conrad", "Conroy", "Conway", "Corwin", "Craig", "Crosby", "Culver",
    "Curt", "Curtis", "Cyril", "Damon", "Daniel", "Darcy", "David", "Dean", "Declan", "Dennis", "Derek", "Dermot", "Derwin", "Dexter",
    "Dillon", "Dion", "Dirk", "Donald", "Dorian", "Drew", "Dudley", "Duncan", "Dwayne", "Dwight", "Dylan", "Earl", "Edgar", "Edwin", "Efrain",
    "Egbert", "Elbert", "Elmer", "Elroy", "Elton", "Elvis", "Emmett", "Emrick", "Ernest", "Errol", "Esmond", "Eugene", "Evan", "Ezra", "Fabian",
    "Farley", "Felix", "Fenton", "Ferris", "Finbar", "Floyd", "Foster", "Fox", "Frank", "Gale", "Galvin", "Garret", "Garth", "Gavin", "George",
    "Gideon", "Giles", "Gilroy", "Glenn", "Godwin", "Graham", "Grant", "Guy", "Hadden", "Hadley", "Hadwin", "Hale", "Hall", "Hamlin", "Hardy",
    "Harley", "Hector", "Henry", "Herman", "Homer", "Howard", "Hubert", "Hunter", "Ian", "Isaac", "Isaiah", "Ivan", "Ives", "Jack", "Jacob",
    "Jarvis", "Jason", "Jasper", "Jed", "Jerome", "Jesse", "John", "Joshua", "Justin", "Keaton", "Keith", "Kelsey", "Kelvin", "Kent", "Kerry",
    "Kevin", "Kirby", "Kirk", "Kit", "Kody", "Konrad", "Kurt", "Kyle", "Lamont", "Landon", "Lane", "Lars", "Lee", "Leroy", "Leslie", "Lester",
    "Lionel", "Lloyd", "Logan", "Lowell", "Lyndon", "Marcus", "Marlon", "Martin", "Marvin", "Medwin", "Melvin", "Merlin", "Miles", "Morgan",
    "Morris", "Morton", "Murray", "Neal", "Nigel", "Noel", "Norman", "Olaf", "Olin", "Oliver", "Oscar", "Oswald", "Otis", "Owen", "Paul",
    "Perry", "Peter", "Philip", "Pierce", "Quincy", "Quinn", "Ralph", "Rex", "Riley", "Rodney", "Roger", "Roland", "Rolf", "Ronald", "Rory",
    "Ross", "Roy", "Rufus", "Rupert", "Ryan", "Samson", "Samuel", "Scott", "Sean", "Seth", "Shawn", "Sidney", "Simon", "Sloane", "Stacy",
    "Thomas", "Toby", "Todd", "Tony", "Trent", "Trevor", "Troy", "Tyler", "Unwin", "Vance", "Victor", "Walter", "Warren", "Wayne", "Wilbur",
    "Willis", "Wyatt", "Wylie"
};


#define FAMILY_NAME_AND_MOD (NAMES_SURNAMES - 1)
#define FIRST_NAME_AND_MOD  (NAMES_FIRST - 1)

#define UNPACK_FAMILY_FIRST_NAME(packed_family_name)  (packed_family_name & 255)
#define UNPACK_FAMILY_SECOND_NAME(packed_family_name) ((packed_family_name >> 8) & 255)


#define GET_NAME_FAMILY(f0,f1) ((n_byte2)((f0&255)|((f1&255)<<8)))


void being_unpack_family( n_byte2 name, n_byte *values ) /* brain.c */
{
    values[0] = UNPACK_FAMILY_FIRST_NAME( name );
    values[1] = UNPACK_FAMILY_SECOND_NAME( name );
}

n_byte being_first_name( simulated_being *value )
{
    if ( value == 0L )
    {
        return 0;
    }
    {
        return value->constant.name[0] & FIRST_NAME_AND_MOD;
    }
}

static void being_set_first_name( simulated_being *value, n_byte2 name )
{
    value->constant.name[0] =  name & FIRST_NAME_AND_MOD;
}

void being_set_family_name( simulated_being *value, n_byte first, n_byte last )
{
    value->constant.name[1] =  ( n_byte2 )( first | ( last << 8 ) );
}

n_byte2 being_gender_name( simulated_being *value )
{
    if ( value == 0L )
    {
        return 0;
    }
    return ( n_byte2 )( ( being_first_name( value ) | ( FIND_SEX( GET_I( value ) ) << 8 ) ) );
}

n_byte2 being_family_name( simulated_being *value )
{
    if ( value == 0L )
    {
        return 0;
    }
    return ( GET_NAME_FAMILY( being_family_first_name( value ), being_family_second_name( value ) ) );
}

n_int being_name_comparison( simulated_being *value, n_byte2 gender_name, n_byte2 family_name )
{
    return ( ( being_gender_name( value ) == gender_name ) && ( being_family_name( value ) == family_name ) );
}

n_byte being_family_first_name( simulated_being *value )
{
    if ( value == 0L )
    {
        return 0;
    }
    {
        return UNPACK_FAMILY_FIRST_NAME( value->constant.name[1] );
    }
}

n_byte being_family_second_name( simulated_being *value )
{
    if ( value == 0L )
    {
        return 0;
    }
    {
        return UNPACK_FAMILY_SECOND_NAME( value->constant.name[1] );
    }
}

static void  being_name( n_byte female, n_int first, n_byte family0, n_byte family1, n_string name )
{
    n_int  position = 0;
    if ( first != -1 )
    {
        if ( female )
        {
            io_string_write( name, english_female_first_names[ first ], &position );
        }
        else
        {
            io_string_write( name, english_male_first_names[ first ], &position );
        }
        io_string_write( name, " ", &position );
        io_string_write( name, english_last_names[ family0 ], &position );
        io_string_write( name, "-", &position );
        io_string_write( name, english_last_names[ family1 ], &position );
    }
    else
    {
        io_string_write( name, "Unknown", &position );
    }
}

void being_name_simple( simulated_being *value, n_string str )
{
    if ( value )
    {
        n_int is_female = FIND_SEX( GET_I( value ) ) == SEX_FEMALE;
        n_byte first_name = being_first_name( value );
        n_byte first_family_name = being_family_first_name( value );
        n_byte second_family_name = being_family_second_name( value );
        being_name( is_female, first_name, first_family_name, second_family_name, str );
    }
    else
    {
        n_int position = 0;
        io_string_write( str, "Unknown", &position );
    }
}

void being_name_byte2( n_byte2 first, n_byte2 family, n_string name )
{
    being_name( ( n_byte )( ( first >> 8 ) == SEX_FEMALE ),
                ( n_int )( first & 255 ),
                ( n_byte )UNPACK_FAMILY_FIRST_NAME( family ),
                ( n_byte )UNPACK_FAMILY_SECOND_NAME( family ),
                name );
}

void being_state_description( n_byte2 state, n_string result )
{
    /* if you change this you need to change the corresponding definitions in entity.h */
    const n_string state_description[] =
    {
        "Sleeping", "Awake", "Hungry", "Swimming", "Eating", "Moving",
        "Speaking", "Shouting", "Grooming", "Suckling",
        "Showing Force", "Attacking", "No Food"
    };
    n_int string_length = 0;
    n_int n = 2;

    if ( state == BEING_STATE_ASLEEP )
    {
        io_string_write( result, state_description[0], &string_length );
        return;
    }

    while ( n < BEING_STATES )
    {
        if ( state & ( 1 << ( n - 1 ) ) )
        {
            if ( string_length > 0 )
            {
                io_string_write( result, ", ", &string_length );
            }
            io_string_write( result, state_description[n], &string_length );
        }
        n++;
    }
}

/**
 This moves the specified Simulated Ape outside the core simulation movement
 interface - think mouse movement or keyboard movement.
 @param local The pointer to the simulated_being being moved.
 @param rel_vel The movement variable used - historically the velocity hence the
 variable name.
 @param kind The kind of movement used - 0 = turning around pivoting on the
 z-axis (ie a standing turn), 1 = move forwards or backwards based on the
 direction facing, 2 = cursor like movements along the X and Y axis useful
 when operating the arrow keys (but not much else).
 */
void being_move( simulated_being *local, n_int rel_vel, n_byte kind )
{
    n_vect2 location_vector;
    n_byte2 loc[2];
    being_space( local, &location_vector );

    if ( kind == 1 )
    {
        n_vect2 facing_vector;
        being_facing_vector( local, &facing_vector, 1 );
        vect2_d( &location_vector, &facing_vector, rel_vel, 512 );
    }
    else
    {
        if ( rel_vel < 2 )
        {
            location_vector.y -= ( rel_vel * 200 ) - 100;
        }
        else
        {
            location_vector.x += 500 - ( rel_vel * 200 );
        }
    }

    being_wrap( &location_vector );

    loc[0] = ( n_byte2 )location_vector.x;
    loc[1] = ( n_byte2 )location_vector.y;
    being_set_location( local, loc );
}

n_byte being_crowding( simulated_being *value )
{
    return value->delta.crowding;
}

void being_crowding_cycle( simulated_being *value, n_int beings_in_vacinity )
{
    /** if the being is not overcrowded and its social drive is not saturated */
    if ( beings_in_vacinity < ( value->delta.crowding + SOCIAL_TOLLERANCE ) )
    {
        /** increase the social drive */
        being_inc_drive( value, DRIVE_SOCIAL );
    }
    else
    {
        /** decrease the social drive */
        being_dec_drive( value, DRIVE_SOCIAL );
    }

    /** Adjust crowding (typical expected number of neighbours). */
    if ( beings_in_vacinity < value->delta.crowding )
    {
        if ( value->delta.crowding > MIN_CROWDING )
        {
            value->delta.crowding--;
        }
    }
    if ( beings_in_vacinity > value->delta.crowding )
    {
        if ( value->delta.crowding < MAX_CROWDING )
        {
            value->delta.crowding++;
        }
    }
}


/*#pragma mark - state*/

void    being_set_state( simulated_being *value, being_state_type state )
{
    value->delta.macro_state = state;
}

void    being_add_state( simulated_being *value, being_state_type state )
{
    value->delta.macro_state |= state;

}
n_byte2 being_state( simulated_being *value )
{
    return value->delta.macro_state;
}

/*#pragma mark - brainstates*/

#ifdef BRAIN_ON

void being_set_brainstates( simulated_being *value, n_int asleep, n_byte2 val1, n_byte2 val2, n_byte2 val3 )
{
    n_int three_offset = ( asleep ? 0 : 3 );

    value->braindata.brain_state[three_offset + 0] = val1;
    value->braindata.brain_state[three_offset + 1] = val2;
    value->braindata.brain_state[three_offset + 2] = val3;
}

#endif

n_int being_brainstates( simulated_being *value, n_int asleep, n_byte2 *states )
{
    n_int three_offset = ( asleep ? 0 : 3 );

    states[0] = value->braindata.brain_state[three_offset + 0];
    states[1] = value->braindata.brain_state[three_offset + 1];
    states[2] = value->braindata.brain_state[three_offset + 2];

    return ( ( states[0] != 0 ) || ( states[1] != 1024 ) || ( states[2] != 0 ) );
}

/*#pragma mark - erase*/

void being_erase( simulated_being *value )
{
    memory_erase( ( n_byte * )value, sizeof( simulated_being ) );
}

/*#pragma mark - honor*/

void being_honor_delta( simulated_being *value, n_int delta )
{
    n_int honor_value = value->delta.honor;
    if ( delta > 0 )
    {
        if ( ( honor_value + delta ) > 255 )
        {
            value->delta.honor = 255;
            return;
        }
    }
    else
    {
        if ( ( honor_value + delta ) < 0 )
        {
            value->delta.honor = 0;
            return;
        }
    }
    value->delta.honor += ( n_byte )delta;
}

n_byte being_honor( simulated_being *value )
{
    return value->delta.honor;
}

void being_honor_inc_dec( simulated_being *inc, simulated_being *dec )
{
    if ( inc->delta.honor < 255 )
    {
        inc->delta.honor++;
    }
    if ( dec->delta.honor > 0 )
    {
        dec->delta.honor--;
    }
}

void being_honor_swap( simulated_being *victor, simulated_being *vanquished )
{
    if ( victor->delta.honor < vanquished->delta.honor )
    {
        /** swap social status */
        n_byte temp_hon = victor->delta.honor;
        victor->delta.honor = vanquished->delta.honor;
        vanquished->delta.honor = temp_hon;
    }
}

n_int being_honor_compare( simulated_being *first, simulated_being *second )
{
    if ( first->delta.honor > second->delta.honor )
    {
        return 1;
    }

    if ( first->delta.honor < second->delta.honor )
    {
        return -1;
    }

    return 0;
}

n_byte being_honor_immune( simulated_being *value )
{
    n_int local_honor = being_honor( value );
    if ( local_honor < 250 ) /* ALPHA_RANK */
    {
        return ( n_byte )( 1 + ( local_honor >> 6 ) );
    }
    return 2; /* IMMUNE_STRENGTH_ALPHA */
}

/*#pragma mark - posture*/

n_byte being_posture( simulated_being *value )
{
    return value->delta.posture;
}

void being_set_posture( simulated_being *value, n_byte post )
{
    value->delta.posture = post;
}

n_int being_posture_under( simulated_being *value, enum posture_type post )
{
    return ( value->delta.posture < post );
}

/*#pragma mark - brain*/

#ifdef BRAIN_ON
n_byte *being_brain( simulated_being *value )
{
    return value->braindata.brain;
}
#endif

/*#pragma mark - misc*/

simulated_iepisodic *being_episodic( simulated_being *value )
{
    return value->events.episodic;

}

simulated_isocial *being_social( simulated_being *value )
{
    return value->events.social;
}

n_int being_location_x( simulated_being *value )
{
    return ( n_int )value->delta.location[0];
}

n_int being_location_y( simulated_being *value )
{
    return ( n_int )value->delta.location[1];
}

void being_high_res( simulated_being *value, n_vect2 *vector )
{
    vector->x = APESPACE_TO_HR_MAPSPACE( being_location_x( value ) );
    vector->y = APESPACE_TO_HR_MAPSPACE( being_location_y( value ) );
}

void being_space( simulated_being *value, n_vect2 *vector )
{
    vector->x = value->delta.location[0];
    vector->y = value->delta.location[1];
}

n_byte2 *being_location( simulated_being *value )
{
    return value->delta.location;
}

void being_set_location( simulated_being *value, n_byte2 *from )
{
    value->delta.location[0] = from[0];
    value->delta.location[1] = from[1];
}

#ifdef DEBUG_LACK_OF_MOVEMENT

n_int being_total_movement( simulated_being *value )
{
    return ( n_int ) value->delta.total_movement;
}

void being_add_total_movement( simulated_being *value )
{
    value->delta.total_movement += value->delta.velocity;
}

void being_zero_total_movement( simulated_being *value )
{
    value->delta.total_movement = 0;
}

void being_register_movement( simulated_being *value, n_string comment_string )
{
    if ( ( IS_NIGHT( land_time() ) == 0 ) && ( being_total_movement( value ) == 0 ) )
    {
        n_string_block name_string, time_string;
        spacetime_to_string( time_string );
        being_name_simple( value, name_string );
        printf( "%s %s %s\n", time_string, name_string, comment_string );
    }
}

#endif

n_byte being_speed( simulated_being *value )
{
    return value->delta.velocity[0];
}

void being_set_speed( simulated_being *value, n_byte sp )
{
    value->delta.velocity[0] = sp;
}

void being_speed_advance( simulated_being *value )
{
    n_int loop = 0;
    while ( loop < 9 )
    {
        value->delta.velocity[9 - loop] = value->delta.velocity[8 - loop];
        loop++;
    }
}

n_int being_ten_minute_distance( simulated_being *value )
{
    n_int total_distance = 0;
    n_int loop = 0;
    while ( loop < 10 )
    {
        total_distance += ( n_int )value->delta.velocity[loop];
        loop++;
    }
    return total_distance;
}


void being_delta( simulated_being *primary, simulated_being *secondary, n_vect2 *delta )
{
    delta->x = primary->delta.location[0] - secondary->delta.location[0];
    delta->y = primary->delta.location[1] - secondary->delta.location[1];
}

/*#pragma mark - parasites*/

void being_add_parasites( simulated_being *value )
{
    /* maximum number of parasites in the range 0-255 */
    if ( value->delta.parasites < ( ( GENE_HAIR( being_genetics( value ) ) * 255 ) >> 4 ) )
    {
        value->delta.parasites++;
    }
}

void being_remove_parasites( simulated_being *value, n_int number_of_parasites )
{
    if ( value->delta.parasites > number_of_parasites )
    {
        value->delta.parasites -= ( n_byte )number_of_parasites;
    }
    else
    {
        value->delta.parasites = 0;
    }
}

n_int being_parasites( simulated_being *value )
{
    return value->delta.parasites;
}

void being_set_parasites( simulated_being *value, n_byte parasites )
{
    value->delta.parasites = parasites;
}

/*#pragma mark - misc part 2*/

n_int being_dob( simulated_being *value )
{
    return value->constant.date_of_birth;
}

void being_facing_towards( simulated_being *value, n_vect2 *vector )
{
    value->delta.direction_facing = math_tan( vector );
}

void being_wander( simulated_being *value, n_int wander )
{
    value->delta.direction_facing = ( n_byte )( ( value->delta.direction_facing + 256 + wander ) & 255 );
}

void being_facing_init( simulated_being *value )
{
    value->delta.direction_facing = ( n_byte )( being_random( value ) & 255 );
}

void being_facing_vector( simulated_being *value, n_vect2 *vect, n_int divisor )
{
    vect2_direction( vect, value->delta.direction_facing, divisor * 32 );
}

n_byte being_facing( simulated_being *value )
{
    return value->delta.direction_facing;
}

n_genetics *being_genetics( simulated_being *value )
{
    return value->constant.genetics;
}

n_int being_pregnant( simulated_being *value )
{
    return value->changes.date_of_conception;
}

n_int being_female( simulated_being *value )
{
    return ( FIND_SEX( GET_I( value ) ) == SEX_FEMALE );
}

n_int being_speaking( simulated_being *value )
{
    return ( value->delta.awake && ( being_state( value ) & BEING_STATE_SPEAKING ) );
}

n_genetics *being_fetal_genetics( simulated_being *value )
{
    return value->changes.fetal_genetics;
}

/* TODO: Remove this kind of access eventually */
n_int   being_energy( simulated_being *value )
{
    return value->delta.stored_energy;
}

n_int   being_energy_less_than( simulated_being *value, n_int less_than )
{
    return being_energy( value ) < less_than;
}

void  being_dead( simulated_being *value )
{
    value->delta.stored_energy = BEING_DEAD;
}

void being_living( simulated_being *value )
{
    value->delta.stored_energy = BEING_FULL;
}

void   being_energy_delta( simulated_being *value, n_int delta )
{
    n_int total = value->delta.stored_energy + delta;

    if ( total < BEING_DEAD )
    {
        total = BEING_DEAD;
    }

    value->delta.stored_energy = ( n_byte2 ) total;
}

n_byte   being_drive( simulated_being *value, enum drives_definition drive )
{
    return value->changes.drives[drive];
}

n_byte *being_drives( simulated_being *value )
{
    return value->changes.drives;
}

void    being_inc_drive( simulated_being *value, enum drives_definition drive )
{
    if ( value->changes.drives[drive] < DRIVES_MAX )
    {
        value->changes.drives[drive]++;
    }
}

void    being_dec_drive( simulated_being *value, enum drives_definition drive )
{
    if ( value->changes.drives[drive] > 0 )
    {
        value->changes.drives[drive]--;
    }
}

void    being_reset_drive( simulated_being *value, enum drives_definition drive )
{
    value->changes.drives[drive] = 0;
}

n_int   being_height( simulated_being *value )
{
    return value->delta.height;
}

void    being_set_height( simulated_being *value, n_int height )
{
    value->delta.height = ( n_byte2 )height;
}

n_int   being_mass( simulated_being *value )
{
    return value->delta.mass;
}

void being_turn_away_from_water( simulated_being *value )
{
    n_int    it_water_turn = 0;
    n_vect2 location_vector;

    being_space( value, &location_vector );

    while ( it_water_turn < 7 )
    {
        /* find higher land first */
        n_int    iturn = 8 - it_water_turn;
        n_int    loc_f = being_facing( value );
        n_int    iturn_plus  = loc_f + iturn;
        n_int    iturn_minus = loc_f + ( 256 - iturn );

        n_byte   turn_plus  = ( n_byte )( ( iturn_plus )  & 255 );
        n_byte   turn_minus = ( n_byte )( ( iturn_minus ) & 255 );
        n_vect2  temp_vector;

        n_int  z_plus;
        n_int  z_minus;

        vect2_direction( &temp_vector, turn_plus, 128 );
        vect2_add( &temp_vector, &temp_vector, &location_vector );

        spacetime_convert_to_map( &temp_vector );

        z_plus = land_location_vect( &temp_vector );

        vect2_direction( &temp_vector, turn_minus, 128 );
        vect2_add( &temp_vector, &temp_vector, &location_vector );

        spacetime_convert_to_map( &temp_vector );

        z_minus = land_location_vect( &temp_vector );

        if ( z_minus > z_plus )
        {
            being_wander( value, -iturn );
        }
        else if ( z_minus < z_plus )
        {
            being_wander( value, iturn );
        }
        it_water_turn++;
    }
}

inventory_type being_carried( simulated_being *value, BODY_INVENTORY_TYPES location )
{
    return ( value )->changes.inventory[location] & 0xfffff8;
}

void being_drop( simulated_being *value, BODY_INVENTORY_TYPES location )
{
    ( value )->changes.inventory[location] &= 7;
    being_set_attention( value, ATTENTION_BODY, location );
}

void being_take( simulated_being *value, BODY_INVENTORY_TYPES location, inventory_type object )
{
    ( value )->changes.inventory[location] |= object;
    being_set_attention( value, ATTENTION_BODY, location );
}


/**
 * @brief Check if a being is on ground or in water
 * @param px x coordinate of the being location
 * @param py y coordinate of the being location
 * @param params being_draw pointer
 * @return 1 if on ground, 0 otherwise
 */
static n_byte    being_ground( n_int px, n_int py, n_int dx, n_int dy, void *params )
{
    n_int        abs_sum = ABS( dx ) + ABS( dy );
    being_draw *being_pixel = ( being_draw * ) params;
    n_int        d_vis = being_pixel->visibility_delta;
    n_int         local_z = ( ( px * ( being_pixel->offset_x ) ) + ( py * ( being_pixel->offset_y ) ) ) >> 9;

    if ( abs_sum )
    {
        weather_values   seven_values = weather_seven_values( APESPACE_TO_MAPSPACE( px ), APESPACE_TO_MAPSPACE( py ) );
        n_int  span10 = ( ( abs_sum - 1 ) ? 1448 : 1024 );

        switch ( seven_values )
        {
        case WEATHER_SEVEN_SUNNY_DAY:
        case WEATHER_SEVEN_CLOUDY_DAY:
            being_pixel->visibility_total += ( span10 * ( d_vis + 16 ) ) >> 11;
            break;
        case WEATHER_SEVEN_RAINY_DAY:
        case WEATHER_SEVEN_DAWN_DUSK:
            being_pixel->visibility_total += ( span10 * ( ( 2 * d_vis ) + 25 ) ) >> 11;
            break;
        case WEATHER_SEVEN_CLEAR_NIGHT:
            being_pixel->visibility_total += ( span10 * ( ( 5 * d_vis ) + 65 ) ) >> 11;
        case WEATHER_SEVEN_CLOUDY_NIGHT:
            being_pixel->visibility_total += ( span10 * ( ( 8 * d_vis ) + 93 ) ) >> 11;
        case WEATHER_SEVEN_RAINY_NIGHT:
            being_pixel->visibility_total += ( span10 * ( ( 12 * d_vis ) + 145 ) ) >> 11;
            break;

        case WEATHER_SEVEN_ERROR:
        default:
            return 1;
        }
        if ( being_pixel->visibility_total > VISIBILITY_MAXIMUM )
        {
            return 1;
        }
        local_z += being_pixel->start_z;

        if ( local_z < WALK_ON_WATER( land_location( px, py ), land_tide_level() ) )
        {
            return 1;
        }
    }
    return 0;
}


n_byte being_basic_line_of_sight( simulated_being *local, n_vect2 *extern_end, n_vect2 *start, n_vect2 *delta, n_vect2 *end )
{
    n_vect2    vector_facing;
    vect2_copy( end, extern_end );
    /* TODO: Check for being awake - need a land and being based awake check */
    being_space( local, start );

    vect2_subtract( delta, end, start );
    {
        n_int distance_squared = vect2_dot( delta, delta, 1, 1 );
        if ( distance_squared > ( VISIBILITY_SPAN * VISIBILITY_SPAN ) )
        {
            return 0;
        }
    }
    /** check trivial case first - self aware */
    if ( ( delta->x == 0 ) && ( delta->y == 0 ) )
    {
        return 1;
    }
    being_facing_vector( local, &vector_facing, 16 );
    /* if it is behind, it can't be in the line of sight */
    if ( vect2_dot( &vector_facing, delta, 1, 64 ) < 0 )
    {
        return 0;
    }
    return 2;
}

n_byte being_los_projection( simulated_being *local, n_vect2 *extern_end )
{
    n_vect2    start, delta, end;
    n_byte     return_value = being_basic_line_of_sight( local, extern_end, &start, &delta, &end );

    if ( return_value != 2 )
    {
        return return_value;
    }

    /** move everything from being co-ordinates to map co-ordinates */

    spacetime_convert_to_map( &start );
    spacetime_convert_to_map( &delta );
    spacetime_convert_to_map( &end );

    /* check trivial case first - self aware (after co-ord translation) */
    if ( ( delta.x == 0 ) && ( delta.y == 0 ) )
    {
        return 1;
    }

    {
        const n_int simulated_iape_height = 3;
        n_int    start_z = ( n_int )WALK_ON_WATER( land_location_vect( &start ), land_tide_level() ) + simulated_iape_height;
        n_int    delta_z = ( n_int )WALK_ON_WATER( land_location_vect( &end ), land_tide_level() ) - start_z + simulated_iape_height;
        n_int    common_divisor = vect2_dot( &delta, &delta, 1, 1 );
        being_draw       translate;

        if ( common_divisor == 0 )
        {
            common_divisor = 1;
        }

        {
            n_vect2 offset = {0};

            vect2_d( &offset, &delta, 512 * delta_z, common_divisor );

            start_z -= vect2_dot( &start, &offset, 1, 512 );

            translate.start_z = start_z;
            translate.offset_x = offset.x;
            translate.offset_y = offset.y;

            translate.visibility_total = 100 * GENE_VISION_INITIAL( being_genetics( local ) );

            translate.visibility_delta = GENE_VISION_DELTA( being_genetics( local ) );
        }

        {
            n_join          being_point;
            being_point.information = ( void * ) &translate;
            being_point.pixel_draw  = &being_ground;

            if ( math_join_vect2( start.x, start.y, &delta, &being_point ) )
            {
                return 0;
            }
        }
    }
    return 1;
}

#ifdef BRAINCODE_ON
static void being_init_braincode_create( simulated_being *local, n_byte internal )
{
    n_byte2 *local_random = being_get_random( local );

    n_int ch = 0;
    /** initially seed the brain with instructions which are random but genetically biased */
    while ( ch < BRAINCODE_SIZE )
    {
        math_random3( local_random );
        if ( internal != 0 )
        {
#ifdef RANDOM_INITIAL_BRAINCODE
            being_braincode_internal( local )[ch] = math_random( local_random ) & 255;
#else
            being_random3( local );
            being_braincode_internal( local )[ch] = ( math_random( local_random ) & 192 ) | get_braincode_instruction( local );
#endif
            being_braincode_internal( local )[ch + 1] = math_random( local_random ) & 255;
            being_braincode_internal( local )[ch + 2] = math_random( local_random ) & 255;
        }
        else
        {
#ifdef RANDOM_INITIAL_BRAINCODE
            being_braincode_external( local )[ch] = math_random( local_random ) & 255;
#else
            being_random3( local );
            being_braincode_external( local )[ch] = ( math_random( local_random ) & 192 ) | get_braincode_instruction( local );
#endif
            being_braincode_external( local )[ch + 1] = math_random( local_random ) & 255;
            being_braincode_external( local )[ch + 2] = math_random( local_random ) & 255;
        }
        ch += 3;
    }
}


/** initialise inner or outer braincode */
void being_init_braincode( simulated_being *local,
                           simulated_being *other,
                           n_byte friend_foe,
                           n_byte internal )
{
    n_uint i, most_similar_index, diff, min, actor_index;
    simulated_isocial *graph;
    if ( other == 0L )
    {
        being_init_braincode_create( local, internal );
    }
    else
    {
        /** initialise based upon a similar being */
        graph = being_social( local );

        if ( graph == 0L )
        {
            return;
        }

        most_similar_index = 0;
        min = 99999;
        actor_index = being_attention( local, ATTENTION_ACTOR );

        /** Find the entry in the social graph with the most similar friend or foe value.
         The FOF value is used because when two beings meet for the first time this
         value is calculated based upon a variety of genetic and learned dispositions.
         Notice also that the search includes index zero, which is the self. */
        for ( i = 0; i < SOCIAL_SIZE; i++ )
        {
            if ( ( i != actor_index ) && ( !SOCIAL_GRAPH_ENTRY_EMPTY( graph, i ) ) )
            {
                n_int signed_diff = ( n_int )graph[i].friend_foe - ( n_int )friend_foe;
                if ( signed_diff < 0 )
                {
                    diff = ( n_uint )( 0 - signed_diff );
                }
                else
                {
                    diff = ( n_uint )signed_diff;
                }
                if ( diff < min )
                {
                    min = diff;
                    most_similar_index = i;
                }
            }
        }
        /** Copy braincode for the most similar individual */
        memory_copy( graph[most_similar_index].braincode, graph[actor_index].braincode, BRAINCODE_SIZE );
    }
}
#endif


/** Assign a unique name to the given being, based upon the given family names */
static n_int being_set_unique_name( simulated_being *beings,
                                    n_int number,
                                    simulated_being *local_being,
                                    n_byte2   mother_family_name,
                                    n_byte2   father_family_name )
{
    n_int     i;
    n_int     samples = 0, found = 0;
    n_byte2   possible_family_name;
    n_byte2   possible_first_name;

    /** random number initialization */
    being_random3( local_being );
    being_random3( local_being );


    /** if no mother and father are specified then randomly create names */
    if ( ( mother_family_name == 0 ) && ( father_family_name == 0 ) )
    {
        n_byte2 *random_factor = being_get_random( local_being );

        mother_family_name =
            GET_NAME_FAMILY( ( random_factor[0] & FAMILY_NAME_AND_MOD ),
                             ( random_factor[1] & FAMILY_NAME_AND_MOD ) );

        math_random3( random_factor );

        father_family_name =
            GET_NAME_FAMILY( ( random_factor[0] & FAMILY_NAME_AND_MOD ),
                             ( random_factor[1] & FAMILY_NAME_AND_MOD ) );
    }

    /** conventional family name */
    possible_family_name =
        GET_NAME_FAMILY( UNPACK_FAMILY_FIRST_NAME( mother_family_name ),
                         UNPACK_FAMILY_FIRST_NAME( father_family_name ) );

    while ( ( found == 0 ) && ( samples < 2048 ) )
    {
        n_byte2 *random_factor = being_get_random( local_being );

        being_random3( local_being );

        /** choose a first_name at random */
        possible_first_name = ( n_byte2 )( ( random_factor[0] & 255 ) | ( FIND_SEX( GET_I( local_being ) ) << 8 ) );


        /** avoid the same two family names */
        if ( UNPACK_FAMILY_FIRST_NAME( mother_family_name ) ==
                UNPACK_FAMILY_SECOND_NAME( father_family_name ) )
        {

            being_random3( local_being );

            random_factor = being_get_random( local_being );

            possible_family_name =
                GET_NAME_FAMILY( ( random_factor[0] & FAMILY_NAME_AND_MOD ),
                                 ( random_factor[1] & FAMILY_NAME_AND_MOD ) );
        }
        if ( samples == 1024 )
        {
            being_random3( local_being );

            random_factor = being_get_random( local_being );

            possible_family_name =
                GET_NAME_FAMILY( ( random_factor[0] & FAMILY_NAME_AND_MOD ),
                                 ( random_factor[1] & FAMILY_NAME_AND_MOD ) );
        }

        /** avoid the same two family names */
        if ( UNPACK_FAMILY_SECOND_NAME( mother_family_name ) ==
                UNPACK_FAMILY_FIRST_NAME( father_family_name ) )
        {
            being_random3( local_being );

            random_factor = being_get_random( local_being );

            possible_family_name =
                GET_NAME_FAMILY( ( random_factor[0] & FAMILY_NAME_AND_MOD ),
                                 ( random_factor[1] & FAMILY_NAME_AND_MOD ) );
        }

        being_set_first_name( local_being, possible_first_name );

        being_set_family_name( local_being,
                               UNPACK_FAMILY_FIRST_NAME( possible_family_name ),
                               UNPACK_FAMILY_SECOND_NAME( possible_family_name ) );

        /** does the name already exist in the population */
        found = 1;
        for ( i = 0; i < number; i++ )
        {
            simulated_being *other_being = &beings[i];
            if ( being_name_comparison( local_being, being_gender_name( other_being ), being_family_name( other_being ) ) )
            {
                found = 0;
                break;
            }
        }
        samples++;
    }

    return found;
}

static void being_random_genetics( n_genetics *value, n_byte2 *random, n_int male )
{
    n_int loop = 0;
    math_random3( random );
    while ( loop < CHROMOSOMES )
    {
        n_uint loop2 = 0;

        value[loop] = 0;

        while ( loop2 < ( sizeof( n_genetics ) * 8 ) )
        {
            if ( math_random( random ) & 1 )
            {
                value[loop] |= 1 << loop2;
            }
            loop2++;
        }
        loop++;
    }
    value[CHROMOSOME_Y] = ( n_genetics )( value[CHROMOSOME_Y] & 0xfffffffe );
    value[CHROMOSOME_Y] |= ( male ? 2 : 3 );
}

n_uint being_init_group( simulated_being *beings, n_byte2 *local_random, n_uint count_to, n_uint max )
{
    n_uint num = 0;
    math_random3( local_random );

    while ( num < count_to )
    {
        math_random3( local_random );
        if ( ( num + 1 ) < max )
        {
            if ( being_init( beings, ( n_int )num, &beings[num], 0L, local_random ) != 0 )
            {
                being_erase( &beings[num] );
                break;
            }
            else
            {
                num++;
            }
        }
    }
    return num;
}


/**
 * Initialise the ape's variables and clear its brain
\ * @param mother Pointer to the mother
 * @param random_factor Random seed
 * @return 0
 */
n_int being_init( simulated_being *beings, n_int number,
                  simulated_being *local, simulated_being *mother,
                  n_byte2 *random_factor )
{
    n_int        loop = 0;
#ifdef EPISODIC_ON
    simulated_isocial *local_social_graph = being_social( local );
    simulated_iepisodic *local_episodic = being_episodic( local );

    if ( local_social_graph == 0L )
    {
        return SHOW_ERROR( "Social memory not available" );
    }
    if ( local_episodic == 0L )
    {
        return SHOW_ERROR( "Episodic memory not available" );
    }
#endif
    being_erase( local );

#ifdef BRAIN_ON
    {
        n_byte       *brain_memory = being_brain( local );
        if ( brain_memory != 0L )
        {
            memory_erase( brain_memory, DOUBLE_BRAIN );
        }
        else
        {
            return SHOW_ERROR( "Brain memory not available" );
        }
    }
#endif

    being_set_goal_none( local );

    /** Set learned preferences to 0.5 (no preference in either direction.
     This may seem like tabla rasa, but there are genetic biases */

    while ( loop < PREFERENCES )
    {
        local->changes.learned_preference[loop++] = 127;
    }

    immune_init( &( local->immune_system ), being_get_random( local ) );
    being_clear_attention( local );

    /** clear the generation numbers for mother and father */
    if ( mother )
    {
        local->constant.generation_max = mother->changes.child_generation_max + 1;
        local->constant.generation_min = mother->changes.child_generation_min + 1;
    }
    else
    {
        local->constant.generation_max = 0;
        local->constant.generation_min = 0;
    }
    local->changes.child_generation_max = 0;
    local->changes.child_generation_min = 0;

    /** initially seed the brain with instructions which
     are genetically biased */


    if ( random_factor )
    {
        being_set_random( local, random_factor );

        being_random3( local );
        being_random3( local );
    }
    else if ( mother )
    {
        ( void )being_random( mother );

        being_set_random( local, being_get_random( mother ) );

        being_random3( local );

        being_set_random1( local, being_get_random( mother )[0] );

        being_random3( local );

        being_set_random1( local, ( n_byte2 )land_time() );

        being_random3( local );
    }
    else
    {
        NA_ASSERT( random_factor, "Random factor not set" );
        NA_ASSERT( mother, "Mother not set" );
        return SHOW_ERROR( "No correct being interface provided" );
    }
#ifdef BRAINCODE_ON

    being_random3( local );

#ifdef EPISODIC_ON
    /** has no social connections initially */
    memory_erase( ( n_byte * )local_social_graph, sizeof( simulated_isocial )*SOCIAL_SIZE );

    loop = 0;
    while ( loop < EPISODIC_SIZE )
    {
        local_episodic[loop++].affect = EPISODIC_AFFECT_ZERO;
    }

    local_social_graph[0].relationship = RELATIONSHIP_SELF;
    loop = 0;
    while ( loop < SOCIAL_SIZE )
    {
        /** default type of entity */
        local_social_graph[loop].entity_type = ENTITY_BEING;
        /** friend_or_foe can be positive or negative,
         with SOCIAL_RESPECT_NORMAL as the zero point */
        local_social_graph[loop].friend_foe = SOCIAL_RESPECT_NORMAL;
        loop++;
    }
#endif

    /* TODO: Apply fitness function around the braincode generation */

    being_init_braincode( local, 0L, 0, BRAINCODE_INTERNAL );
    being_init_braincode( local, 0L, 0, BRAINCODE_EXTERNAL );

    /** randomly initialize registers */
    loop = 0;
    while ( loop < BRAINCODE_PSPACE_REGISTERS )
    {
        being_random3( local );
        local->braindata.braincode_register[loop++] = ( n_byte )being_random( local ) & 255;
    }

    /** initialize brainprobes */
    loop = 0;
    while ( loop < BRAINCODE_PROBES )
    {
        being_random3( local );
        if ( being_random( local ) & 1 )
        {
            local->braindata.brainprobe[loop].type = INPUT_SENSOR;
        }
        else
        {
            local->braindata.brainprobe[loop].type = OUTPUT_ACTUATOR;
        }
        local->braindata.brainprobe[loop].frequency = ( n_byte )1 + ( being_random( local ) % BRAINCODE_MAX_FREQUENCY );
        being_random3( local );
        local->braindata.brainprobe[loop].address = ( n_byte )being_random( local ) & 255;
        local->braindata.brainprobe[loop].position = ( n_byte )being_random( local ) & 255;
        being_random3( local );
        local->braindata.brainprobe[loop].offset = ( n_byte )being_random( local ) & 255;
        loop++;
    }
#endif

    being_facing_init( local );

    if ( random_factor )
    {
        n_byte2 location[2];
        n_vect2 location_vector;
        being_random3( local );

        being_initial_location( &location_vector, being_get_random( local ) );

        location[0] = ( n_byte2 )location_vector.x;
        location[1] = ( n_byte2 )location_vector.y;

        being_set_location( local, location );

        {
            n_genetics mother_genetics[CHROMOSOMES];
            n_genetics father_genetics[CHROMOSOMES];
            n_byte2    gene_random[2];

            being_random3( local );

            gene_random[0] = being_random( local );

            being_random3( local );
            being_random3( local );

            gene_random[1] = being_random( local );

            being_random_genetics( mother_genetics, gene_random, 0 );

            being_random3( local );

            gene_random[0] = being_random( local );
            being_random3( local );
            being_random3( local );
            being_random3( local );

            gene_random[1] = being_random( local );

            being_random_genetics( father_genetics, gene_random, 1 );
            being_random3( local );

            body_genetics( beings, number, being_genetics( local ), mother_genetics, father_genetics, gene_random );

            being_set_unique_name( beings, number, local, 0L, 0L );
        }
        local->delta.social_coord_x = local->delta.social_coord_nx =
                                          ( math_random( local->delta.random_seed ) & 32767 ) + 16384;
        local->delta.social_coord_y = local->delta.social_coord_ny =
                                          ( math_random( local->delta.random_seed ) & 32767 ) + 16384;

        local->constant.date_of_birth = 0;
    }
    else
    {
        being_set_location( local, being_location( mother ) );

        /** this is the same as equals */
        being_wander( local, being_facing( mother ) - being_facing( local ) );

        ( void ) being_random( local );
        local->delta.social_coord_x = local->delta.social_coord_nx = mother->delta.social_coord_x;
        local->delta.social_coord_y = local->delta.social_coord_ny = mother->delta.social_coord_y;

        genetics_set( being_genetics( local ), being_fetal_genetics( mother ) );

        /** ascribed social status */
        local->delta.honor = ( n_byte )being_honor( mother );

        being_set_unique_name( beings, number, local,
                               being_family_name( mother ),
                               mother->changes.father_name[1] );

        local->constant.date_of_birth = land_date();
    }

    being_living( local );

    if ( random_factor )
    {
        being_set_height( local, BIRTH_HEIGHT );

        GET_M( local ) = BIRTH_MASS;
    }
    else
    {
        /** produce an initial distribution of heights and masses*/
        being_random3( local );
        being_set_height( local, BIRTH_HEIGHT +
                          ( local->delta.random_seed[0] % ( BEING_MAX_HEIGHT - BIRTH_HEIGHT ) ) );

        GET_M( local ) = BIRTH_MASS +
                         ( local->delta.random_seed[1] % ( BEING_MAX_MASS_G - BIRTH_MASS ) );
    }

    local->delta.crowding = MIN_CROWDING;
#ifdef BRAIN_ON
    if ( being_brain( local ) )
    {
        /** These magic numbers were found in March 2001 -
         feel free to change them! */
        being_set_brainstates( local, 0, 171, 0, 146 );
        being_set_brainstates( local, 1, 86, 501, 73 );

    }
#endif
    return 0;
}

n_int being_move_energy( simulated_being *local_being, n_int *conductance )
{
    n_int      local_s  = being_speed( local_being );
    n_int      delta_e = 0;
    n_vect2    location_vector;
    n_vect2    facing_vector;
    n_genetics  *genetics = being_genetics( local_being );

    being_space( local_being, &location_vector );

    being_facing_vector( local_being, &facing_vector, 1 );

    if ( local_s > 0 )
    {
        n_byte2 location[2];
        vect2_d( &location_vector, &facing_vector, local_s, 512 );

        /* vector to n_byte2 may do incorrect wrap around MUST be improved */

        being_wrap( &location_vector );

        location[0] = ( n_byte2 )location_vector.x;
        location[1] = ( n_byte2 )location_vector.y;

        being_set_location( local_being, location );
#ifdef DEBUG_LACK_OF_MOVEMENT
        being_add_total_movement( local_being );
#endif
    }

    {
        n_int delta_z;
        n_int delta_energy;
        n_int local_z;
        n_vect2 slope_vector;

        land_vect2( &slope_vector, &local_z, &location_vector );

        delta_z = vect2_dot( &slope_vector, &facing_vector, 1, 96 );
        delta_energy = ( ( 512 - delta_z ) * local_s ) / 80;

        if ( WATER_TEST( local_z, land_tide_level() ) )
        {
            n_int insulation = 0;
            /** the more body fat, the less energy is lost whilst swimming */
            n_int fat_mass = GET_BODY_FAT( local_being );
            delta_energy = ( ( delta_energy * delta_energy ) >> 9 );
            if ( fat_mass > BEING_MAX_MASS_FAT_G )
            {
                fat_mass = BEING_MAX_MASS_FAT_G;
            }
            insulation = fat_mass * 5 / BEING_MAX_MASS_FAT_G;
            delta_e += ( delta_energy + 10 - insulation ) >> 3;
            *conductance = 4;
        }
        else
        {
            if ( delta_z > 0 )
            {
                /** going uphill */
                delta_energy += GENE_HILL_CLIMB( genetics );
            }

            delta_energy = ( ( delta_energy * delta_energy ) >> 9 );

            /* the more massive the more energy consumed when moving */
            delta_e += ( delta_energy + 4 + ( GET_M( local_being ) * 5 / BEING_MAX_MASS_G ) ) >> 2;
        }
    }
    return delta_e;
}


/* ./entity/body.c */
/****************************************************************

 body.c

 =============================================================



 ****************************************************************/

#include "entity.h"
#include "entity_internal.h"

/**
 * @brief One being gives something to another
 * @param local The being doing the giving
 * @param other The being receiving
 * @param carrying objects being carried
 */
static void body_action_give( simulated_being *local, simulated_being *other, n_byte2 carrying )
{
    n_byte hand = BODY_RIGHT_HAND;

    if ( carrying == 0 )
    {
        hand = BODY_LEFT_HAND;
        carrying = being_carried( local, hand );
    }
    if ( ( carrying != 0 ) &&
            ( ( being_carried( other, BODY_LEFT_HAND ) == 0 ) ||
              ( being_carried( other, BODY_RIGHT_HAND ) == 0 ) ) )
    {
        being_set_attention( local, ATTENTION_BODY, BODY_RIGHT_HAND );
        being_set_attention( other, ATTENTION_BODY, BODY_RIGHT_HAND );

        episodic_interaction( local, other, EVENT_GIVEN, EPISODIC_AFFECT_ZERO, carrying );
        episodic_interaction( other, local, EVENT_GIVEN_BY, AFFECT_RECEIVE, carrying );

        being_drop( local, hand );
        if ( being_carried( other, BODY_RIGHT_HAND ) == 0 )
        {
            being_take( other, BODY_RIGHT_HAND, carrying );
        }
        else
        {
            being_take( other, BODY_LEFT_HAND, carrying );
        }
    }
}

/**
 * @brief One being bashes another
 * @param local The being doing the bashing
 * @param other The being being bashed
 * @param carrying Objects being carried
 */
static void body_action_bash( simulated_being *local, simulated_being *other, n_byte2 carrying )
{
    n_byte hand = BODY_RIGHT_HAND;
    n_int  index, hit = 0;
    simulated_isocial *graph;

    if ( carrying == 0 )
    {
        hand = BODY_LEFT_HAND;
        carrying = being_carried( local, hand );
    }
    if ( carrying != 0 )
    {
        if ( ( carrying & INVENTORY_BRANCH ) || ( carrying & INVENTORY_ROCK ) )
        {
            being_set_attention( local, ATTENTION_BODY, BODY_RIGHT_HAND );
            being_set_attention( other, ATTENTION_BODY, BODY_BACK );
            index = get_simulated_isocial( other, local );
            if ( index > -1 )
            {
                graph = being_social( other );
                if ( !graph )
                {
                    return;
                }
                if ( graph[index].friend_foe > 1 )
                {
                    graph[index].friend_foe -= 2;
                }
            }
            if ( ( carrying & INVENTORY_ROCK ) && ( being_random( other ) > THROW_ACCURACY ) )
            {
                hit = 1;
                being_energy_delta( other, 0 - SQUABBLE_ENERGY_ROCK_HURL );
            }
            if ( ( carrying & INVENTORY_BRANCH ) && ( being_random( other ) > WHACK_ACCURACY ) )
            {
                hit = 1;
                being_energy_delta( other, 0 - SQUABBLE_ENERGY_BRANCH_WHACK );
            }
        }
        if ( carrying & INVENTORY_BRANCH )
        {
            if ( hit != 0 )
            {
                episodic_interaction( local, other, EVENT_WHACKED, EPISODIC_AFFECT_ZERO, 0 );
                episodic_interaction( other, local, EVENT_WHACKED_BY, AFFECT_WHACKED, 0 );
            }
        }
        if ( carrying & INVENTORY_ROCK )
        {
            episodic_interaction( local, other, EVENT_HURLED, EPISODIC_AFFECT_ZERO, 0 );
            if ( hit != 0 )
            {
                episodic_interaction( other, local, EVENT_HURLED_BY, AFFECT_HURL, 0 );
            }
        }
    }

}

/**
 * @brief Remember interaction between two beings
 * @param local Pointer to the first being
 * @param other Pointer to the second being
 * @param local_attention Focus of attention for the first being
 * @param other_attention Focus of attention for the second being
 * @param kind The type of event
 */
static void body_action_interactive( simulated_being *local, simulated_being *other,
                                     n_byte local_attention, n_byte other_attention, n_byte kind )
{
    being_set_attention( local, ATTENTION_BODY, local_attention );
    being_set_attention( other, ATTENTION_BODY, other_attention );
    episodic_interaction( local, other, kind, EPISODIC_AFFECT_ZERO, 0 );
    episodic_interaction( other, local, kind + 1, EPISODIC_AFFECT_ZERO, 0 );
}

/*** This block should also be the same function ***/

static void body_action_interactive_change( simulated_being *local, simulated_being *other,
        n_byte local_attention, n_byte other_attention, n_byte kind, n_byte positive, AFFECT_TYPE affect )
{
    n_int index;
    being_set_attention( local, ATTENTION_BODY, local_attention );
    being_set_attention( other, ATTENTION_BODY, other_attention );
    index = get_simulated_isocial( other, local );
    if ( index > -1 )
    {
        simulated_isocial *graph = being_social( other );
        if ( !graph )
        {
            return;
        }
        if ( positive )
        {
            if ( graph[index].friend_foe < 255 )
            {
                graph[index].friend_foe++;
            }
        }
        else
        {
            if ( graph[index].friend_foe > 0 )
            {
                graph[index].friend_foe--;
            }
        }
    }

    episodic_interaction( local, other, kind, EPISODIC_AFFECT_ZERO, 0 );
    episodic_interaction( other, local, kind + 1, affect, 0 );
}

/**
 * @brief Carry an object in a hand
 * @param local Pointer to the being
 * @param carrying Objects which are carried
 * @param hand left or right hand
 * @param kind The kind of object
 */
static void body_action_hand_object( simulated_being *local, n_byte2 carrying, n_byte hand, n_byte kind )
{
    if ( carrying == 0 )
    {
        hand = BODY_LEFT_HAND;
        carrying = being_carried( local, hand );
    }
#ifdef EPISODIC_ON
    if ( carrying != 0 )
    {
        if ( carrying & INVENTORY_BRANCH )
        {
            episodic_self( local, kind, EPISODIC_AFFECT_ZERO, INVENTORY_BRANCH );
        }
        else
        {
            if ( carrying & INVENTORY_TWIG )
            {
                episodic_self( local, kind, EPISODIC_AFFECT_ZERO, INVENTORY_TWIG );
            }
            else
            {
                if ( carrying & INVENTORY_SPEAR )
                {
                    episodic_self( local, kind, EPISODIC_AFFECT_ZERO, INVENTORY_SPEAR );
                }
            }
        }
    }
#endif
}

/**
 * @brief Performs a jabbing action
 * @param local Pointer to the being
 * @param carrying Objects which are carried
 * @param hand Left or right hand
 */
static void body_action_jab( simulated_being *local, n_byte2 carrying, n_byte hand )
{
    inventory_type carrying2 = being_carried( local, BODY_LEFT_HAND );
    if ( ( carrying & INVENTORY_SPEAR ) ||
            ( carrying2 & INVENTORY_SPEAR ) )
    {
        n_int az;
        n_vect2 location_vector, facing_vector, slope_vector;

        being_space( local, &location_vector );

        being_facing_vector( local, &facing_vector, 4 );
        land_vect2( &slope_vector, &az, &location_vector );

        if ( ( az > WATER_MAP ) && ( az < TIDE_MAX ) )
        {
            /* some probability of spearing a fish */
            if ( being_random( local ) < FISHING_PROB )
            {
                /* carry fish */
                if ( carrying & INVENTORY_SPEAR )
                {
                    being_take( local, BODY_LEFT_HAND, INVENTORY_FISH );
                }
                else
                {
                    being_take( local, hand, INVENTORY_FISH );
                }
#ifdef EPISODIC_ON
                episodic_self( local, EVENT_FISH, AFFECT_FISH, 0 );
#endif
            }
        }
    }
}

/**
 * @brief Bashes one object on another.  Both objects must be carried.
 * @param local Pointer to the being
 * @param carrying Things which are carried
 * @param hand left or right hand
 */
static void body_action_bash_objects( simulated_being *local, n_byte2 carrying, n_byte hand )
{
    inventory_type carrying2 = being_carried( local, BODY_LEFT_HAND );
    if ( ( carrying & INVENTORY_ROCK ) && ( carrying2 & INVENTORY_ROCK ) )
    {
        /** bash two rocks to make a scraper */
        being_drop( local, hand );
        being_take( local, hand, INVENTORY_SCRAPER );
    }
    if ( ( ( carrying & INVENTORY_ROCK ) && ( carrying2 & INVENTORY_NUT ) ) ||
            ( ( carrying & INVENTORY_NUT ) && ( carrying2 & INVENTORY_ROCK ) ) )
    {
        /** bash nut with a rock */
        if ( carrying & INVENTORY_NUT )
        {
            being_drop( local, hand );
            being_take( local, hand, INVENTORY_NUT_CRACKED );
        }
        else
        {
            being_drop( local, BODY_LEFT_HAND );
            being_take( local, BODY_LEFT_HAND, INVENTORY_NUT_CRACKED );
        }
    }
    if ( ( ( carrying & INVENTORY_BRANCH ) && ( carrying2 & INVENTORY_SCRAPER ) ) ||
            ( ( carrying & INVENTORY_SCRAPER ) && ( carrying2 & INVENTORY_BRANCH ) ) )
    {
        /** use a scraper to make a spear */
        if ( carrying & INVENTORY_BRANCH )
        {
            being_drop( local, hand );
            being_take( local, hand, INVENTORY_SPEAR );
        }
        else
        {
            being_drop( local, BODY_LEFT_HAND );
            being_take( local, BODY_LEFT_HAND, INVENTORY_SPEAR );
        }
    }
    if ( ( ( carrying & INVENTORY_BRANCH ) && ( carrying2 & INVENTORY_NUT ) ) ||
            ( ( carrying & INVENTORY_NUT ) && ( carrying2 & INVENTORY_BRANCH ) ) )
    {
        /** whack nut with a branch */
        if ( carrying & INVENTORY_NUT )
        {
            being_drop( local, hand );
            being_take( local, hand, INVENTORY_NUT_CRACKED );
        }
        else
        {
            being_drop( local, BODY_LEFT_HAND );
            being_take( local, BODY_LEFT_HAND, INVENTORY_NUT_CRACKED );
        }
    }
}

/**
 * @brief A being chews on something
 * @param local Pointer to the being
 * @param carrying Things which are carried
 * @param hand left or right hand
 */

static void body_action_chew( simulated_being *local, n_byte2 carrying, n_byte hand )
{
    if ( !( ( carrying & INVENTORY_GRASS ) ||
            ( carrying & INVENTORY_TWIG ) ||
            ( carrying & INVENTORY_FISH ) ||
            ( carrying & INVENTORY_BIRD_EGGS ) ||
            ( carrying & INVENTORY_LIZARD_EGGS ) ||
            ( carrying & INVENTORY_NUT_CRACKED ) ) )
    {
        hand = BODY_LEFT_HAND;
        carrying = being_carried( local, hand );
    }
    if ( ( carrying & INVENTORY_GRASS ) ||
            ( carrying & INVENTORY_TWIG ) ||
            ( carrying & INVENTORY_FISH ) ||
            ( carrying & INVENTORY_BIRD_EGGS ) ||
            ( carrying & INVENTORY_LIZARD_EGGS ) ||
            ( carrying & INVENTORY_NUT_CRACKED ) )
    {
        if ( hand == BODY_RIGHT_HAND )
        {
            carrying |= 1;
        }
#ifdef EPISODIC_ON
        episodic_self( local, EVENT_CHEW, EPISODIC_AFFECT_ZERO, carrying );
#endif
    }
    if ( carrying & INVENTORY_GRASS )
    {
        /** consume grass */
        being_energy_delta( local, food_absorption( local, ENERGY_GRASS, FOOD_VEGETABLE ) );
        being_drop( local, hand );
    }
    else
    {
        if ( carrying & INVENTORY_FISH )
        {
            /** consume fish */
            being_energy_delta( local, food_absorption( local, ENERGY_FISH, FOOD_SHELLFISH ) );
            being_drop( local, hand );
        }
        else
        {
            if ( carrying & INVENTORY_NUT_CRACKED )
            {
                /** consume nut */
                being_energy_delta( local, food_absorption( local, ENERGY_NUT, FOOD_VEGETABLE ) );
                being_drop( local, hand );
            }
            else
            {
                if ( carrying & INVENTORY_BIRD_EGGS )
                {
                    /** consume nut */
                    being_energy_delta( local, food_absorption( local, ENERGY_BIRD_EGGS, FOOD_BIRD_EGGS ) );
                    being_drop( local, hand );
                }
                else
                {
                    if ( carrying & INVENTORY_LIZARD_EGGS )
                    {
                        /** consume nut */
                        being_energy_delta( local, food_absorption( local, ENERGY_LIZARD_EGGS, FOOD_LIZARD_EGGS ) );
                        being_drop( local, hand );
                    }
                }
            }
        }
    }
}
/**
 * @brief If anything is being carried in a hand this swaps it between hands
 * @param local Pointer to the being
 * @param carrying Things which are carried
 * @param hand left or right hand
 */
static void body_action_swap_hands( simulated_being *local, n_byte2 carrying, n_byte hand )
{
    if ( ( carrying != 0 ) && ( being_carried( local, BODY_LEFT_HAND ) == 0 ) )
    {
        being_drop( local, hand );
        being_take( local, BODY_LEFT_HAND, carrying );
    }
    else
    {
        if ( ( carrying == 0 ) && ( being_carried( local, BODY_LEFT_HAND ) != 0 ) )
        {
            carrying = being_carried( local, BODY_LEFT_HAND );
            being_drop( local, BODY_LEFT_HAND );
            being_take( local, hand, carrying );
        }
    }
}

/**
 * @brief A being drops something
 * @param local Pointer to the being
 * @param carrying Things which are carried
 * @param hand left or right hand
 */
static void body_action_drop( simulated_being *local, n_byte2 carrying, n_byte hand )
{
    if ( carrying == 0 )
    {
        hand = BODY_LEFT_HAND;
        carrying = being_carried( local, hand );
    }
    if ( carrying != 0 )
    {
        being_drop( local, hand );
#ifdef EPISODIC_ON
        episodic_self( local, EVENT_DROP, EPISODIC_AFFECT_ZERO, carrying );
#endif
    }
}

/**
 * @brief A being picks something up
 * @param local Pointer to the being
 * @param carrying Things being carried by the being
 * @param hand left or right hand
 */
static void body_action_pickup( simulated_being *local, n_byte2 carrying, n_byte hand )
{
    if ( ( carrying != 0 ) && ( !being_posture_under( local, POSTURE_CROUCHING ) ) )
    {
        hand = BODY_LEFT_HAND;
        carrying = being_carried( local, hand );
    }
    if ( carrying == 0 )
    {
        n_int az;
        n_vect2 location_vector, facing_vector, slope_vector;
        being_space( local, &location_vector );
        being_facing_vector( local, &facing_vector, 4 );
        land_vect2( &slope_vector, &az, &location_vector );

        if ( az > WATER_MAP )
        {
            if ( az > TIDE_MAX )
            {
                /* TODO handle this logic centrally */

                n_int grass, trees, bush;
                food_values( being_location_x( local ), being_location_y( local ), &grass, &trees, &bush );


                if ( ( grass > bush ) && ( grass > trees ) )
                {
                    being_take( local, hand, INVENTORY_GRASS );
#ifdef EPISODIC_ON
                    episodic_self( local, EVENT_PICKUP, EPISODIC_AFFECT_ZERO, INVENTORY_GRASS );
#endif
                }
                if ( ( trees > grass ) && ( trees > bush ) )
                {
                    if ( being_posture_under( local, POSTURE_UPRIGHT ) )
                    {
                        being_take( local, hand, INVENTORY_BRANCH );
#ifdef EPISODIC_ON
                        episodic_self( local, EVENT_PICKUP, EPISODIC_AFFECT_ZERO, INVENTORY_BRANCH );
#endif
                    }
                    else
                    {
                        being_take( local, hand, INVENTORY_NUT );
#ifdef EPISODIC_ON
                        episodic_self( local, EVENT_PICKUP, EPISODIC_AFFECT_ZERO, INVENTORY_NUT );
#endif
                    }
                }
                if ( ( bush > grass ) && ( bush > trees ) )
                {
                    being_take( local, hand, INVENTORY_TWIG );
#ifdef EPISODIC_ON
                    episodic_self( local, EVENT_PICKUP, EPISODIC_AFFECT_ZERO, INVENTORY_TWIG );
#endif
                }
            }
            else
            {
                being_take( local, hand, INVENTORY_ROCK );
#ifdef EPISODIC_ON
                episodic_self( local, EVENT_PICKUP, EPISODIC_AFFECT_ZERO, INVENTORY_ROCK );
#endif
            }
        }
    }
}

/**
 * @brief Performs a given action
 * @param local Pointer to the being performing the action
 * @param other Pointer to another being involved in the action
 * @param action The type of action
 */
void social_action(
    simulated_being *local,
    simulated_being *other,
    n_byte action )
{
    n_byte2 carrying;
    n_byte hand = BODY_RIGHT_HAND;

    if ( local->delta.awake == FULLY_ASLEEP )
    {
        return;
    }

    carrying = being_carried( local, hand );
    if ( other == 0L )
    {
        /** individual action */
        switch ( action % INDIVIDUAL_ACTIONS )
        {
        case ACTION_JAB:
            body_action_jab( local, carrying, hand );
            break;
        case ACTION_BASH_OBJECTS:
            body_action_bash_objects( local, carrying, hand );
            break;
        case ACTION_CHEW:
            body_action_chew( local, carrying, hand );
            break;
        case ACTION_BRANDISH:
            body_action_hand_object( local, carrying, hand, EVENT_BRANDISH );
            break;
        case ACTION_DRAG:
            body_action_hand_object( local, carrying, hand, EVENT_DRAG );
            break;
        case ACTION_SWAP_HANDS:
            body_action_swap_hands( local, carrying, hand );
            break;
        case ACTION_DROP:
            body_action_drop( local, carrying, hand );
            break;
        case ACTION_PICKUP:
            body_action_pickup( local, carrying, hand );
            break;
        }
    }
    else
    {
        /** social action */
        switch ( action % SOCIAL_ACTIONS )
        {
        case ACTION_PROD:
            body_action_interactive_change( local, other, BODY_RIGHT_HAND, BODY_FRONT,
                                            EVENT_PRODDED, 0, AFFECT_PRODDED );
            break;
        case ACTION_HUG:
            body_action_interactive_change( local, other, BODY_FRONT, BODY_FRONT,
                                            EVENT_HUGGED, 1, AFFECT_HUGGED );
            break;
        case ACTION_SMILE:
            body_action_interactive_change( local, other, BODY_TEETH, BODY_TEETH,
                                            EVENT_SMILED, 1, AFFECT_SMILED );
            break;
        case ACTION_GLOWER:
            body_action_interactive_change( local, other, BODY_HEAD, BODY_HEAD,
                                            EVENT_GLOWERED, 0, AFFECT_GLOWER );
            break;
        case ACTION_TICKLE:
            body_action_interactive( local, other, BODY_RIGHT_HAND, BODY_FRONT, EVENT_TICKLED );
            break;
        case ACTION_POINT:
            body_action_interactive( local, other, BODY_RIGHT_HAND, BODY_RIGHT_HAND, EVENT_POINT );
            break;
        case ACTION_PAT:
            body_action_interactive( local, other, BODY_RIGHT_HAND, BODY_BACK, EVENT_PATTED );
            break;
        case ACTION_BASH:
            body_action_bash( local, other, carrying );
            break;
        case ACTION_GIVE:
            body_action_give( local, other, carrying );
            break;
        }
    }
}

/**
 * @brief Compares two genetics and returns 1 if they are the same
 * @param genetics_a First genetics
 * @param genetics_b Second genetics
 * @return 1 if the two genetics are the same, 0 otherwise
 */
n_int genetics_compare( n_genetics *genetics_a, n_genetics *genetics_b )
{
    n_int loop = 0;

    while ( loop < CHROMOSOMES )
    {
        if ( genetics_a[loop] != genetics_b[loop] )
        {
            return 0;
        }
        loop++;
    }
    return 1;
}

/**
 * @brief Sets genetics A to be the same as genetics B
 * @param genetics_a The destination genetics
 * @param genetics_b The source genetics
 */
void genetics_set( n_genetics *genetics_a, n_genetics *genetics_b )
{
    n_int loop = 0;
    while ( loop < CHROMOSOMES )
    {
        genetics_a[loop] = genetics_b[loop];
        loop++;
    }
}

/**
 * @brief Creates a blank genome
 * @param genetics_a The genetics to be cleared
 */
void genetics_zero( n_genetics *genetics_a )
{
    n_int loop = 0;
    while ( loop < CHROMOSOMES )
    {
        genetics_a[loop] = 0;
        loop++;
    }
}

/**
 * @brief Returns 1 if the given genetics are unique within the population
 * @param local Pointer to the simulation object
 * @param genetics The new genetics to be compared
 * @return 1 if the given genetics are unique in the population
 */
static n_int genetics_unique( simulated_being *local, n_int number, n_genetics *genetics )
{
    n_int         loop = 0;
    if ( number == 0 )
    {
        return 1;
    }
    while ( loop < number )
    {
        simulated_being	 *local_being = &( local[loop] );
        if ( genetics_compare( being_genetics( local_being ), genetics ) )
        {
            return 0;
        }
        loop++;
    }
    return 1;
}

/**
 * @brief Returns the 2 bit gene value from the given point within a diploid chromosome.
   This includes mutations
 * @param chromosome The chromosome as a 32 bit value.  Lower 16 bits are from father, upper 16 bits from mother
 * @param point The index within the chromosome
 * @param mutation_prob The probability of mutation
 * @param local Random number generator seed
 * @return 2 bit gene value
 */
static n_int genetics_child_gene( n_genetics chromosome, n_int point, n_byte2 mutation_prob, n_byte2 *local )
{
    n_byte2 mutation_type;
    n_int child_gene = 0;

    math_random3( local );
    if ( math_random( local ) < mutation_prob )
    {
        mutation_type = ( math_random( local ) & 7 );
        switch ( mutation_type )
        {
        /** mutation on the maternal chromosome */
        case MUTATION_MATERNAL:
            child_gene = DIPLOID(
                             ( math_random( local ) & 3 ),
                             ( ( CHROMOSOME_FROM_FATHER( chromosome ) >> point ) & 3 ) );
            break;
        /** mutation on the paternal chromosome */
        case MUTATION_PATERNAL:
            child_gene = DIPLOID(
                             ( ( CHROMOSOME_FROM_MOTHER( chromosome ) >> point ) & 3 ),
                             ( math_random( local ) & 3 ) );
            break;
        /** duplicate of the maternal gene on both sides */
        case MUTATION_MATERNAL_DUPLICATE:
            child_gene = DIPLOID(
                             ( ( CHROMOSOME_FROM_MOTHER( chromosome ) >> point ) & 3 ),
                             ( ( CHROMOSOME_FROM_MOTHER( chromosome ) >> point ) & 3 ) );
            break;
        /** duplicate of the paternal gene on both sides */
        case MUTATION_PATERNAL_DUPLICATE:
            child_gene = DIPLOID(
                             ( ( CHROMOSOME_FROM_FATHER( chromosome ) >> point ) & 3 ),
                             ( ( CHROMOSOME_FROM_FATHER( chromosome ) >> point ) & 3 ) );
            break;
        default:
            math_random3( local );

            child_gene = DIPLOID(
                             ( math_random( local ) & 3 ), ( math_random( local ) & 3 ) );
        }
    }
    else
    {
        /** normal gene.  What grandparent genes get into the current generation is randomly chosen */
        if ( ( math_random( local ) & 1 ) != 0 )
        {
            child_gene = DIPLOID(
                             ( ( CHROMOSOME_FROM_MOTHER( chromosome ) >> point ) & 3 ),
                             ( ( CHROMOSOME_FROM_FATHER( chromosome ) >> point ) & 3 ) );
        }
        else
        {
            child_gene = DIPLOID(
                             ( ( CHROMOSOME_FROM_FATHER( chromosome ) >> point ) & 3 ),
                             ( ( CHROMOSOME_FROM_MOTHER( chromosome ) >> point ) & 3 ) );
        }
    }
    return child_gene;
}

/**
 * @brief Performs crossover and mutation
 * @param mother Chromosome of the mother (first 16 bits from maternal grandfather, second 16 bits from maternal grandmother)
 * @param father Chromosome of the father (first 16 bits from paternal grandfather, second 16 bits from paternal grandmother)
 * @param local Random number generator seed
 * @return Child chromosome
 */
static n_genetics	genetics_crossover( n_genetics mother, n_genetics father, n_byte2 *local )
{
    n_int loop = 0;
    n_genetics result = 0;
    n_int point, point2;
    n_int deletion_point = 16;
    n_byte2 prob;
    n_genetics parent;

    /** randomly select a crossover point */
    n_int crossover_point = ( math_random( local ) >> 13 ) << 1;

    /** gene insertion/deletion */
    if ( math_random( local ) < MUTATION_DELETION_PROB )
    {
        deletion_point = ( math_random( local ) >> 13 ) << 1;
    }

    point = point2 = crossover_point - 8;
    /** for every 2 bit gene in the 16 bit chromosome */
    while ( loop < 16 )
    {
        if ( loop == deletion_point )
        {
            point2 -= 2;
        }

        /** equal genetic contribution from mother and father */
        if ( point2 < 0 )
        {
            point2 += 16;
        }
        else
        {
            if ( point2 > 15 )
            {
                point2 -= 16;
            }
        }

        if ( loop < 8 )
        {
            parent = father;
            /** higher mutation probability in males */
            prob = MUTATION_CROSSOVER_PROB * 50;
        }
        else
        {
            parent = mother;
            prob = MUTATION_CROSSOVER_PROB;
        }

        result |= ( genetics_child_gene( parent, point2, prob, local ) << point );
        loop += 2;
        point += 2;
        point2 += 2;
    }
    return result;
}

/**
 * @brief Mutates a single chromosome, without crossover
 * @param chromosome The chromosome to be mutated
 * @param local Random number generator seed
 * @return The mutated chromosome
 */
static n_genetics	genetics_mutate( n_genetics chromosome, n_byte2 *local )
{
    n_genetics result = 0;
    n_int point = 0;
    n_int loop = 0;
    n_int deletion_point = 16;

    /** gene insertion/deletion */
    if ( math_random( local ) < MUTATION_DELETION_PROB )
    {
        deletion_point = ( math_random( local ) >> 13 ) << 1;
    }

    /** for every 2 bit gene in the 16 bit chromosome */
    point = 0;
    while ( loop < 16 )
    {
        if ( loop == deletion_point )
        {
            point -= 2;
            if ( point < 0 )
            {
                point += 16;
            }
        }
        if ( point > 15 )
        {
            point -= 16;
        }

        result |= ( genetics_child_gene( chromosome, point, MUTATION_CROSSOVER_PROB, local ) << point );
        loop += 2;
        point += 2;
    }
    return result;
}

/**
 * @brief Transposes segments of the genome between chromosomes or within the same chromosome.
 This is the main cause of variation between siblings.
 * @param genetics Pointer to the genetics
 * @param local Random number generator seed
 */
static void genetics_transpose( n_genetics *genetics, n_byte2 *local )
{
    math_random3( local );

    if ( math_random( local ) < MUTATION_TRANSPOSE_PROB )
    {
        /** number of bits to transpose */
        /** chromosome numbers */
        /** locations within the chromosomes */
        n_byte2 local_random0 = math_random( local );
        n_byte2 local_random1 = math_random( local );

        n_byte source_offset = ( local_random0 >> 8 ) & 31;
        n_byte dest_offset   = local_random1 & 31;
        /** whether to invert the sequence */
        n_byte inversion     = ( local_random0 >> 13 ) & 1;
        n_byte source_ch     = ( local_random1 >> 5 ) % CHROMOSOMES;
        n_byte dest_ch       = ( local_random1 >> 7 ) % CHROMOSOMES;
        n_int  ctr1          = source_offset;
        n_byte p             = 0;
        math_random3( local );

        while ( p < ( math_random( local ) & 15 ) )
        {
            n_int ctr2;
            ctr1 = ( ctr1 & 31 );

            if ( inversion == 0 )
            {
                ctr2 = ( n_int )( dest_offset + p );
            }
            else
            {
                /** inverted sequence */
                ctr2 = ( n_int )dest_offset - p + 32;
            }
            ctr2 = ( ctr2 & 31 );
            /** clear destination bit */
            if ( ( genetics[dest_ch] & ( 1 << ctr2 ) ) != 0 )
            {
                genetics[dest_ch] ^= ( 1 << ctr2 );
            }
            /** set destination bit */
            if ( ( genetics[source_ch] & ( 1 << ctr1 ) ) != 0 )
            {
                genetics[dest_ch] |= ( 1 << ctr2 );
            }
            p++;
            ctr1++;
        }
    }
}


void body_genetics( simulated_being *beings, n_int number, n_genetics *genetics, n_genetics *mother_genetics, n_genetics *father_genetics, n_byte2 *local )
{
    n_int ch;
    n_byte sex = 2;
    math_random3( local );
    sex |= ( math_random( local ) & 1 );
    do
    {
        math_random3( local );

        /** crossover and mutation */
        for ( ch = 0; ch < CHROMOSOMES; ch++ )
        {
            if ( ch != CHROMOSOME_Y )
            {
                genetics[ch] = genetics_crossover( mother_genetics[ch], father_genetics[ch], local );
            }
        }

        /** Y chromosome does not undergo crossover and passes from father to son */
        if ( sex != SEX_FEMALE )
        {
            genetics[CHROMOSOME_Y] = genetics_mutate( father_genetics[CHROMOSOME_Y], local );
        }
        else
        {
            genetics[CHROMOSOME_Y] = genetics_mutate( mother_genetics[CHROMOSOME_Y], local );
        }
        /** transpose genes between chromosomes */
        genetics_transpose( genetics, local );
        /** align the sex genetics */
        genetics[CHROMOSOME_Y] &= ~1;
        genetics[CHROMOSOME_Y] |= sex;
    }
    while ( genetics_unique( beings, number, genetics ) == 0 );
}

/**
 * @brief Returns a string of letters representing the genome
 * @param maternal Show either the maternal or paternal side of each chromosome
 * @param genome The genome to be shown
 * @param genome_str The returned string
 */
void body_genome( n_byte maternal, n_genetics *genome, n_byte *genome_str )
{
    n_byte string_point = 0;
    n_int ch, value;

    n_byte nucleotide[] = { 'A', 'T', 'C', 'G' };
    /** for every chromosome */
    for ( ch = 0; ch < CHROMOSOMES; ch++ )
    {
        /** for each 2 bit gene in the chromosome.
            Each chromosome is 16 bits long with the full
            32 bit value containing the chromosome pair */
        n_byte gene_point = 0;
        while ( gene_point < 16 )
        {
            if ( maternal != 0 )
            {
                /** the maternal part of the diplod */
                value = ( CHROMOSOME_FROM_MOTHER( genome[ch] ) >> gene_point ) & 3;
            }
            else
            {
                /** the paternal part of the diploid */
                value = ( CHROMOSOME_FROM_FATHER( genome[ch] ) >> gene_point ) & 3;
            }
            genome_str[string_point++] = nucleotide[value];
            gene_point += 2;
        }
    }
    genome_str[string_point] = 0;
}



/* ./entity/brain.c */
/****************************************************************

 brain.c

 =============================================================



 ****************************************************************/

#include "entity.h"
#include "entity_internal.h"

#include <stdio.h>

/* typical minimum spacing between MVB instructions */
#define BRAINCODE_MIN_MVB_SPACING          2

#define BRAINCODE_CONSTANT0_BIT		  (64)
#define BRAINCODE_CONSTANT1_BIT		  (128)

#define BRAINCODE_DATA_START          BRAINCODE_DAT0
#define BRAINCODE_DATA_NUMBER         (1 + BRAINCODE_DAT1 - BRAINCODE_DATA_START)

#define BRAINCODE_OPERATORS_START     BRAINCODE_ADD
#define BRAINCODE_OPERATORS_NUMBER    (1 + BRAINCODE_LTP - BRAINCODE_OPERATORS_START)

#define BRAINCODE_CONDITIONALS_START  BRAINCODE_JMZ
#define BRAINCODE_CONDITIONALS_NUMBER (1 + BRAINCODE_SLT - BRAINCODE_CONDITIONALS_START)

#define BRAINCODE_SENSORS_START       BRAINCODE_SEN
#define BRAINCODE_SENSORS_NUMBER      (1 + BRAINCODE_SEN3 - BRAINCODE_SENSORS_START)

#define BRAINCODE_ACTUATORS_START     BRAINCODE_ACT
#define BRAINCODE_ACTUATORS_NUMBER    (1 + BRAINCODE_ANE - BRAINCODE_ACTUATORS_START)

#define BRAINCODE_INSTRUCTION(braincode,i) ((braincode[i] & (BRAINCODE_CONSTANT0_BIT-1)) % BRAINCODE_INSTRUCTIONS)
#define BRAINCODE_CONSTANT0(braincode,i)    (braincode[i] & BRAINCODE_CONSTANT0_BIT)
#define BRAINCODE_CONSTANT1(braincode,i)    (braincode[i] & BRAINCODE_CONSTANT1_BIT)
#define BRAINCODE_VALUE(braincode,i,n)      (braincode[(i+1+n) & (BRAINCODE_SIZE - 1)])

/*	Brain definitions */

#define B_SIZE		(32768)
#define B_WR        (B_SIZE - 1)
#define	F_X			(1)
#define	F_Y			(32)
#define	F_Z			(1024)
#define	B_Z			(B_SIZE - F_Z)
#define	B_Y			(B_SIZE - F_Y)
#define	B_X			(B_SIZE - F_X)

/*
 *	The basic brain formula is;
 *	   b(t+1) = a*l + b(t)*m + (b(t)-b(t-1))*n;
 *
 *	The waking mind works differently to the sleeping mind. This is quantified
 *	with two distinct but similar equations. There are two versions for the awake
 *	and asleep states, in this function it is simplified to;
 *	   b(t+1) = a*l_a + b(t)*l_b - b(t-1)*l_c;
 *
 *	   where, l_a = l, l_b = m+n, l_c = n
 */

#define	B_FN(ave, bra, obra) ((ave+bra-obra)>>10)

/** positive and negative, lower and upper halves */
#define B_P_LH (br[loc+F_Z]+br[loc+F_Y]+br[loc+F_X])
#define	B_P_UH (br[loc-F_X]+br[loc-F_Y]+br[loc-F_Z])
#define	B_N_LH (br[(loc+F_X)&B_WR]+br[(loc+F_Y)&B_WR]+br[(loc+F_Z)&B_WR])
#define	B_N_UH (br[(loc+B_Z)&B_WR]+br[(loc+B_Y)&B_WR]+br[(loc+B_X)&B_WR])

/**
 * @brief Updates the brain
 * @param local Pointer to the brain array
 * @param constants Array containing brain constants
 */
void brain_cycle( n_byte *local, n_byte2 *constants )
{
    n_byte br[B_SIZE];
    n_byte  *bract = local, *obr = &local[B_SIZE];
    n_int  l_a = constants[0];
    n_int  l_c = constants[2];
    n_int  l_b = constants[1] + l_c;
    n_int  loc = 0;
    n_int  average;
    n_int  obr_tmp;
    n_int  br_tmp;
    n_int  count = F_Z;

    memory_copy( bract, br, B_SIZE );

    do
    {
        average = ( B_P_LH + B_N_UH );
        br_tmp = br[loc];
        obr_tmp = obr[loc];

        average *= l_a;
        obr_tmp *= l_c;

        br_tmp *= l_b;
        br_tmp -= obr_tmp;
        average += br_tmp;

        br[loc++] = ( n_byte )( average >> 10 );
        count--;

    }
    while ( count );
    count = B_Z - F_Z;
    do
    {
        average =  br[loc - F_Z];
        average += br[loc - F_Y];
        average += br[loc - F_X];

        br_tmp = br[loc];

        average += br[loc + F_X];
        average += br[loc + F_Y];
        average += br[loc + F_Z];

        obr_tmp = obr[loc];
        average *= l_a;
        obr_tmp *= l_c;
        br_tmp *= l_b;
        br_tmp -= obr_tmp;
        average += br_tmp;
        br[loc++] = ( n_byte )( average >> 10 );
        count--;
    }
    while ( count );
    count = F_Z;
    do
    {
        average = B_P_UH;
        br_tmp = br[loc];
        average += B_N_LH;
        obr_tmp = obr[loc];

        average *= l_a;
        obr_tmp *= l_c;
        br_tmp *= l_b;
        br_tmp -= obr_tmp;
        average += br_tmp;

        br[loc++] = ( n_byte )( average >> 10 );
        count--;
    }
    while ( count );

    memory_copy( bract, obr, B_SIZE );
    memory_copy( br, bract, B_SIZE );

}

/**     "XXX_#NNN_#NNN"*/
/**     "0123456789012"*/


enum BC_FORMAT
{
    BC_FORMAT_A = 0,
    BC_FORMAT_C,
    BC_FORMAT_E,
    BC_FORMAT_F,
    BC_FORMAT_G,
    BC_FORMAT_H
};
const n_string braincode_mnemonic[BRAINCODE_INSTRUCTIONS] =
{
    /** data */
    "DAT0",
    "DAT1",

    /** operators */
    "ADD ",
    "SUB ",
    "MUL ",
    "DIV ",
    "MOD ",
    "MVB ",
    "MOV ",
    "JMP ",
    "CTR ",
    "SWP ",
    "INV ",
    "STP ",
    "LTP ",

    /** conditionals */
    "JMZ ",
    "JMN ",
    "DJN ",
    "AND ",
    "OR  ",
    "SEQ ",
    "SNE ",
    "SLT ",

    /** sensors */
    "SEN ",
    "SEN2",
    "SEN3",

    /** actuators */
    "ACT ",
    "ACT2",
    "ACT3",
    "ANE "
};

/**
 * @brief Returns the type of formatting of a three byte instruction
 * @param instruction The instruction type
 * @param command Whether the subsequent two bytes are constants or variables
 * @param value0 The first argument
 * @param value1 The second argument
 * @return The format type used to display a three byte instruction
 */
static enum BC_FORMAT brain_format( n_byte instruction, n_byte command, n_byte value0, n_byte value1 )
{
    n_byte is_constant0 = ( ( command & BRAINCODE_CONSTANT0_BIT ) != 0 );
    n_byte is_constant1 = ( ( command & BRAINCODE_CONSTANT1_BIT ) != 0 );

    switch ( instruction )
    {
    case BRAINCODE_AND:
    case BRAINCODE_OR:
    case BRAINCODE_MOV:
    case BRAINCODE_ADD:
    case BRAINCODE_SUB:
    case BRAINCODE_MUL:
    case BRAINCODE_MOD:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            return BC_FORMAT_A;
        }
        return BC_FORMAT_C;
        break;
    case BRAINCODE_JMZ:
    case BRAINCODE_JMN:
    case BRAINCODE_DJN:
        return BC_FORMAT_E;
        break;
    case BRAINCODE_SEQ:
    case BRAINCODE_SNE:
    case BRAINCODE_SLT:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            return BC_FORMAT_A;
        }
        return BC_FORMAT_F;
        break;
    case BRAINCODE_DAT0:
    case BRAINCODE_DAT1:
    case BRAINCODE_JMP:
        return BC_FORMAT_C;
        break;
    case BRAINCODE_INV:
        if ( is_constant0 )
        {
            return BC_FORMAT_G;
        }

        return BC_FORMAT_H;

        break;
    case BRAINCODE_STP:
    case BRAINCODE_LTP:
        if ( ( is_constant0 ) && ( !is_constant1 ) )
        {
            return BC_FORMAT_F;
        }
        if ( ( is_constant0 ) && ( is_constant1 ) )
        {
            return BC_FORMAT_C;
        }
        if ( ( !is_constant0 ) && ( is_constant1 ) )
        {
            return BC_FORMAT_E;
        }
        break;
    }
    return BC_FORMAT_A;
}

/** "aeio" "fmsv"; */

const n_string braincode_spoken_dictionary[BRAINCODE_INSTRUCTIONS] =
{
    /** data */
    "a",    /**< "DAT0", */
    "o",    /**< "DAT1", */

    /** operators */
    "mam", /**< "ADD ",*/
    "vos", /**< "SUB ",*/
    "sie",  /**< "MUL ",*/
    "fes",  /**< "DIV ",*/
    "feo", /**< "MOD ",*/
    "mas", /**< "MVB ",*/
    "vam", /**< "MOV ",*/
    "amo", /**< "JMP ",*/
    "sam", /**< "CTR ",*/
    "mao", /**< "SWP ",*/
    "ova", /**< "INV ",*/
    "eef",  /**< "STP ",*/
    "fee",  /**< "LTP ",*/

    /** conditionals */
    "om", /**< "JMZ ",*/
    "ov",  /**< "JMN ",*/
    "fi",  /**< "DJN ",*/
    "im", /**< "AND ",*/
    "se", /**< "OR  ",*/
    "es",  /**< "SEQ ",*/
    "os",  /**< "SNE ",*/
    "is",  /**< "SLT ",*/

    /** sensors */
    "favos", /**< "SEN ",*/
    "vamos", /**< "SEN2",*/
    "famov", /**< "SEN3",*/

    /** actuators */
    "iema", /**< "ACT ",*/
    "iova", /**< "ACT2",*/
    "iafi", /**< "ACT3",*/
    "ovma", /**< "ANE "*/
};

static n_byte brain_vc( n_byte value, n_byte vowel )
{
    if ( vowel )
    {
        switch ( value )
        {
        case 3:
            return 'a';
        case 1:
            return 'e';
        case 2:
            return 'i';
        default:
            return 'o';
        }
    }
    switch ( value )
    {
    case 0:
        return 'v';
    case 1:
        return 'f';
    case 2:
        return 's';
    case 3:
        return 't';
    case 4:
        return 'p';
    case 5:
        return 'b';
    case 6:
        return 'j';
    default:
        return 'm';
    }
}

static void brain_longword( n_string output, n_byte value )
{
    output[0] = ( n_char )brain_vc( ( value >> 0 ) & 7, 0 );
    output[1] = ( n_char )brain_vc( ( value >> 3 ) & 3, 1 );
    output[2] = ( n_char )brain_vc( ( value >> 5 ) & 7, 0 );
    output[4] = 0;
}

static void brain_four_character_byte( n_string value, n_byte star, n_byte dashes, n_byte number )
{
    if ( star )
    {
        value[0] = '*';
    }
    else
    {
        value[0] = ' ';
    }
    if ( dashes )
    {
        value[1] = '-';
        value[2] = '-';
        value[3] = '-';
    }
    else
    {
        value[1] = '0' + ( number / 100 ) % 10;
        value[2] = '0' + ( number / 10 ) % 10;
        value[3] = '0' + ( number / 1 ) % 10;

        if ( value[1] == '0' )
        {
            value[1] = ' ';
            if ( value[2] == '0' )
            {
                value[2] = ' ';
            }
        }
    }
}

static void brain_space_nstruction_space( n_string value, n_byte instruction )
{
    n_string instruction_string = braincode_mnemonic[instruction];
    value[0] = ' ';
    value[1] = instruction_string[0];
    value[2] = instruction_string[1];
    value[3] = instruction_string[2];
    value[4] = instruction_string[3];
    value[5] = ' ';
}

/**
 * @brief prints a three byte instruction in the appropriate format
 * @param string The returned string
 * @param response Array containing the three byte instruction
 */
void brain_three_byte_command( n_string string, n_byte *response )
{
    n_byte command      = response[0];
    n_byte value0       = response[1];
    n_byte value1       = response[2];
    n_byte instruction  = ( command & ( BRAINCODE_CONSTANT0_BIT - 1 ) ) % BRAINCODE_INSTRUCTIONS;
    enum BC_FORMAT format       = brain_format( instruction, command, value0, value1 );

    brain_space_nstruction_space( string, instruction );

    switch ( format )
    {
    case BC_FORMAT_A:
        brain_four_character_byte( &string[6],  0, 0, value0 );
        brain_four_character_byte( &string[10], 0, 0, value1 );
        break;
    case BC_FORMAT_C:
        brain_four_character_byte( &string[6],  1, 0, value0 );
        brain_four_character_byte( &string[10], 1, 0, value1 );
        break;
    case BC_FORMAT_E:
        brain_four_character_byte( &string[6],  0, 0, value0 );
        brain_four_character_byte( &string[10], 1, 0, value1 );
        break;
    case BC_FORMAT_F:
        brain_four_character_byte( &string[6],  1, 0, value0 );
        brain_four_character_byte( &string[10], 0, 0, value1 );
        break;
    case BC_FORMAT_G:
        brain_four_character_byte( &string[6],  0, 0, value0 );
        brain_four_character_byte( &string[10], 0, 1, 0 );
        break;
    default:
        brain_four_character_byte( &string[6],  0, 1, 0 );
        brain_four_character_byte( &string[10], 0, 0, value1 );
        break;
    }
    string[14] = 0;
}

/**
 * @brief A simple sort of sentence construction from three byte instructions
 * @param string The returned sentence
 * @param response Array containing three byte instruction
 */
void brain_sentence( n_string string, n_byte *response )
{
    n_byte command      = response[0];
    n_byte value0       = response[1];
    n_byte value1       = response[2];
    n_byte instruction  = ( command & ( BRAINCODE_CONSTANT0_BIT - 1 ) ) % BRAINCODE_INSTRUCTIONS;
    enum BC_FORMAT  format = brain_format( instruction, command, value0, value1 );
    n_string_block      first_word, second_word;
    n_int  position     = 0;

    brain_longword( first_word, value0 );
    brain_longword( second_word, value1 );

    switch ( format )
    {
    case BC_FORMAT_A:
    case BC_FORMAT_C:
    case BC_FORMAT_E:
    case BC_FORMAT_F:
        io_string_write( string, braincode_spoken_dictionary[instruction], &position );
        io_string_write( string, " ", &position );
        io_string_write( string, first_word, &position );
        io_string_write( string, second_word, &position );
        break;
    case BC_FORMAT_G:
        io_string_write( string, braincode_spoken_dictionary[instruction], &position );
        io_string_write( string, " ", &position );
        io_string_write( string, first_word, &position );
        break;
    default:
        io_string_write( string, braincode_spoken_dictionary[instruction], &position );
        io_string_write( string, " ", &position );
        io_string_write( string, second_word, &position );
        break;
    }
}

#ifdef BRAINCODE_ON

/**
 * @brief returns a random braincode instruction of the given type
 * @param instruction_type Number indicating the type of instruction
 * @return braincode instruction
 */
static n_byte get_braincode_instruction_type( n_byte instruction_type )
{
    n_byte2 local_random[2];

    math_random3( local_random );
    switch ( instruction_type )
    {
    case 0: /**< GENE_BRAINCODE_SENSORS(genetics);*/
        return BRAINCODE_DATA_START + ( local_random[0] % ( BRAINCODE_DATA_NUMBER ) );
    case 1: /**< GENE_BRAINCODE_ACTUATORS(genetics); */
        return BRAINCODE_SENSORS_START + ( local_random[0] % ( BRAINCODE_SENSORS_NUMBER ) );
    case 2: /**< GENE_BRAINCODE_CONDITIONALS(genetics); */
        return BRAINCODE_ACTUATORS_START + ( local_random[0] % ( BRAINCODE_ACTUATORS_NUMBER ) );
    case 3: /**< GENE_BRAINCODE_OPERATORS(genetics); */
        return BRAINCODE_OPERATORS_START + ( local_random[0] % ( BRAINCODE_OPERATORS_NUMBER ) );
    case 4: /**< GENE_BRAINCODE_DATA(genetics); */
        return BRAINCODE_CONDITIONALS_START + ( local_random[0] % ( BRAINCODE_CONDITIONALS_NUMBER ) );
    }

    return BRAINCODE_DATA_START;
}

/* return the number of instruction_types in the braincode */


/**
 * @brief returns a random braincode instruction
 * @param local_being Pointer to the being
 * @return braincode instruction
 */
n_byte get_braincode_instruction( simulated_being *local_being )
{
    n_byte2 prob[5], total, index;
    n_genetics *genetics = being_genetics( local_being );
    n_byte  i;
    const n_byte2 min = 2;

    prob[0] = ( n_byte2 )( min + GENE_BRAINCODE_SENSORS( genetics ) );
    prob[1] = ( n_byte2 )( min + GENE_BRAINCODE_ACTUATORS( genetics ) );
    prob[2] = ( n_byte2 )( min + GENE_BRAINCODE_CONDITIONALS( genetics ) );
    prob[3] = ( n_byte2 )( min + GENE_BRAINCODE_OPERATORS( genetics ) );
    prob[4] = ( n_byte2 )( min + GENE_BRAINCODE_DATA( genetics ) );

    total = prob[0] + prob[1] + prob[2] + prob[3] + prob[4];

    if ( total == 0 )
    {
        index = 0;
    }
    else
    {
        index = being_random( local_being );
    }
    total = 0;
    for ( i = 0; i < 5; i++, total += prob[i] )
    {
        if ( index >= total )
        {
            return get_braincode_instruction_type( i );
        }
    }
    return get_braincode_instruction_type( 4 );
}

static n_int get_actor_index( simulated_isocial *social_graph, n_int value )
{
    n_int i;

    for ( i = 0; i < SOCIAL_SIZE; i++ )
    {
        if ( SOCIAL_GRAPH_ENTRY_EMPTY( social_graph, i ) )
        {
            break;
        }
    }

    if ( i == 0 )
    {
        return 0;
    }

    return value % i;
}

/**
 * @brief returns the social graph index for a being with the same (or similar) name to the given episodic memory event
 * @param social_graph Pointer to the social graph
 * @param episodic_event Pointer to the episodic memory
 * @param episode_index Index of the episode which is the current focus of attention
 * @return Social graph index
 */
static n_int get_actor_index_from_episode(
    simulated_isocial *social_graph,
    simulated_iepisodic *episodic_event,
    n_int episode_index )
{
    n_int i, actor_index = -1;

    for ( i = 1; i < SOCIAL_SIZE_BEINGS; i++ )
    {
        if ( !SOCIAL_GRAPH_ENTRY_EMPTY( social_graph, i ) )
        {
            if ( social_graph[i].family_name == episodic_event[episode_index].family_name )
            {
                actor_index = i;
                if ( social_graph[i].first_name == episodic_event[episode_index].first_name )
                {
                    actor_index = i;
                    break;
                }
            }
        }
    }
    return actor_index;
}

typedef n_int ( n_similar )( simulated_iepisodic *episodic, n_int *carry_through );

/**
 * @brief Returns the index of the most similar episodic memory
 * @param episode_index Current episodic memory index
 * @param episodic Pointer to the episodic memory
 * @param memory_visited Array which keeps track of which episodic memories have already been visited
 * @param carry_through The property to be compared against
 * @param function The similarity function to be used to do the comparrisson
 * @return Episodic memory index of the most similar event
 */
static n_int attention_similar( n_int episode_index,
                                simulated_iepisodic *episodic,
                                n_int *memory_visited,
                                n_int *carry_through,
                                n_similar function )
{
    n_int i;
    n_int visited_max = memory_visited[episode_index] - ( EPISODIC_SIZE >> 1 );
    n_int min = -1;
    n_int next_episode_index = -1;
    if ( visited_max < 0 )
    {
        visited_max = 0;
    }

    for ( i = 0; i < EPISODIC_SIZE; i++ )
    {
        if ( episodic[i].event == 0 )
        {
            continue;
        }

        if ( i != episode_index )
        {
            /** was this episode recently visited? */
            if ( memory_visited[i] <= visited_max )
            {
                /** difference between episodes */
                n_int diff = function( &episodic[i], carry_through );
                if ( diff < 0 )
                {
                    diff = -diff;
                }
                if ( ( min == -1 ) || ( diff < min ) )
                {
                    /** record most similar */
                    min = diff;
                    next_episode_index = i;
                }
            }
        }
    }
    if ( next_episode_index > -1 )
    {
        /** mark this episode as having been visited */
        memory_visited[next_episode_index] = memory_visited[episode_index] + 1;
    }
    return next_episode_index;
}

/**
 * @brief returns the temporal proximity of an episodic event to the given reference time
 * @param episodic Pointer to the episodic memory event
 * @param carry_through Time to be compared against
 * @return Absolute temporal proximity
 */
static n_int similar_time( simulated_iepisodic *episodic, n_int *carry_through )
{
    n_int dt = episodic->space_time.time - carry_through[0];
    if ( dt < 0 )
    {
        dt = - dt;
    }
    return dt;
}

/**
 * @brief Returns the temporal proximity of an episodic memory event to the given time
 * @param episode_index Index of the current focus of attention within the episodic memory
 * @param episodic Pointer to the episodic memory
 * @param memory_visited Time to be compared against
 * @return Absolute temporal proximity
 */
static n_int attention_similar_time( n_int episode_index,
                                     simulated_iepisodic *episodic,
                                     n_int *memory_visited )
{
    n_int time = episodic[episode_index].space_time.time;
    return attention_similar( episode_index, episodic, memory_visited, &time, similar_time );
}

/**
 * @brief Returns the affective similarity of the given affect value to an episodic memory event
 * @param episodic Pointer to the episodic memory event
 * @param carry_through Affect value to be compared against
 * @return Absolute difference in affect value
 */
static n_int similar_affect( simulated_iepisodic *episodic, n_int *carry_through )
{
    n_int da = episodic->affect - carry_through[0];
    if ( da < 0 )
    {
        da = - da;
    }
    return da;
}
/**
 * @brief Returns the affective similarity of the given affect value to an episodic memory event
 * @param episode_index Index of the current focus of attention within the episodic memory
 * @param episodic Pointer to the episodic memory
 * @param memory_visited Affect value to be compared against
 * @return Absolute difference in affect value
 */
static n_int attention_similar_affect( n_int episode_index,
                                       simulated_iepisodic *episodic,
                                       n_int *memory_visited )
{
    n_int affect = episodic[episode_index].affect;
    return attention_similar( episode_index, episodic, memory_visited, &affect, similar_affect );
}

/**
 * @brief Returns the similarity between a given episodic memory event and the given family name
 * @param episodic Pointer to the episodic memory event
 * @param carry_through Family name to be compared against
 * @return Similarity value in the range 0-3
 */
static n_int similar_name( simulated_iepisodic *episodic, n_int *carry_through )
{
    n_int similarity = 3;
    n_byte values[2];

    being_unpack_family( episodic->family_name[BEING_MET], values );

    if ( values[0] == carry_through[0] )
    {
        similarity--;
    }
    if ( values[1] == carry_through[1] )
    {
        similarity--;
    }
    if ( episodic->first_name[BEING_MET] == carry_through[2] )
    {
        similarity--;
    }
    return similarity;
}


/**
 * @brief Returns the similarity between a given episodic memory event and the given being name
 * @param episode_index Index of the current focus of attention within the episodic memory
 * @param episodic Pointer to the episodic memory
 * @param memory_visited Affect value to be compared against
 * @return Similarity value
 */
static n_int attention_similar_name( n_int episode_index,
                                     simulated_iepisodic *episodic,
                                     simulated_being *meeter,
                                     n_int *memory_visited )
{
    n_int name[3];
    n_byte values[2];

    being_unpack_family( episodic->family_name[BEING_MET], values );

    name[0] = values[0];
    name[1] = values[1];
    name[2] = episodic[episode_index].first_name[BEING_MET];

    return attention_similar( episode_index, episodic, memory_visited, name, similar_name );
}

/**
 * @brief Returns the similarity of a given date to the date of the given episodic memory event
 * @param episodic Pointer to the episodic memory event
 * @param carry_through Date to be compared against
 * @return Absolute difference in date value
 */
static n_int similar_date( simulated_iepisodic *episodic, n_int *carry_through )
{
    n_int dd = episodic->space_time.date - carry_through[0];
    if ( dd < 0 )
    {
        dd = - dd;
    }
    return dd;
}

/**
 * @brief Returns the similarity of a given date to the date of the given episodic memory event
 * @param episode_index Index of the current focus of attention within the episodic memory
 * @param episodic Pointer to the episodic memory
 * @param memory_visited Date to be compared against
 * @return Similarity value
 */
static n_int attention_similar_date( n_int episode_index,
                                     simulated_iepisodic *episodic,
                                     n_int *memory_visited )
{
    n_int time = episodic[episode_index].space_time.date;
    return attention_similar( episode_index, episodic, memory_visited, &time, similar_date );
}

/**
 * @brief Returns the similarity between the given episodic memory event place and a given reference location
 * @param episodic Pointer to the episodic memory event
 * @param carry_through 2D coordinate of the place to be compared against
 * @return Similarity value (2D distance squared)
 */
static n_int similar_place( simulated_iepisodic *episodic, n_int *carry_through )
{
    n_int dx = episodic->space_time.location[0] - carry_through[0];
    n_int dy = episodic->space_time.location[1] - carry_through[1];
    /** TODO should be calculated in the future with wrap around comparison */
    n_int da = ( dx * dx ) + ( dy * dy );
    return da;
}

/**
 * @brief Returns the similarity between the given episodic memory event place and a given reference location
 * @param episode_index Index of the episodic memory which is the current focus of attention
 * @param episodic Pointer to the episodic memory
 * @param memory_visited 2D coordinate of the place to be compared against
 * @return Similarity value (2D distance squared)
 */
static n_int attention_similar_place( n_int episode_index,
                                      simulated_iepisodic *episodic,
                                      n_int *memory_visited )
{
    n_int location[2];
    location[0] = episodic[episode_index].space_time.location[0];
    location[1] = episodic[episode_index].space_time.location[1];
    return attention_similar( episode_index, episodic, memory_visited, location, similar_place );
}


n_byte *math_general_allocation( n_byte *bc0, n_byte *bc1, n_int i )
{
    if ( BRAINCODE_ADDRESS( i ) < BRAINCODE_SIZE )
    {
        /** address within this being */
        return &bc0[BRAINCODE_ADDRESS( i )];
    }
    /** Address within the other being */
    return &bc1[BRAINCODE_ADDRESS( i ) - BRAINCODE_SIZE];
}

void math_general_execution( n_int instruction, n_int is_constant0, n_int is_constant1,
                             n_byte *addr0, n_byte *addr1, n_int value0, n_int *i,
                             n_int is_const0, n_int is_const1,
                             n_byte *pspace,
                             n_byte *bc0, n_byte *bc1,
                             n_int braincode_min_loop )
{
    /** Logical and */
    switch ( instruction )
    {
    case BRAINCODE_AND:
        if ( is_constant0 )
        {
            addr0[0] &= addr1[0];
        }
        else
        {
            if ( ( addr0[0] > 127 ) && ( addr1[0] > 127 ) )
            {
                *i += BRAINCODE_BYTES_PER_INSTRUCTION;
            }
        }
        break;
    /** Logical or */
    case BRAINCODE_OR:
        if ( is_constant0 )
        {
            addr0[0] |= addr1[0];
        }
        else
        {
            if ( ( addr0[0] > 127 ) || ( addr1[0] > 127 ) )
            {
                *i += BRAINCODE_BYTES_PER_INSTRUCTION;
            }
        }
        break;
    /** Move a byte, with no particular alignment */
    case BRAINCODE_MOV:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            addr1[0] = addr0[0];
        }
        else
        {
            addr1[0] = ( n_byte )value0;
        }
        break;
    /** Move a block of instructions */
    case BRAINCODE_MVB:
    {
        n_int ptr0, ptr1, n, instructions_to_copy, dat = 0;

        if ( !is_constant0 )
        {
            ptr0 = BRAINCODE_ADDRESS( *i + ( ( n_int )addr0[0] * BRAINCODE_BYTES_PER_INSTRUCTION ) );
        }
        else
        {
            ptr0 = BRAINCODE_ADDRESS( *i + ( ( n_int )value0 * BRAINCODE_BYTES_PER_INSTRUCTION ) );
        }

        ptr1 = BRAINCODE_ADDRESS( *i + ( ( n_int )is_const0 * BRAINCODE_BYTES_PER_INSTRUCTION ) );

        instructions_to_copy = 1 + ( pspace[1] % BRAINCODE_BLOCK_COPY );

        while ( dat < instructions_to_copy )
        {
            if ( ptr0 < BRAINCODE_SIZE )
            {
                addr0 = &bc0[ptr0];
            }
            else
            {
                addr0 = &bc1[ptr0 - BRAINCODE_SIZE];
            }

            if ( ptr1 < BRAINCODE_SIZE )
            {
                addr1 = &bc0[ptr1];
            }
            else
            {
                addr1 = &bc1[ptr1 - BRAINCODE_SIZE];
            }

            for ( n = 0; n < BRAINCODE_BYTES_PER_INSTRUCTION; n++ )
            {
                addr1[n] = addr0[n];
            }
            dat++;
            ptr0 = BRAINCODE_ADDRESS( ptr0 + BRAINCODE_BYTES_PER_INSTRUCTION );
            ptr1 = BRAINCODE_ADDRESS( ptr1 + BRAINCODE_BYTES_PER_INSTRUCTION );
        }
    }
    break;

    /** Add */
    case BRAINCODE_ADD:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            addr1[0] += addr0[0];
        }
        else
        {
            addr1[0] += value0;
        }
        break;
    /** Subtract */
    case BRAINCODE_SUB:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            addr1[0] -= addr0[0];
        }
        else
        {
            addr1[0] -= value0;
        }
        break;
    /** Multiply */
    case BRAINCODE_MUL:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            addr1[0] *= addr0[0];
        }
        else
        {
            addr1[0] *= value0;
        }
        break;
    /** Divide */
    case BRAINCODE_DIV:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            addr1[0] >>= ( addr0[0] % 4 );
        }
        else
        {
            addr1[0] >>= ( value0 % 4 );
        }
        break;
    /** Modulus */
    case BRAINCODE_MOD:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            if ( addr0[0] != 0 )
            {
                addr1[0] %= addr0[0];
            }
        }
        else
        {
            if ( value0 != 0 )
            {
                addr1[0] %= value0;
            }
        }
        break;
    /** Count up or down */
    case BRAINCODE_CTR:
        if ( addr0[0] > 127 )
        {
            if ( addr1[0] < 255 )
            {
                addr1[0]++;
            }
            else
            {
                addr1[0] = 0;
            }
        }
        else
        {
            if ( addr1[0] > 0 )
            {
                addr1[0]--;
            }
            else
            {
                addr1[0] = 255;
            }
        }
        break;
    /** Goto */
    case BRAINCODE_JMP:
    {
        n_int v0 = is_const0;
        n_int v1 = is_const1;
        n_int i2 = ( *i + ( ( ( v0 * 256 ) + v1 ) * BRAINCODE_BYTES_PER_INSTRUCTION ) ) % BRAINCODE_SIZE;
        if ( i2 <= *i )
        {
            if ( ( *i - i2 ) < braincode_min_loop )
            {
                i2 = *i - braincode_min_loop;
                if ( i2 < 0 )
                {
                    i2 += BRAINCODE_SIZE;
                }
            }
        }
        *i = i2 - BRAINCODE_BYTES_PER_INSTRUCTION;
        break;
    }
    /** Goto if zero */
    case BRAINCODE_JMZ:
    {
        n_int v0 = is_const0;

        if ( v0 == 0 )
        {
            n_int i2 = ( *i + ( ( n_int ) is_const1 * BRAINCODE_BYTES_PER_INSTRUCTION ) ) % BRAINCODE_SIZE;

            if ( i2 <= *i )
            {
                if ( ( *i - i2 ) < braincode_min_loop )
                {
                    i2 = *i - braincode_min_loop;
                    if ( i2 < 0 )
                    {
                        i2 += BRAINCODE_SIZE;
                    }
                }
            }
            *i = i2 - BRAINCODE_BYTES_PER_INSTRUCTION;
        }
        break;
    }
    /** Goto if not zero */
    case BRAINCODE_JMN:
    {
        n_int v0 = is_const0;
        if ( v0 != 0 )
        {
            n_int i2 = ( *i + ( ( n_int ) is_const1 * BRAINCODE_BYTES_PER_INSTRUCTION ) ) % BRAINCODE_SIZE;
            if ( i2 <= *i )
            {
                if ( ( *i - i2 ) < braincode_min_loop )
                {
                    i2 = *i - braincode_min_loop;
                    if ( i2 < 0 )
                    {
                        i2 += BRAINCODE_SIZE;
                    }
                }
            }
            *i = i2 - BRAINCODE_BYTES_PER_INSTRUCTION;
        }
        break;
    }
    /** Goto and decrement if not zero */
    case BRAINCODE_DJN:
        if ( addr0[0] - 1 != 0 )
        {
            n_int i2 = ( *i + ( ( n_int ) is_const1 * BRAINCODE_BYTES_PER_INSTRUCTION ) ) % BRAINCODE_SIZE;
            addr0[0]--;

            if ( i2 <= *i )
            {
                if ( ( *i - i2 ) < braincode_min_loop )
                {
                    i2 = *i - braincode_min_loop;
                    if ( i2 < 0 )
                    {
                        i2 += BRAINCODE_SIZE;
                    }
                }
            }
            *i = i2 - BRAINCODE_BYTES_PER_INSTRUCTION;
        }
        break;
    /** If two values are equal then skip the next n instructions */
    case BRAINCODE_SEQ:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            if ( addr1[0] == addr0[0] )
            {
                *i = ( *i + ( BRAINCODE_BYTES_PER_INSTRUCTION * ( 1 + ( n_int )pspace[0] ) ) ) % BRAINCODE_SIZE;
            }
        }
        else
        {
            if ( addr1[0] == value0 )
            {
                *i = ( *i + ( BRAINCODE_BYTES_PER_INSTRUCTION * ( 1 + ( n_int )pspace[0] ) ) ) % BRAINCODE_SIZE;
            }
        }
        break;
    /** If two values are not equal then skip the next n instructions */
    case BRAINCODE_SNE:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            if ( addr1[0] != addr0[0] )
            {
                *i = ( *i + ( BRAINCODE_BYTES_PER_INSTRUCTION * ( 1 + ( n_int )pspace[0] ) ) ) % BRAINCODE_SIZE;
            }
        }
        else
        {
            if ( addr1[0] != value0 )
            {
                *i = ( *i + ( BRAINCODE_BYTES_PER_INSTRUCTION * ( 1 + ( n_int )pspace[0] ) ) ) % BRAINCODE_SIZE;
            }
        }
        break;
    /** Skip the next n instructions if less than */
    case BRAINCODE_SLT:
        if ( ( !is_constant0 ) && ( !is_constant1 ) )
        {
            if ( addr1[0] < addr0[0] )
            {
                *i = ( *i + ( BRAINCODE_BYTES_PER_INSTRUCTION * ( 1 + ( n_int )pspace[0] ) ) ) % BRAINCODE_SIZE;
            }
        }
        else
        {
            if ( addr1[0] < value0 )
            {
                *i = ( *i + ( BRAINCODE_BYTES_PER_INSTRUCTION * ( 1 + ( n_int )pspace[0] ) ) ) % BRAINCODE_SIZE;
            }
        }
        break;
    /** No operation (data only) */
    case BRAINCODE_DAT0:
    case BRAINCODE_DAT1:
        break;
    /** swap */
    case BRAINCODE_SWP:
    {
        n_byte tmp = addr0[0];
        addr0[0] = addr1[0];
        addr1[0] = tmp;
        break;
    }
    /** invert */
    case BRAINCODE_INV:
        if ( is_constant0 )
        {
            addr0[0] = 255 - addr0[0];
        }
        else
        {
            addr1[0] = 255 - addr1[0];
        }
        break;
    /** Save to Pspace */
    case BRAINCODE_STP:
    {
        n_byte v0 = ( n_byte )is_const0;
        n_byte v1 = ( n_byte )is_const1;
        pspace[v0 % BRAINCODE_PSPACE_REGISTERS] = v1;
        break;
    }
    /** Load from Pspace */
    case BRAINCODE_LTP:
    {
        n_byte v0 = ( n_byte )is_const0;
        addr1[0] = pspace[v0 % BRAINCODE_PSPACE_REGISTERS];
        break;
    }
    }
}


/**
 * @brief Returns a sensor value
 * @param group Pointer to the simulated_group object
 * @param meeter_being Pointer to the being doing the meeting
 * @param met_being Pointer to the being which was met
 * @param meeter_social_graph Pointer to the meeter being's social graph
 * @param actor_index Social graph index of the being which is the current focus of attention
 * @param switcher The type of sensor
 * @return Sensor value
 */
static n_byte brain_first_sense( simulated_group *group, simulated_being *meeter_being, simulated_being *met_being, simulated_isocial *meeter_social_graph, n_int actor_index, n_byte switcher )
{
    switch ( switcher % 32 )
    {
    case 0:
        return being_honor( meeter_being );
    case 1:
        return being_honor( met_being );
    case 2:
        return ( n_byte )being_parasites( meeter_being );
    case 3:
        return ( n_byte )being_parasites( met_being );
    case 4:
        return being_crowding( meeter_being );
    case 5:
        return being_family_first_name( meeter_being );
    case 6:
        return being_family_second_name( meeter_being );
    case 7:
        return being_family_first_name( met_being );
    case 8:
        return being_family_second_name( met_being );
    case 9:
        return being_facing( meeter_being );
    case 10:
        return being_facing( met_being );
    case 11:
        return being_speed( meeter_being );
    case 12:
        return meeter_social_graph[actor_index].familiarity & 255;
    case 13:
        return meeter_social_graph[actor_index].friend_foe;
    case 14:
        return meeter_social_graph[actor_index].attraction;
    /** Location */

    /*
        case 15:
            return (n_byte)(APESPACE_TO _MAPSPACE(being_location_x(meeter_being)) * 255 / land_map_dimension());
        case 16:
            return (n_byte)(APESPACE_TO _MAPSPACE(being_location_y(meeter_being)) * 255 / land_map_dimension());
     */
    /** Being state (lower)*/
    case 17:
        return ( n_byte )( being_state( meeter_being ) & 255 );
    /** Being state (upper)*/
    case 18:
        return ( n_byte )( ( being_state( meeter_being ) >> 8 ) & 255 );
    /** Drives */
    case 19:
        return ( n_byte )being_drive( meeter_being, DRIVE_HUNGER );
    case 20:
        return ( n_byte )being_drive( meeter_being, DRIVE_SOCIAL );
    case 21:
        return ( n_byte )being_drive( meeter_being, DRIVE_FATIGUE );
    case 22:
        return ( n_byte )being_drive( meeter_being, DRIVE_SEX );

    /** Sexisms */
    case 23:
        if ( FIND_SEX( GET_I( meeter_being ) ) == FIND_SEX( GET_I( met_being ) ) )
        {
            return 0;
        }
        else
        {
            return 255;
        }
        break;
    case 24:
        if ( FIND_SEX( GET_I( met_being ) ) == SEX_FEMALE )
        {
            return 255;
        }
        else
        {
            return 0;
        }
        break;
    case 25:
        if ( FIND_SEX( GET_I( met_being ) ) != SEX_FEMALE )
        {
            return 255;
        }
        else
        {
            return 0;
        }
    /** Overall grooming */
    case 26:
    {
        n_int v = 0;
        n_int n;
        for ( n = 0; n < INVENTORY_SIZE; n++ )
        {
            if ( met_being->changes.inventory[n] & INVENTORY_GROOMED )
            {
                v++;
            }
        }
        return ( n_byte ) ( v << 4 );
    }
    case 27:
    {
        n_int v = 0;
        n_int n;
        for ( n = 0; n < INVENTORY_SIZE; n++ )
        {
            if ( meeter_being->changes.inventory[n] & INVENTORY_GROOMED )
            {
                v++;
            }
        }
        return ( n_byte ) ( v << 4 );
    }

    /** Wounds */
    case 28:
    {
        n_int v = 0;
        n_int n;
        for ( n = 0; n < INVENTORY_SIZE; n++ )
        {
            if ( met_being->changes.inventory[n] & INVENTORY_WOUND )
            {
                v++;
            }
        }
        return ( n_byte ) ( v << 4 );
    }
    case 29:
    {
        n_int v = 0;
        n_int n;
        for ( n = 0; n < INVENTORY_SIZE; n++ )
        {
            if ( meeter_being->changes.inventory[n] & INVENTORY_WOUND )
            {
                v++;
            }
        }
        return ( n_byte ) ( v << 4 );
    }

    /** Posture */
    case 30:
        return being_posture( meeter_being );
    }
    /** case 31: */
    return being_posture( met_being );
}

static n_byte territory_familiarity( simulated_being *local_being,
                                     n_byte2 index )
{
    n_byte result = 0;
#ifdef TERRITORY_ON
    n_uint familiarity = ( n_uint )( local_being->events.territory[index].familiarity );
    n_uint i, max_familiarity = 1;

    /** find the maximum familiarity */
    for ( i = 0; i < TERRITORY_AREA; i++ )
    {
        if ( local_being->events.territory[i].familiarity > max_familiarity )
        {
            max_familiarity = ( n_uint )local_being->events.territory[i].familiarity;
        }
    }

    if ( max_familiarity == 0 )
    {
        return 0;
    }

    result = ( n_byte )( familiarity * 255 / max_familiarity );
#endif
    return result;
}

static void being_second_sense( simulated_group *group, n_byte addr00, n_byte *local_addr10, simulated_being *meeter_being, simulated_being *met_being, n_int actor_index, n_byte is_const1, n_int episode_index, simulated_iepisodic *episodic )
{
    n_int new_episode_index = -1;
    n_int switcher = addr00 % 25;

    n_vect2 location;

    simulated_isocial *meeter_social_graph = being_social( meeter_being );
    n_int territory_index = ( n_int )( being_attention( meeter_being, ATTENTION_TERRITORY ) );
    n_int memory_visited[EPISODIC_SIZE];
    n_int i;
    n_int relationship_index = ( n_int )( being_attention( meeter_being, ATTENTION_RELATIONSHIP ) );


    being_space( meeter_being, &location );
    spacetime_convert_to_map( &location );

    /** clear episodes visited.
     This array helps to avoid repeatedly visiting the same memories */
    for ( i = 0; i < EPISODIC_SIZE; i++ )
    {
        memory_visited[i] = 0;
    }
    switch ( switcher )
    {
    /** Shift attention to a different actor */
    case 0:
        actor_index = get_actor_index( meeter_social_graph, is_const1 % SOCIAL_SIZE );
        /** store the current focus of attention */
        being_set_attention( meeter_being, ATTENTION_ACTOR, actor_index );
        break;
    /** Shift attention to a different episode */
    case 1:
        new_episode_index = is_const1 % EPISODIC_SIZE;
        break;
    /** Shift attention to a different territory */
    case 2:
        territory_index = is_const1;
        being_set_attention( meeter_being, ATTENTION_TERRITORY, territory_index );
        break;
    /** Shift attention to a body region */
    case 3:
        being_set_attention( meeter_being, ATTENTION_BODY, is_const1 % INVENTORY_SIZE );
        break;
    case 4: /** Shift attention to a similar location */
        new_episode_index = attention_similar_place( episode_index, episodic, memory_visited );
        break;
    case 5: /** Shift attention to a similar time */
        new_episode_index = attention_similar_time( episode_index, episodic, memory_visited );
        break;
    case 6: /** Shift attention to a similar date */
        new_episode_index = attention_similar_date( episode_index, episodic, memory_visited );
        break;
    case 7: /** Shift attention to a similar name */
        new_episode_index = attention_similar_name( episode_index, episodic, meeter_being, memory_visited );
        break;
    case 8: /** Shift attention to a similar affect */
        new_episode_index = attention_similar_affect( episode_index, episodic, memory_visited );
        break;
    case 9:
        *local_addr10 = episodic[episode_index].event;
        break;
    case 10:
        *local_addr10 = episodic[episode_index].food;
        break;
    case 11:
        *local_addr10 = episodic[episode_index].affect & 255;
        break;
    case 12:
        *local_addr10 = episodic[episode_index].arg & 255;
        break;
    case 13:
        *local_addr10 = ( n_byte )( episodic[episode_index].space_time.location[0] * 255 / land_map_dimension() );
        break;
    case 14:
        *local_addr10 = ( n_byte )( episodic[episode_index].space_time.location[1] * 255 / land_map_dimension() );
        break;
    case 15:
    {
        /** atmosphere pressure */
        n_int pressure = weather_pressure( POSITIVE_LAND_COORD( location.x ), POSITIVE_LAND_COORD( location.y ) );

        if ( pressure > 100000 )
        {
            pressure = 100000;
        }
        if ( pressure < 0 )
        {
            pressure = 0;
        }
        *local_addr10 = ( n_byte )( pressure >> 9 );
        break;
    }
    case 16:
    {
        /** wind magnitude */
        n_vect2 wind;
        weather_wind_vector( &location, &wind );
        if ( wind.x < 0 )
        {
            wind.x = -wind.x;
        }
        if ( wind.y < 0 )
        {
            wind.y = -wind.y;
        }
        *local_addr10 = ( n_byte )( ( wind.x + wind.y ) >> 7 );
        break;
    }
    case 17:
        *local_addr10 = ( n_byte )( land_time() >> 3 );
        break;
    case 18:
        /** attention to body */
        *local_addr10 = being_attention( meeter_being, ATTENTION_BODY ) * 30;
        break;
    case 19:
#ifdef TERRITORY_ON
        /** territory name */
        *local_addr10 = meeter_being->events.territory[territory_index].name;
#endif
        break;
    case 20:
        /** territory familiarity */
        *local_addr10 = territory_familiarity( meeter_being, ( n_byte2 )territory_index );
        break;
    case 21:
        /** territory familiarity */
        *local_addr10 = territory_familiarity( met_being, ( n_byte2 )territory_index );
        break;
    case 22:
    {
        /** carrying object */
        n_byte2 carrying = being_carried( meeter_being, BODY_RIGHT_HAND );
        n_byte2 obj_type = 0;

        if ( carrying == 0 )
        {
            carrying = being_carried( meeter_being, BODY_LEFT_HAND );
        }
        if ( carrying != 0 )
        {
            /* TODO Is this willed into existence? */
            switch ( addr00 % 12 )
            {
            case 0:
                obj_type = INVENTORY_BRANCH;
                break;
            case 1:
                obj_type = INVENTORY_TWIG;
                break;
            case 2:
                obj_type = INVENTORY_ROCK;
                break;
            case 3:
                obj_type = INVENTORY_SHELL;
                break;
            case 4:
                obj_type = INVENTORY_GRASS;
                break;
            case 5:
                obj_type = INVENTORY_NUT;
                break;
            case 6:
                obj_type = INVENTORY_NUT_CRACKED;
                break;
            case 7:
                obj_type = INVENTORY_SCRAPER;
                break;
            case 8:
                obj_type = INVENTORY_SPEAR;
                break;
            case 9:
                obj_type = INVENTORY_FISH;
                break;
            case 10:
                obj_type = INVENTORY_BIRD_EGGS;
                break;
            case 11:
                obj_type = INVENTORY_LIZARD_EGGS;
                break;
            }
            if ( carrying & obj_type )
            {
                *local_addr10 = 255;
            }
            else
            {
                *local_addr10 = 0;
            }
        }

        break;
    }
    case 23:
    {
        /** shift attention to a given social graph entry based on relationship */
        n_int idx = social_get_relationship( meeter_being, ( n_byte )relationship_index );
        if ( idx > -1 )
        {
            actor_index = idx;
            /** store the current focus of attention */
            being_set_attention( meeter_being, ATTENTION_ACTOR, actor_index );
        }
        break;
    }
    case 24:
    {
        /** shift attention to a different relationship type */
        relationship_index = 1 + ( *local_addr10 % ( OTHER_MOTHER - 1 ) );
        /** store the current relationship attention */
        being_set_attention( meeter_being, ATTENTION_RELATIONSHIP, relationship_index );
        break;
    }
    }

    /** If attention has shifted to a new episode */
    if ( new_episode_index > -1 )
    {
        n_int possible_actor_index;
        episode_index = new_episode_index;
        being_set_attention( meeter_being, ATTENTION_EPISODE, episode_index );
        /** Shift attention to the being in this episode */
        possible_actor_index = get_actor_index_from_episode( meeter_social_graph, episodic, episode_index );
        if ( possible_actor_index > -1 )
        {
            actor_index = possible_actor_index;
            /** store the change in attention */
            being_set_attention( meeter_being, ATTENTION_ACTOR, actor_index );
        }
        /** set territory attention to the location where the episode occurred */
        being_set_attention( meeter_being, ATTENTION_TERRITORY,
                             ( APESPACE_TO_TERRITORY( episodic[episode_index].space_time.location[1] ) * 16 ) +
                             APESPACE_TO_TERRITORY( episodic[episode_index].space_time.location[0] ) );
    }
}

/**
 * @brief Returns a sensor value
 * @param group Pointer to the simulated_group object
 * @param meeter_being Pointer to the being doing the meeting
 * @param met_being Pointer to the being which was met
 * @param internal Non-zero if this is an internal dialogue
 * @param switcher The type of sensor
 * @param additional_write No operation value
 * @return Sensor value
 */
static n_byte brain_third_sense( simulated_group *group, simulated_being *meeter_being, simulated_being *met_being, n_byte internal, n_byte switcher, n_byte *additional_write )
{
    n_byte half_switcher = switcher >> 1;
    simulated_being *important_being = ( ( switcher & 1 ) ? met_being : meeter_being );
    n_genetics *genetics = being_genetics( important_being );
    switch ( half_switcher % 10 )
    {
    /** Facial characteristics.
          Here we shift the 0-15 gene values into a 0-255 range */
    case 0:
        return ( n_byte )( GENE_EYE_SHAPE( genetics ) << 4 );
    case 1:
        return ( n_byte )( GENE_EYE_COLOR( genetics ) << 4 );
    case 2:
        return ( n_byte )( GENE_EYE_SEPARATION( genetics ) << 4 );
    case 3:
        return ( n_byte )( GENE_NOSE_SHAPE( genetics ) << 4 );
    case 4:
        return ( n_byte )( GENE_EAR_SHAPE( genetics ) << 4 );
    case 5:
        return ( n_byte )( GENE_EYEBROW_SHAPE( genetics ) << 4 );
    case 6:
        return ( n_byte )( GENE_MOUTH_SHAPE( genetics ) << 4 );
    case 7:/* healthyness */
    {
        n_byte return_value = 0;
#ifdef IMMUNE_ON
        n_int n;
        simulated_immune_system *immune = &( important_being->immune_system );
        return_value = immune->antigens[0];
        for ( n = 1; n < IMMUNE_ANTIGENS; n++ )
        {
            if ( immune->antigens[n] > return_value )
            {
                return_value = immune->antigens[n];
            }
        }
#endif
        return return_value;
    }
    /** the 8 case is covered in the default: */
    case 9: /** listen for shouts */
        if ( ( internal != 0 ) &&
                ( !( being_state( meeter_being )&BEING_STATE_SHOUTING ) ) &&
                ( !( being_state( meeter_being )&BEING_STATE_SPEAKING ) ) &&
                ( meeter_being->changes.shout[SHOUT_HEARD] > 0 ) )
        {
            return meeter_being->changes.shout[SHOUT_HEARD];
        }
        break;
        break;
    /** listen for name shouts */
    default:
        if ( switcher == 16 ) /** positive affect */
        {
            n_uint positive = being_affect( meeter_being, 1 ) >> 7;
            if ( positive > 255 )
            {
                positive = 255;
            }
            return ( n_byte )positive;

        }
        {
            /* (switcher == 17) negative affect */

            n_uint negative = being_affect( meeter_being, 0 ) >> 1;
            if ( negative > 255 )
            {
                negative = 255;
            }
            return ( n_byte )negative;
        }
    }
    return additional_write[0]; /** no op case. Not sure if the compiler will recognize that though */
}

static void brain_first_action( simulated_group *group, n_byte awake,
                                n_byte *local_addr00, n_byte *local_addr10,
                                simulated_being *meeter_being, simulated_being *met_being, n_int episode_index,
                                simulated_iepisodic *episodic, n_byte pspace0, n_int actor_index,
                                simulated_isocial *meeter_social_graph, n_byte is_const1 )
{
    switch ( *local_addr00 % 6 )
    {
    /** individual or social action */
    case 0:
        if ( ( awake != 0 ) && ( *local_addr00 > 127 ) )
        {
            if ( meeter_being == met_being )
            {
                social_action( meeter_being, 0L, *local_addr10 );
            }
            else
            {
                social_action( meeter_being, met_being, *local_addr10 );
            }

            *local_addr00 = 0;
        }
        break;
    /** Set location goal */
    case 1:
        if ( !( meeter_being->braindata.script_overrides & OVERRIDE_GOAL ) )
        {
            being_set_goal_location( meeter_being,
                                     episodic[episode_index].space_time.location[0],
                                     episodic[episode_index].space_time.location[1] );
        }
        break;
    /** alter friend or foe value */
    case 2:
    {
        n_byte fof0 = pspace0;
        n_byte fof1 = *local_addr10;

        if ( fof0 > ( n_byte )( fof1 + 85 ) )
        {
            if ( meeter_social_graph[actor_index].friend_foe < 170 )
            {
                meeter_social_graph[actor_index].friend_foe++;
            }
        }
        if ( fof1 > ( n_byte )( fof0 + 85 ) )
        {
            if ( meeter_social_graph[actor_index].friend_foe > 85 )
            {
                meeter_social_graph[actor_index].friend_foe--;
            }
        }
        break;
    }
    /** alter attraction */
    case 3:
    {
        n_byte att0 = *local_addr10;
        n_byte att1 = pspace0;

        if ( att0 > ( n_byte )( att1 + 85 ) )
        {
            if ( meeter_social_graph[actor_index].attraction < 255 )
            {
                meeter_social_graph[actor_index].attraction++;
            }
        }
        if ( att1 > ( n_byte )( att0 + 85 ) )
        {
            if ( meeter_social_graph[actor_index].attraction > 16 )
            {
                meeter_social_graph[actor_index].attraction--;
            }
        }
        break;
    }
    /** alter familiarity */
    case 4:
        /** The values 10 and 20 meetings were just found experimentally */
        if ( ( *local_addr10 > 100 ) && ( *local_addr10 < 150 ) )
        {
            if ( meeter_social_graph[actor_index].familiarity < 65535 )
            {
                meeter_social_graph[actor_index].familiarity++;
                *local_addr10 = 0;
            }
        }
        if ( ( *local_addr10 > 150 ) && ( *local_addr10 < 200 ) )
        {
            if ( meeter_social_graph[actor_index].familiarity > 10 )
            {
                meeter_social_graph[actor_index].familiarity--;
                *local_addr10 = 0;
            }
        }
        break;
    /** brainprobe frequency */
    case 5:
    {
        n_int  n = pspace0 % BRAINCODE_PROBES;
        n_byte f = 1 + ( is_const1 % BRAINCODE_MAX_FREQUENCY );

        meeter_being->braindata.brainprobe[n].frequency = f;
        break;
    }
    }
}

#define IS_CONST0 (is_constant0 ? value0 : addr0[0])
#define IS_CONST1 (is_constant1 ? value1 : addr1[0])

/**
 * @brief Two beings meet and chat, or a being engages in an internal dialogue
 * @param group Pointer to the simulated_group object
 * @param awake Whether the being is awake
 * @param meeter_being Pointer to the being doing the meeting
 * @param met_being Pointer to the being which was met
 * @param bc0 Braincode of the meeter
 * @param bc1 Braincode of the met
 * @param being_index Social graph index of the being which is the current focus of attention
 */
void brain_dialogue(
    simulated_group *group,
    n_byte awake,
    simulated_being *meeter_being,
    simulated_being *met_being,
    n_byte *bc0,
    n_byte *bc1,
    n_int being_index )
{
#ifdef EPISODIC_ON
    n_byte internal = ( meeter_being == met_being );
    const n_int braincode_min_loop = 8 * BRAINCODE_BYTES_PER_INSTRUCTION;
    n_int i = 0, itt = 0;
    n_int actor_index;
    n_int episode_index = ( n_int )( being_attention( meeter_being, ATTENTION_EPISODE ) );
    n_int anecdote_episode_index = -1;
    n_int intention_episode_index = -1;

    simulated_isocial *meeter_social_graph = being_social( meeter_being );
    simulated_iepisodic *episodic = being_episodic( meeter_being );
    n_int max_itterations;
    n_byte *pspace = ( n_byte * )meeter_being->braindata.braincode_register;

    /* what is the current actor index within episodic memory? */
    if ( being_index > -1 )
    {
        actor_index = being_index;
    }
    else
    {
        being_index = being_attention( meeter_being, ATTENTION_ACTOR );
        actor_index = being_index;
    }

    if ( meeter_being == met_being )
    {
        /** fixed number of itterations for internal dialogue */
        max_itterations = BRAINCODE_MAX_ADDRESS / BRAINCODE_BYTES_PER_INSTRUCTION;
    }
    else
    {
        /** variable number of itterations for chat */
        max_itterations = 8 + meeter_being->changes.learned_preference[PREFERENCE_CHAT];
    }

    i = 0;

    while ( itt < max_itterations )
    {
        n_byte instruction = BRAINCODE_INSTRUCTION( bc0, i );
        n_byte is_constant0 = BRAINCODE_CONSTANT0( bc0, i );
        n_byte is_constant1 = BRAINCODE_CONSTANT1( bc0, i );
        n_byte value0 = BRAINCODE_VALUE( bc0, i, 0 );
        n_byte value1 = BRAINCODE_VALUE( bc0, i, 1 );
        n_byte *addr0 = math_general_allocation( bc0, bc1, i + value0 );
        n_byte *addr1 = math_general_allocation( bc0, bc1, i + value1 );

        switch ( instruction )
        {
        /** General sensor */
        case BRAINCODE_SEN:
        {
            addr1[0] = brain_first_sense( group, meeter_being, met_being, meeter_social_graph, actor_index, addr0[0] );
            break;
        }
        case BRAINCODE_SEN2:
        {
            being_second_sense( group, addr0[0], &addr1[0], meeter_being, met_being, actor_index, IS_CONST1, episode_index, episodic );
            break;
        }
        case BRAINCODE_SEN3:

            addr1[0] = brain_third_sense( group, meeter_being, met_being, internal, addr0[0], addr1 );
            break;
        /** Action */
        case BRAINCODE_ACT:
        {

            brain_first_action( group, awake, &addr0[0], &addr1[0], meeter_being, met_being, episode_index,
                                episodic, pspace[0], actor_index, meeter_social_graph, IS_CONST1 );
            break;
        }
        case BRAINCODE_ACT2:
        {
            switch ( addr0[0] % 6 )
            {
            case 0: /* brainprobe type */
            {
                n_int  n = pspace[0] % BRAINCODE_PROBES;
                n_byte typ = IS_CONST1 & 1;

                meeter_being->braindata.brainprobe[n].type = typ;
                break;
            }
            case 1: /** brainprobe address */
            {
                n_int n = pspace[0] % BRAINCODE_PROBES;
                n_byte adr = IS_CONST1;

                meeter_being->braindata.brainprobe[n].address = adr;
                break;
            }
            case 2: /** shout out */
            {
                n_byte msg = addr1[0];
                if ( is_constant1 )
                {
                    msg = value1;
                }
                if ( ( internal != 0 ) && ( awake != 0 ) &&
                        ( !( being_state( meeter_being )&BEING_STATE_SHOUTING ) ) &&
                        ( !( being_state( meeter_being )&BEING_STATE_SPEAKING ) ) &&
                        ( meeter_being->changes.shout[SHOUT_CONTENT] == 0 ) &&
                        ( meeter_being->changes.shout[SHOUT_HEARD] == 0 ) &&
                        ( meeter_being->changes.shout[SHOUT_CTR] == 0 ) &&
                        ( msg > 0 ) )
                {
                    meeter_being->changes.shout[SHOUT_CTR] = SHOUT_REFRACTORY;
                    being_add_state( meeter_being, BEING_STATE_SHOUTING );
                    /** volume of message */
                    meeter_being->changes.shout[SHOUT_VOLUME] = pspace[0];
                    /** type of message */
                    meeter_being->changes.shout[SHOUT_CONTENT] = msg;
                }
                break;
            }
            case 3: /** intention */
            {
                if ( intention_episode_index != episode_index )
                {
                    n_byte v0 = pspace[0];
                    n_byte v1 = IS_CONST1;
                    if ( episodic_intention( meeter_being, episode_index, ( n_byte2 )( v0 * 10 ), v1 ) != 0 )
                    {
                        intention_episode_index = episode_index;
                    }
                }
                break;
            }
            case 4: /** brainprobe offset */
            {
                n_int n = pspace[0] % BRAINCODE_PROBES;
                n_byte offset = IS_CONST1;

                meeter_being->braindata.brainprobe[n].offset = offset;
                break;
            }
            case 5: /** posture */
                if ( awake != 0 )
                {
                    being_set_posture( meeter_being, addr1[0] );
                }
                break;
            }
            break;
        }
        case BRAINCODE_ACT3:
            switch ( addr0[0] % 2 )
            {
            /** brainprobe position */
            case 0:
            {
                n_int  n = pspace[0] % BRAINCODE_PROBES;
                n_byte p = IS_CONST1;
                meeter_being->braindata.brainprobe[n].position = p;
                break;
            }
            /** alter learned preferences */
            case 1:
            {
                n_int n;
                n_byte prf = addr1[0];

                n = pspace[0] % PREFERENCES;

                if ( ( prf > 55 ) && ( prf < 155 ) )
                {
                    if ( meeter_being->changes.learned_preference[n] < 255 )
                    {
                        meeter_being->changes.learned_preference[n]++;
                        addr1[0] = 0;
                    }
                }
                if ( prf >= 155 )
                {
                    if ( meeter_being->changes.learned_preference[n] > 0 )
                    {
                        meeter_being->changes.learned_preference[n]--;
                        addr1[0] = 0;
                    }
                }
                break;
            }
            break;
            }
        /** spread anecdote */
        case BRAINCODE_ANE:
            if ( internal == 0 )
            {
                /** not internal dialogue */
                /** avoid repeated anecdotes in the same conversation */
                if ( anecdote_episode_index != episode_index )
                {
                    if ( episodic_anecdote( meeter_being, met_being ) != 0 )
                    {
                        anecdote_episode_index = episode_index;
                    }
                }
            }
            break;

        default:
            math_general_execution( instruction, is_constant0, is_constant1,
                                    addr0, addr1, value0, &i,
                                    IS_CONST0, IS_CONST1,
                                    pspace,
                                    bc0, bc1,
                                    braincode_min_loop );
            break;


        }
        i += BRAINCODE_BYTES_PER_INSTRUCTION;
        itt++;

        if ( i >= BRAINCODE_SIZE )
        {
            i -= BRAINCODE_SIZE;
        }
    }
#endif
}

#endif




/* ./entity/drives.c */
/****************************************************************

 drives.c

 =============================================================



 ****************************************************************/

/*! \file   drives.c
 *  \brief  Functions related to biological drives
 */

#include "entity.h"
#include "entity_internal.h"

/** Mate seeking */

#define GENE_MATE_SEEK(gene)                GENE_VAL_REG(gene, 8, 9, 14, 2)

/**
 * @brief Update the hunger drive
 * @param local Pointer to the ape
 */
void drives_hunger( simulated_being *local )
{
    /** if the being is hungry and its hunger drive is not already saturated */
    if ( being_energy_less_than( local, BEING_HUNGRY ) )
    {
        /** increase hunger drive */
        being_inc_drive( local, DRIVE_HUNGER );
        /** decrease sex drive (hunger subsumes sex) */
        being_dec_drive( local, DRIVE_SEX );
    }
    else
    {
        /** otherwise decrease hunger drive */
        being_dec_drive( local, DRIVE_HUNGER );
    }
}

void drives_sociability_loop_no_sim( simulated_being *other, void *data )
{
    drives_sociability_data *dsd = ( drives_sociability_data * )data;
    n_int   distance_squared;
    n_vect2 difference_vector;
    /* this needs to be checked against simulation near sight and sound values */
    const n_int apespace_span = 2; /*(10) >> APE_TO_MAP_BIT_RATIO; too low */
    being_delta( dsd->being, other, &difference_vector );
    /* los should not be used here, it's too expensive */
    distance_squared = vect2_dot( &difference_vector, &difference_vector, 1, 1 );
    if ( distance_squared < ( apespace_span * apespace_span ) )
    {
        dsd->beings_in_vacinity++;
    }
}

/**
 * @brief Social drive governs how likely the being is to interact with others.
 * This affects behaviors such as grooming, chatting and mating
 * @param local Pointer to the ape
 * @param group Pointer to the simulated_group
 */
static void drives_sociability(
    simulated_being *local,
    simulated_group *group )
{
    drives_sociability_data dsd;
    dsd.beings_in_vacinity = 0;
    dsd.being = local;
    loop_being_no_sim( group->beings, group->num, drives_sociability_loop_no_sim, &dsd );

    being_crowding_cycle( local, dsd.beings_in_vacinity );
}

/**
 * @brief Updates the sex drive
 * @param local Pointer to the ape
 * @param awake whether the ape is awake
 */
static void drives_sex(
    simulated_being *local,
    n_int awake )
{
    n_int i, max;
    simulated_isocial *local_social_graph = being_social( local );
    n_int age_in_days = AGE_IN_DAYS( local );

#ifdef EPISODIC_ON
    simulated_iepisodic *local_episodic = being_episodic( local );
#endif

    /** is the being mature */
    if ( age_in_days > AGE_OF_MATURITY )
    {
        /** is the being awake and its sex drive not saturated */
        if ( awake )
        {
            /** increase the sex drive */
            being_inc_drive( local, DRIVE_SEX );

            /** if sex drive is above a mate seeking threshold and
            the being has no current goal */
            if ( ( being_drive( local, DRIVE_SEX ) > THRESHOLD_SEEK_MATE ) &&
                    being_check_goal( local, GOAL_NONE ) )
            {
                /** either search for a preferred mate, or mate randomly */
                if ( GENE_MATE_SEEK( being_genetics( local ) ) & 1 )
                {
                    /** look for a mate */
#ifdef EPISODIC_ON
                    if ( !local_episodic )
                    {
                        return;
                    }

                    /** does the being remember mating in the recent past */
                    for ( i = 0; i < EPISODIC_SIZE; i++ )
                    {
                        if ( local_episodic[i].event == EVENT_MATE )
                        {
                            /** not someone else's mate */

                            if ( being_name_comparison( local, local_episodic[i].first_name[BEING_MEETER], local_episodic[i].family_name[BEING_MEETER] ) )
                            {
                                /** set a goal to seek the remembered mate */

                                being_set_goal_mate( local, local_episodic[i].first_name[BEING_MET], local_episodic[i].family_name[BEING_MET] );

                                /** remember seeking a mate */
                                episodic_store_memory(
                                    local, EVENT_SEEK_MATE, AFFECT_SEEK_MATE,
                                    being_gender_name( local ), being_family_name( local ),
                                    local->delta.goal[1], local->delta.goal[2], 0 );
                                break;
                            }
                        }
                    }
#endif
                    /** if the being is not seeking a remembered mate
                        then examine the social graph for attractive prospects */
                    if ( being_check_goal( local, GOAL_MATE ) == 0 )
                    {
                        max = 0;
                        if ( !local_social_graph )
                        {
                            return;
                        }

                        for ( i = 1; i < SOCIAL_SIZE_BEINGS; i++ )
                        {
                            if ( !SOCIAL_GRAPH_ENTRY_EMPTY( local_social_graph, i ) )
                            {
                                if ( ( local_social_graph[i].attraction ) > max )
                                {

                                    /** who are we most attracted to? */
                                    max = local_social_graph[i].attraction;

                                    being_set_goal_mate( local, local_social_graph[i].first_name[BEING_MET], local_social_graph[i].family_name[BEING_MET] );
                                }
                            }
                        }
                        /** if an attractive mate was found then remember this event */
                        if ( being_check_goal( local, GOAL_MATE ) )
                        {
                            episodic_store_memory(
                                local, EVENT_SEEK_MATE, AFFECT_SEEK_MATE,
                                being_gender_name( local ), being_family_name( local ),
                                local->delta.goal[1], local->delta.goal[2], 0 );
                        }
                    }
                }
            }
            /** during gestation reduce the sex drive */
            if ( being_pregnant( local ) != 0 )
            {
                if ( being_drive( local, DRIVE_SEX ) >= GESTATION_SEX_DRIVE_DECREMENT )
                {
                    being_dec_drive( local, DRIVE_SEX );
                }
            }
        }
        else
        {
            /** while sleeping reduce sex drive */
            being_dec_drive( local, DRIVE_SEX );
        }
        /** if sex drive falls below the mate seeking threshold and the being
            is seeking a mate, then stop seeking a mate */
        if ( ( being_drive( local, DRIVE_SEX ) < THRESHOLD_SEEK_MATE ) &&
                being_check_goal( local, GOAL_MATE ) )
        {
            being_set_goal_none( local );
        }
    }
}

/**
 * @brief Updates the fatigue drive.  This doesn't do much, but is
 * accessible to the braincode.
 * @param local Pointer to the ape
 */
void drives_fatigue(
    simulated_being *local )
{
    /** if the being is moving fast enough then increase the fatigue drive */
    if ( being_speed( local ) > FATIGUE_SPEED_THRESHOLD )
    {
        being_inc_drive( local, DRIVE_FATIGUE );
        /** Add extra fatigue when swimming */
        if ( being_state( local ) & BEING_STATE_SWIMMING )
        {
            being_inc_drive( local, DRIVE_FATIGUE );
        }
        /** As fatigue increases, sex drive decreases */
        being_dec_drive( local, DRIVE_SEX );
    }
    else
    {
        /** When resting fatigue drive decreases */
        being_dec_drive( local, DRIVE_FATIGUE );
    }
}

void drives_cycle( simulated_group *group, simulated_being *local_being, void *data )
{
    drives_hunger( local_being );
    drives_sociability( local_being, group );
    drives_sex( local_being, local_being->delta.awake );
    drives_fatigue( local_being );
}


/* ./entity/episodic.c */
/****************************************************************

 episodic.c

 =============================================================



 ****************************************************************/

/*! \file   episodic.c
 *  \brief  This handles episodic memory
 */

#include "entity.h"
#include "entity_internal.h"

/*! /file episodic.c
 * /brief Functions relating to updates of episodic memories and intentions.
 */

#ifdef EPISODIC_ON

static n_console_output *local_logging;
static n_int local_social;

void episodic_logging( n_console_output *output_function, n_int social )
{
    local_logging = output_function;
    local_social = social;
}

/**
 * @brief If the given episodic memory is an intention, as defined by the event type,
 * then update the learned preferences based upon the intention type.
 * For example, if the ape intends to chat then the chatting preference
 * may be increased which makes chatting more likely.
 * @param local pointer to the particular ape
 * @param episode_index array index of the episodic memory representing the intention
 */
static void episodic_intention_update( simulated_being *local, n_int episode_index )
{
    simulated_iepisodic *local_episodic = being_episodic( local );
    n_byte event;
    n_int learned_preference_index = -1;
    if ( local_episodic == 0L )
    {
        return;
    }
    event = local_episodic[episode_index].event - EVENT_INTENTION;
    switch ( event )
    {
    case EVENT_CHAT:
    {
        learned_preference_index = PREFERENCE_CHAT;
        break;
    }
    case EVENT_GROOM:
    {
        if ( ( local_episodic[episode_index].arg & 2 ) != 0 )
        {
            learned_preference_index = PREFERENCE_GROOM_MALE;
        }
        else
        {
            learned_preference_index = PREFERENCE_GROOM_FEMALE;
        }
        break;
    }
    }

    /** alter preferences */
    if ( learned_preference_index > -1 )
    {
        if ( ( local_episodic[episode_index].arg & 1 ) != 0 )
        {
            if ( local->changes.learned_preference[learned_preference_index] < 255 )
            {
                local->changes.learned_preference[learned_preference_index]++;
            }
        }
        else
        {
            if ( local->changes.learned_preference[learned_preference_index] > 0 )
            {
                local->changes.learned_preference[learned_preference_index]--;
            }
        }
    }
}

/**
 * @brief Update the episodic memories for a given ape.
 * This is based upon a fading memory model in which older memories
 * are replaced by newer ones.  Each memory has an associated affect
 * value indicating its emotional impact, and this fades over time.
 *
 * The rate of fading is genetically regulated, with different rates
 * for memories with positive and negative affect.
 * This facilitates optimistic/pessimistic and forgetful/memorable
 * type personalities.
 *
 * The fading memory model may not be strictly realistic, and might
 * be replaced by something else in future.
 * @param local_being pointer to the ape
 */
void episodic_cycle_no_sim( simulated_being *local_being )
{
    if ( local_being->delta.awake == 0 )
    {
        return;
    }
    {
        n_int i;
        simulated_iepisodic *local_episodic = being_episodic( local_being );
        n_genetics *genetics = being_genetics( local_being );

        if ( !local_episodic )
        {
            return;
        }

        for ( i = 0; i < EPISODIC_SIZE; i++ )
        {
            if ( local_episodic[i].event == 0 )
            {
                continue;
            }

            /** remove intentions which are outdated */
            if ( local_episodic[i].event >= EVENT_INTENTION )
            {
                /** is this my intention, or someone else's? */
                if ( being_name_comparison( local_being, local_episodic[i].first_name[BEING_MEETER], local_episodic[i].family_name[BEING_MEETER] ) )
                {
                    if ( spacetime_before_now( &local_episodic[i].space_time ) )
                    {
                        local_episodic[i].event = 0;
                        continue;
                    }
                }
                episodic_intention_update( local_being, i );
            }

            /** fade towards EPISODIC_AFFECT_ZERO */
            if ( local_episodic[i].affect < EPISODIC_AFFECT_ZERO )
            {
                /** negative memories fade */
                if ( EPISODIC_AFFECT_ZERO - local_episodic[i].affect > 16 )
                {
                    local_episodic[i].affect += ( 1 + GENE_NEGATIVE_AFFECT_FADE( genetics ) );
                }
                else
                {
                    local_episodic[i].affect++;
                }
            }
            else
            {
                if ( local_episodic[i].affect > EPISODIC_AFFECT_ZERO )
                {
                    /** positive memories fade */
                    if ( local_episodic[i].affect - EPISODIC_AFFECT_ZERO > 16 )
                    {
                        local_episodic[i].affect -= ( 1 + GENE_POSITIVE_AFFECT_FADE( genetics ) );
                    }
                    else
                    {
                        local_episodic[i].affect--;
                    }
                }
            }
        }
    }
}

/**
 * @brief Returns a celebrity factor based upon how many apes within
 * the episodic memory of the given ape have a similar name to the
 * met ape, and their friend or foe values.
 * This means that initial beliefs about other apes are partly
 * a form of stereotyping
 * @param meeter_being pointer to the ape
 * @param met_being pointer to another ape
 * @return celebrity value of the met ape
 */
n_int episodic_met_being_celebrity(
    simulated_being *meeter_being,
    simulated_being *met_being )
{
    n_int i, j, celebrity = 0, ctr, aff;
    simulated_iepisodic *meeter_episodic = being_episodic( meeter_being );
    n_byte2 first_name = being_gender_name( met_being );
    n_byte2 family_name = being_family_name( met_being );

    if ( !meeter_episodic )
    {
        return 0;
    }

    /** check all episodic memories of the meeter */
    for ( i = 0; i < EPISODIC_SIZE; i++ )
    {
        aff = ( n_int )( meeter_episodic[i].affect ) - EPISODIC_AFFECT_ZERO;
        if ( aff > 1 )
        {
            aff = 1;
        }
        if ( aff < -1 )
        {
            aff = -1;
        }

        /** check both the meeter and the met ape for each memory */
        for ( j = BEING_MEETER; j <= BEING_MET; j++ )
        {
            ctr = 0;
            /** same first name */
            if ( meeter_episodic[i].first_name[j] == first_name )
            {
                celebrity += aff;
                ctr++;
            }
            /** same family name */
            if ( meeter_episodic[i].family_name[j] == family_name )
            {
                celebrity += aff;
                ctr++;
            }
            /** if both first name and family name match then
            increase the celebrity value further */
            if ( ctr == 2 )
            {
                celebrity += aff * 2;
            }
        }
    }

    /** limit within range */
    if ( celebrity > 16 )
    {
        celebrity = 16;
    }
    if ( celebrity < -16 )
    {
        celebrity = -16;
    }
    return celebrity;
}

/**
 * @brief This returns the percentage of episodic memories or intentions which are first person.
 * Some memories originate from the self and others are acquired from others via chatting.
 * @param local pointer to the ape
 * @param intention 0=episodic memories, 1=intentions
 * @return percentage in the range 0-100
 */
n_int episodic_first_person_memories_percent(
    simulated_being *local,
    n_byte intention )
{
    n_int i, hits = 0, memories = 0;
    simulated_iepisodic *local_episodic = being_episodic( local );
    if ( local_episodic == 0L )
    {
        return 0;
    }

    /** examine all memories */
    for ( i = 0; i < EPISODIC_SIZE; i++ )
    {
        if ( local_episodic[i].event > 0 )
        {
            if ( intention != 0 )
            {
                /** ratio of intentions to other memories */
                if ( local_episodic[i].event >= EVENT_INTENTION )
                {
                    hits++;
                }
            }
            else
            {
                /** ratio of first person memories to other memories */
                if ( being_name_comparison( local, local_episodic[i].first_name[BEING_MEETER], local_episodic[i].family_name[BEING_MEETER] ) )
                {
                    hits++;
                }
            }
            memories++;
        }
    }
    if ( memories > 0 )
    {
        return hits * 100 / memories;
    }
    else
    {
        if ( intention != 0 )
        {
            return 0;
        }
        return 100;
    }
}

/**
 * @brief Returns the index of the the episodic memory which can be overwritten with a new one.
 * @param event The type of event
 * @param affect The affect value associated with the event
 * @param name1 Name of the first ape in the memory (meeter)
 * @param family1 Family name of the first ape in the memory (meeter)
 * @param name2 Name of the second ape in the memory (met)
 * @param family2 Family name of the second ape in the memory (met)
 * @param local Pointer to the ape
 * @return array index of the episodic memory which can be replaced.
 */
static n_int simulated_iepisodic_replace_index(
    being_episodic_event_type event,
    n_int affect,
    n_byte2 name1, n_byte2 family1,
    n_byte2 name2, n_byte2 family2,
    simulated_being *local )
{
    /** absolute affect value */
    n_int abs_aff = affect;
    n_int i;
    n_int replace = -1;
    n_int min;
    n_byte event_exists = 0;

    simulated_iepisodic *local_episodic = being_episodic( local );

    if ( !local_episodic )
    {
        return -1;
    }

    /** replace only events with an affect lower then the current */
    abs_aff = ABS( abs_aff );
    min = abs_aff;
    for ( i = 0; i < EPISODIC_SIZE; i++ )
    {
        /** is this the same type of event */
        if ( local_episodic[i].event == event )
        {
            /** is this the same being? */
            if ( ( local_episodic[i].first_name[BEING_MEETER] == name1 ) &&
                    ( local_episodic[i].family_name[BEING_MEETER] == family1 ) )
            {
                /** get absolute affect value */
                n_int aff1 = ABS( ( n_int )( local_episodic[i].affect ) - EPISODIC_AFFECT_ZERO );
                /** does this have the least affect (most forgettable) */
                event_exists = 1;
                if ( aff1 <= min )
                {
                    min = aff1;
                    replace = i;
                }
            }
        }
    }

    if ( event_exists == 0 )
    {
        /** Use any empty memory slots */
        for ( i = 0; i < EPISODIC_SIZE; i++ )
        {
            if ( local_episodic[i].event == 0 )
            {
                return i;
            }
        }

        /** no event of this type was found,
        so search for any event with the lowest affect */
        min = abs_aff;
        for ( i = 0; i < EPISODIC_SIZE; i++ )
        {
            /** get absolute affect value */
            n_int aff1 = ABS( ( n_int )( local_episodic[i].affect ) - EPISODIC_AFFECT_ZERO );
            /** does this have the least affect (most forgettable) */
            if ( aff1 < min )
            {
                min = aff1;
                replace = i;
            }
        }
    }

    return replace;
}

/**
 * @brief Stores an episodic memory
 * @param local Pointer to the being
 * @param event The type of event
 * @param affect Affect value associated with the event
 * @param name1 First name of a being participating in the event
 * @param family1 Family names of a being participating in the event
 * @param name2 First name of a second being participating in the event
 * @param family2 Family names of a second being participating in the event
 * @param arg Any additional argument
 * @param food Type of food
 */
static void episodic_store_full(
    simulated_being *local,
    being_episodic_event_type event,
    n_int affect,
    n_byte2 name1, n_byte2 family1,
    n_byte2 name2, n_byte2 family2,
    n_byte2 arg,
    n_byte food )
{
    simulated_iepisodic *local_episodic = being_episodic( local );
    n_int replace;
    n_byte  old_event;
    n_byte4 old_time;
    n_byte4 new_time;

    if ( local_episodic == 0L )
    {
        return;
    }

    if ( local->delta.awake == FULLY_ASLEEP )
    {
        return;
    }

    replace = simulated_iepisodic_replace_index( event, affect, name1, family1, name2, family2, local );

    if ( replace == -1 )
    {
        return;
    }

    old_event = local_episodic[replace].event;
    old_time = local_episodic[replace].space_time.time;

    /** insert the current event into the episodic memory */
    local_episodic[replace].event       = event;
    local_episodic[replace].affect      = ( n_byte2 )( affect + EPISODIC_AFFECT_ZERO );

    spacetime_set( &local_episodic[replace].space_time, being_location( local ) );

    new_time = local_episodic[replace].space_time.time;

    local_episodic[replace].first_name[BEING_MEETER] = name1;
    local_episodic[replace].family_name[BEING_MEETER] = family1;
    local_episodic[replace].first_name[BEING_MET] = name2;
    local_episodic[replace].family_name[BEING_MET] = family2;
    local_episodic[replace].food = food;
    local_episodic[replace].arg = arg;

    if ( ( event == 0 ) || ( event >= EVENTS ) )
    {
        ( void )SHOW_ERROR( "Event outside scope" );
    }

    if ( local_logging )
    {
        if ( ( old_event != event ) /*|| ((old_time+10) < (new_time))*/ ) /**< TODO this may need to be changed */
        {
            n_string_block description = {0};
            n_string_block str = {0};
            n_string_block time = {0};
            n_string_block combination = {0};
            n_int social_event;

            social_event = episode_description( local, replace, description );

            if ( ( local_social == 1 ) && ( social_event == 0 ) )
            {
                return;
            }

            being_name_simple( local, str );
            spacetime_to_string( time );
            io_three_string_combination( combination, time, str, description, 35 );

            ( *local_logging )( combination );
        }
    }
}
/**
 * @brief Remember eating
 * @param local Pointer to the being
 * @param energy Energy obtained from food
 * @param food_type The type of food
 */
void episodic_food( simulated_being *local, n_int energy, n_byte food_type )
{
    episodic_store_full( local, EVENT_EAT, energy,
                         being_gender_name( local ), being_family_name( local ),
                         0, 0, 0, food_type );
}

/**
 * @brief Updates the episodic memory with details about an event
 * @param local Pointer to the ape
 * @param event The type of event
 * @param affect The affect value associated with the event
 * @param name1 Name of the first ape in the memory (meeter)
 * @param family1 Family name of the first ape in the memory (meeter)
 * @param name2 Name of the second ape in the memory (met)
 * @param family2 Family name of the second ape in the memory (met)
 * @param arg Any additional arguments
 */
void episodic_store_memory(
    simulated_being *local,
    being_episodic_event_type event,
    AFFECT_TYPE affect,
    n_byte2 name1, n_byte2 family1,
    n_byte2 name2, n_byte2 family2,
    n_byte2 arg )
{
    episodic_store_full( local, event, affect, name1, family1, name2, family2, arg, 0 );
}
/**
 * @brief Store an episodic memory about the self
 * @param local Pointer to the being
 * @param event The type of event
 * @param affect An affect value associated with the event
 * @param arg Any additional argument
 */
void episodic_self(
    simulated_being *local,
    being_episodic_event_type event,
    AFFECT_TYPE affect,
    n_byte2 arg )
{
    episodic_store_memory( local, event, affect,
                           being_gender_name( local ), being_family_name( local ),
                           0, 0, arg );
}
/**
 * @brief Remember an event which occurred between being in close proximity
 * @param local Pointer to the first being
 * @param other Pointer to the second being
 * @param event The type of event
 * @param affect Affect value associated with the event
 * @param arg Any additional argument
 */
void episodic_close(
    simulated_being *local,
    simulated_being *other,
    being_episodic_event_type event,
    AFFECT_TYPE affect,
    n_byte2 arg )
{
    episodic_store_memory(
        local, event, affect,
        being_gender_name( other ), being_family_name( other ),
        0, 0, arg );
}
/**
 * @brief Remember a particular interaction between two beings
 * @param local Pointer to the being
 * @param other Pointer to the being being interacted with
 * @param event The type of event
 * @param affect The affect associated with the interaction
 * @param arg Any additional argument
 */
void episodic_interaction(
    simulated_being *local,
    simulated_being *other,
    being_episodic_event_type event,
    AFFECT_TYPE affect,
    n_byte2 arg )
{
    episodic_store_memory(
        local, event, affect,
        being_gender_name( local ), being_family_name( local ),
        being_gender_name( other ), being_family_name( other ), arg );
}

/**
 * @brief Generate an intention.
 * Note that intentions are stored together with episodic memories,
 * with the event type making the difference between a memory about
 * the past and an intention about the future.
 * @param local Pointer to the ape
 * @param episode_index Episodic memory array index to use.
 * @param mins_ahead The number of minutes into the future for which the intention will last.
 * @param args Any additional arguments
 * @return Returns 1 if the update was successful, or 0 otherwise.
 */
n_byte episodic_intention(
    simulated_being *local,
    n_int episode_index,
    n_byte2 mins_ahead,
    n_byte args )
{
    n_byte4 date;
    n_byte4 time;
    n_int   replace;
    n_byte  event;

    simulated_iepisodic *local_episodic = being_episodic( local );

    if ( local_episodic == 0L )
    {
        return 0;
    }

    event = local_episodic[episode_index].event;

    if ( event == 0 )
    {
        return 0;
    }

    time = land_time();
    date = local_episodic[episode_index].space_time.date;
    if ( time >= TIME_DAY_MINUTES )
    {
        /** increment date by one day */
        time %= TIME_DAY_MINUTES;
        date++;
    }

    if ( event >= EVENT_INTENTION )
    {
        /** extend the time of an existing intention */
        local_episodic[episode_index].space_time.time = time;
        local_episodic[episode_index].space_time.date = date;
        local_episodic[episode_index].arg = args;
        /** if this was someone else's intention it now becomes yours */
        local_episodic[episode_index].first_name[BEING_MEETER] = being_gender_name( local );
        local_episodic[episode_index].family_name[BEING_MEETER] = being_family_name( local );
        return 1;
    }

    /** only certain types of events become intentions */
    if ( !( ( event == EVENT_GROOM ) || ( event == EVENT_CHAT ) ) )
    {
        return 0;
    }

    /** find a memory index to replace */
    replace = simulated_iepisodic_replace_index(
                  EVENT_INTENTION + event,
                  ( n_int )( local_episodic[episode_index].affect ) - EPISODIC_AFFECT_ZERO,
                  being_gender_name( local ),
                  being_family_name( local ),
                  local_episodic[episode_index].first_name[BEING_MET],
                  local_episodic[episode_index].family_name[BEING_MET],
                  local );

    if ( replace == -1 )
    {
        return 0;
    }

    if ( replace == episode_index )
    {
        return 0;
    }

    memory_copy( ( n_byte * )&local_episodic[episode_index], ( n_byte * )&local_episodic[replace], sizeof( simulated_iepisodic ) );

    local_episodic[replace].event = EVENT_INTENTION + event;

    local_episodic[replace].space_time.time = time;
    local_episodic[replace].space_time.date = date;

    local_episodic[replace].first_name[BEING_MEETER] = being_gender_name( local );
    local_episodic[replace].family_name[BEING_MEETER] = being_family_name( local );

    local_episodic[replace].arg = args;

    return 1;
}

/**
 * @brief Copy an episodic memory (an anecdote) from one ape to another during chat.
 * @param local Pointer to the ape conveying the anecdote
 * @param other Pointer to the ape to which the anecdote will be copied
 * @return Returns 1 if the copy was successful, 0 otherwise
 */
n_byte episodic_anecdote(
    simulated_being *local,
    simulated_being *other )
{
    simulated_iepisodic *local_episodic = being_episodic( local );
    simulated_iepisodic *other_episodic = being_episodic( other );
    n_int affect;
    n_byte event;
    n_int replace, mult = 1;

    if ( local_episodic == 0L || other_episodic == 0L || local == other )
    {
        return 0;
    }

    affect = ( n_int )( local_episodic[being_attention( local, ATTENTION_EPISODE )].affect ) - EPISODIC_AFFECT_ZERO;
    event = local_episodic[being_attention( local, ATTENTION_EPISODE )].event;

    /** both protagonists must be awake */
    if ( ( event == 0 ) ||
            ( local->delta.awake == FULLY_ASLEEP ) ||
            ( other->delta.awake == FULLY_ASLEEP ) )
    {
        return 0;
    }

    if ( local->delta.awake != FULLY_AWAKE )
    {
        /** more likely to make errors while drowsy */
        mult = 2;
    }

    /** mutate with some probability */
    if ( being_random( local ) <
            ( ANECDOTE_EVENT_MUTATION_RATE +
              ( local->changes.learned_preference[PREFERENCE_ANECDOTE_EVENT_MUTATION] ) * 100 )*mult )
    {
        event = ( n_byte )( being_random( local ) % EVENTS );
    }
    if ( being_random( local ) <
            ( ANECDOTE_AFFECT_MUTATION_RATE +
              ( local->changes.learned_preference[PREFERENCE_ANECDOTE_AFFECT_MUTATION] ) * 100 )*mult )
    {
        /** affect gets exaggerated or downplayed */
        affect = ( affect * ( 64 + ( n_int )( being_random( local ) & 127 ) ) ) / 128;
        /** keep affect within range */
        if ( affect < -32000 )
        {
            affect = -32000;
        }
        if ( affect > 32000 )
        {
            affect = 32000;
        }
    }

    /** find an index within the other episodic memory in which to insert */
    replace = simulated_iepisodic_replace_index(
                  event, affect,
                  local_episodic[being_attention( local, ATTENTION_EPISODE )].first_name[BEING_MEETER],
                  local_episodic[being_attention( local, ATTENTION_EPISODE )].family_name[BEING_MEETER],
                  local_episodic[being_attention( local, ATTENTION_EPISODE )].first_name[BEING_MET],
                  local_episodic[being_attention( local, ATTENTION_EPISODE )].family_name[BEING_MET],
                  local );

    if ( replace == -1 )
    {
        return 0;
    }

    other_episodic[replace] = local_episodic[being_attention( local, ATTENTION_EPISODE )];
    other_episodic[replace].event = event;
    other_episodic[replace].affect = ( n_byte2 )( affect + EPISODIC_AFFECT_ZERO );

    /** other ape pays attention to the incoming anecdote */
    being_set_attention( local, ATTENTION_EPISODE, replace );

    return 1;
}

#else

/**
 * An empty function
 */
void episodic_interaction(
    simulated_being *local,
    simulated_being *other,
    being_episodic_event_type event,
    AFFECT_TYPE affect,
    n_byte2 arg )
{

}

/**
 * An empty function
 */
void episodic_store_memory(
    simulated_being *local,
    being_episodic_event_type event,
    AFFECT_TYPE affect,
    n_byte2 name1, n_byte2 family1,
    n_byte2 name2, n_byte2 family2,
    n_byte2 arg )
{
}

#endif




/* ./entity/food.c */
/****************************************************************

 food.c

 =============================================================



 ****************************************************************/

/*! \file   food.c
 *  \brief  Functions related to eating
 */

#include "entity.h"
#include "entity_internal.h"

/** Various energy use and addition through eating characteristics */
/** Energy from vegetables */

#define GENE_ENERGY_FROM_VEGETABLES(gene)   GENE_VAL_REG(gene, 3, 13, 15, 3)

/** Energy from fruits */

#define GENE_ENERGY_FROM_FRUITS(gene)       GENE_VAL_REG(gene, 14, 7, 6, 4)

/** Energy from shellfish */

#define GENE_ENERGY_FROM_SHELLFISH(gene)    GENE_VAL_REG(gene, 10, 12, 12, 2)

/** Energy from seaweed */

#define GENE_ENERGY_FROM_SEAWEED(gene)      GENE_VAL_REG(gene, 0, 9, 11, 12)

/** Energy from bird eggs */

#define GENE_ENERGY_FROM_BIRD_EGGS(gene)    GENE_VAL_REG(gene, 7, 1, 9, 5)

/** Energy from lizard eggs */

#define GENE_ENERGY_FROM_LIZARD_EGGS(gene)  GENE_VAL_REG(gene, 15, 3, 12, 8)


/**
 * @brief How much energy is absorbed from a given type of food
 * @param food_type The type of food
 * @param local pointer to the ape
 * @return Energy absorbed
 */
n_int food_absorption( simulated_being *local, n_int max_energy, n_byte food_type )
{
    n_genetics *genetics = being_genetics( local );

    n_int   vegetable = GENE_ENERGY_FROM_VEGETABLES( genetics );
    n_int   fruit = GENE_ENERGY_FROM_FRUITS( genetics );
    n_int   shellfish = GENE_ENERGY_FROM_SHELLFISH( genetics );
    n_int   seawood = GENE_ENERGY_FROM_SEAWEED( genetics );

    n_int   bird_eggs = GENE_ENERGY_FROM_BIRD_EGGS( genetics );
    n_int   lizard_eggs = GENE_ENERGY_FROM_LIZARD_EGGS( genetics );

    n_int        return_value = 0;
    /** note that the absorbition for different foods is normalised */
    n_int absorb_denom = 1 + vegetable + fruit + seawood + bird_eggs + lizard_eggs;

    /** ingest pathogens from certain foods */
    immune_ingest_pathogen( &local->immune_system, food_type );

    switch ( food_type )
    {
    case FOOD_VEGETABLE:
#ifdef DEBUG_LACK_OF_MOVEMENT
    {
        n_string_block information_string;
        sprintf( information_string, "vegetable %ld absorbtion %ld food", vegetable, absorb_denom );
        being_register_movement( local, information_string );
    }
#endif
    return_value = ( vegetable << 4 ) / absorb_denom;
    break;
    case FOOD_FRUIT:
#ifdef DEBUG_LACK_OF_MOVEMENT
        being_register_movement( local, "fruit food" );
#endif
        return_value = ( fruit << 4 ) / absorb_denom;
        break;
    case FOOD_SHELLFISH:
#ifdef DEBUG_LACK_OF_MOVEMENT
        being_register_movement( local, "shellfish food" );
#endif
        return_value = ( shellfish << 4 ) / absorb_denom;
        break;
    case FOOD_SEAWEED:
#ifdef DEBUG_LACK_OF_MOVEMENT
        being_register_movement( local, "seaweed food" );
#endif
        return_value = ( seawood << 4 ) / absorb_denom;
        break;
    case FOOD_BIRD_EGGS:
#ifdef DEBUG_LACK_OF_MOVEMENT
        being_register_movement( local, "bird egg food" );
#endif
        return_value = ( seawood << 4 ) / absorb_denom;
        break;
    case FOOD_LIZARD_EGGS:
#ifdef DEBUG_LACK_OF_MOVEMENT
        being_register_movement( local, "lizard egg food" );
#endif
        return_value = ( seawood << 4 ) / absorb_denom;
        break;
    default:
#ifdef DEBUG_LACK_OF_MOVEMENT
        being_register_movement( local, "no food" );
#endif
        return 0;
    }

    return_value = ( max_energy * ( 1 + return_value ) >> 3 );

    if ( return_value > 320 )
    {
        return_value = 320; /**< can only eat so much in one go */
    }
    return return_value;
}

/**
 * @brief Returns the amount of food of the given type at the given location
 * @param loc_x x coordinate
 * @param loc_y y coordinate
 * @param kind The type of food
 * @return The amount of food of the given type at this location
 */
static n_int food_location( n_int loc_x,
                            n_int loc_y,
                            n_int kind )
{
    return land_operator_interpolated( loc_x, loc_y,
                                       ( n_byte * )&operators[kind - VARIABLE_BIOLOGY_AREA] );
}

/**
 * @brief Returns the values for grass, trees and bushes at the given location
 * @param loc_x X ape coordinate on the map
 * @param loc_y Y ape coordinate on the lap
 * @param grass Returned value for grass
 * @param trees Returned value for trees
 * @param bush Returned value for bushes
 */
void food_values( n_int loc_x,
                  n_int loc_y,
                  n_int *grass, n_int *trees, n_int *bush )
{
    /* TODO include bird and lizard eggs */

    /** grass at this location */
    *grass =
        food_location( loc_x, loc_y, VARIABLE_BIOLOGY_GRASS ) + OFFSET_GRASS;

    /** trees at this location */
    *trees =
        food_location( loc_x, loc_y, VARIABLE_BIOLOGY_TREE );

    /** bushes at this location */
    *bush =
        food_location( loc_x, loc_y, VARIABLE_BIOLOGY_BUSH ) + OFFSET_BUSH;

    *grass += LAND_DITHER( *grass, *trees, *bush );
}

/**
 * @brief Returns the dominant food type on land and its associated maximum energy value
 * @param loc_x X ape coordinate
 * @param loc_y Y ape coordinate
 * @param energy Returned maximum energy value for the food type
 * @return The type of food
 */
static n_byte food_eat_land(
    n_int loc_x,
    n_int loc_y,
    n_int *energy )
{
    n_byte food_type = FOOD_VEGETABLE;
    n_int grass, trees, bush;

    /* TODO Handle this logic centrally - including the int values in the function not outside */

    food_values( loc_x, loc_y, &grass, &trees, &bush );

    /** which is the dominant form of vegetation in this area? */
    if ( ( grass > bush ) && ( grass > trees ) )
    {
        *energy = ENERGY_GRASS;
    }
    else
    {
        if ( bush > trees )
        {
            *energy = ENERGY_BUSH;
        }
        else
        {
            *energy = ENERGY_FRUIT;
            food_type = FOOD_FRUIT;
        }
    }
    return food_type;
}

/**
 * @brief Returns the dominant food type in the intertidal zone and its associated maximum energy value
 * @param loc_x X ape coordinate
 * @param loc_y Y ape coordinate
 * @param energy Returned maximum energy value for the food type
 * @return The type of food
 */
static n_byte food_intertidal(
    n_int loc_x,
    n_int loc_y,
    n_int *energy )
{
    n_byte food_type = FOOD_VEGETABLE;
    n_int seaweed, rockpool, beach;

    /** seaweed at this location */
    seaweed =
        food_location( loc_x, loc_y, VARIABLE_BIOLOGY_SEAWEED );

    /** rockpools at this location */
    rockpool =
        food_location( loc_x, loc_y, VARIABLE_BIOLOGY_ROCKPOOL );

    /** beach at this location */
    beach =
        food_location( loc_x, loc_y, VARIABLE_BIOLOGY_BEACH );

    beach += LAND_DITHER( seaweed, rockpool, beach );

    /** which is the dominant form of food in this area? */
    if ( ( seaweed > rockpool ) && ( seaweed > beach ) )
    {
        *energy = ENERGY_SEAWEED;
        food_type = FOOD_SEAWEED;
    }
    else
    {
        if ( rockpool > beach )
        {
            *energy = ENERGY_SHELLFISH;
            food_type = FOOD_SHELLFISH;
        }
    }
    return food_type;
}

/**
 * @brief Eat food at the given location and return the energy increase
 * @param loc_x X ape coordinate
 * @param loc_y Y ape coordinate
 * @param az Z ape coordinate
 * @param local_being Pointer to the ape
 * @return Energy obtained from the food
 */
n_int food_eat(
    n_int loc_x,
    n_int loc_y,
    n_int az,
    n_byte *food_type,
    simulated_being *local_being )
{
    n_int max_energy = BEING_DEAD;

    *food_type = FOOD_VEGETABLE;

    if ( az > TIDE_MAX )
    {
        /** above the high water mark */
        *food_type = food_eat_land( loc_x, loc_y, &max_energy );
    }
    else
    {
        /** in the intertidal zone */
        *food_type = food_intertidal( loc_x, loc_y, &max_energy );
    }

    return food_absorption( local_being, max_energy, *food_type );
}


/* ./entity/immune.c */
/****************************************************************

 immune.c

 =============================================================



 ****************************************************************/

#include "toolkit.h"
#include "universe.h"

#define IMMUNE_FIT                            5
#define MIN_ANTIBODIES                        16
#define MIN_ANTIGENS                          8
#define PATHOGEN_TRANSMISSION_PROB            1000
#define PATHOGEN_ENVIRONMENT_PROB             100
#define PATHOGEN_MUTATION_PROB                100
#define ANTIBODY_DEPLETION_PROB               100

#define RANDOM_PATHOGEN(seed,pathogen_type)   (((seed%(255/PATHOGEN_TRANSMISSION_TOTAL))*PATHOGEN_TRANSMISSION_TOTAL)+pathogen_type)
#define PATHOGEN_SEVERITY(pathogen)           (((pathogen)*(pathogen))>>11)
#define PATHOGEN_TRANSMISSION(pathogen)       ((pathogen)&7)

void immune_init( simulated_immune_system *immune, n_byte2 *local_random )
{
#ifdef IMMUNE_ON
    n_byte i;
    immune->random_seed[0] = local_random[0];
    immune->random_seed[1] = local_random[1];

    for ( i = 0; i < IMMUNE_ANTIGENS; i += 2 )
    {
        immune->antigens[i] = 0;
        immune->antigens[i + 1] = 0;
        math_random3( immune->random_seed );
        immune->shape_antigen[i] = ( n_byte )( immune->random_seed[0] & 255 );
        immune->shape_antigen[i + 1] = ( n_byte )( immune->random_seed[1] & 255 );
    }
    for ( i = 0; i < IMMUNE_POPULATION; i += 2 )
    {
        immune->antibodies[i] = 0;
        immune->antibodies[i + 1] = 0;
        math_random3( immune->random_seed );
        immune->shape_antibody[i] = ( n_byte )( immune->random_seed[0] & 255 );
        immune->shape_antibody[i + 1] = ( n_byte )( immune->random_seed[1] & 255 );
    }
#endif
}

void immune_seed( simulated_immune_system *immune_mother, simulated_immune_system *immune_child )
{
#ifdef IMMUNE_ON
    n_byte i;
    /** child acquires mother's antibodies */
    for ( i = 0; i < IMMUNE_POPULATION; i++ )
    {
        immune_child->shape_antibody[i] = immune_mother->shape_antibody[i];
        immune_child->antibodies[i] = immune_mother->antibodies[i];
    }
#endif
}

static void immune_acquire_pathogen( simulated_immune_system *immune, n_byte transmission_type )
{
#ifdef IMMUNE_ON
    n_byte i;
    math_random3( ( n_byte2 * )&immune->random_seed );
    if ( immune->random_seed[0] < PATHOGEN_ENVIRONMENT_PROB )
    {
        i = immune->random_seed[1] % IMMUNE_ANTIGENS;
        if ( immune->antigens[i] == 0 )
        {
            math_random3( ( n_byte2 * )&immune->random_seed );
            immune->antigens[i] = ( n_byte )( immune->random_seed[0] & 7 );
            immune->shape_antigen[i] = ( n_byte )RANDOM_PATHOGEN( immune->random_seed[1], transmission_type );
        }
    }
#endif
}

void immune_ingest_pathogen( simulated_immune_system *immune, n_byte food_type )
{
    n_byte transmission_type = food_type + PATHOGEN_TRANSMISSION_FOOD_VEGETABLE;
    immune_acquire_pathogen( immune, transmission_type );
}

void immune_transmit( simulated_immune_system *immune0, simulated_immune_system *immune1, n_byte transmission_type )
{
#ifdef IMMUNE_ON
    n_byte i, j;
    /** pathogen obtained from environment */
    immune_acquire_pathogen( immune0, transmission_type );

    /** pathogen transmitted between beings */
    math_random3( ( n_byte2 * )&immune0->random_seed );
    if ( immune0->random_seed[0] < PATHOGEN_TRANSMISSION_PROB )
    {
        math_random3( ( n_byte2 * )&immune0->random_seed );
        i = immune0->random_seed[0] % IMMUNE_ANTIGENS;
        if ( ( immune0->antigens[i] > 0 ) &&
                ( PATHOGEN_TRANSMISSION( immune0->shape_antigen[i] ) == transmission_type ) )
        {
            /** does the other being already carry this pathogen ? */
            for ( j = 0; j < IMMUNE_ANTIGENS; j++ )
            {
                if ( immune0->shape_antigen[i] == immune1->shape_antigen[j] )
                {
                    if ( immune1->antigens[j] < 255 )
                    {
                        immune1->antigens[j]++;
                    }
                    break;
                }
            }
            if ( j == IMMUNE_ANTIGENS )
            {
                j = immune0->random_seed[1] % IMMUNE_ANTIGENS;
                if ( immune1->antigens[j] <= MIN_ANTIGENS )
                {
                    /** spread pathogen */
                    immune1->shape_antigen[j] = immune0->shape_antigen[i];
                }
            }
        }
    }
#endif
}

n_int immune_response( simulated_immune_system *immune, n_byte honor_immune, n_int being_energy )
{
#ifdef IMMUNE_ON
    n_int min_antibodies;
    n_int max_bits_matched;
    n_byte2 total_antigens, max_severity;
    n_byte i, j, k, match, best_match, bits_matched, bit;

    /** antibodies die at some fixed rate */
    math_random3( ( n_byte2 * )&immune->random_seed );
    if ( immune->random_seed[0] < ANTIBODY_DEPLETION_PROB )
    {
        i = immune->random_seed[1] % IMMUNE_POPULATION;
        if ( immune->antibodies[i] > 0 )
        {
            immune->antibodies[i]--;
        }
    }

    /** pick an antigen */
    math_random3( ( n_byte2 * )&immune->random_seed );
    i = immune->random_seed[0] % IMMUNE_ANTIGENS;
    if ( immune->antigens[i] != 0 )
    {
        /** mutate with some probability */
        if ( immune->random_seed[1] < PATHOGEN_MUTATION_PROB )
        {
            math_random3( ( n_byte2 * )&immune->random_seed );
            if ( ( immune->shape_antigen[i] & ( 1 << ( immune->random_seed[0] & 7 ) ) ) != 0 )
            {
                immune->shape_antigen[i] ^= ( immune->random_seed[0] & 7 );
            }
            else
            {
                immune->shape_antigen[i] |= ( immune->random_seed[0] & 7 );
            }
        }

        /** try to find a matching antibody */
        max_bits_matched = 0;
        best_match = 0;
        for ( j = 0; j < IMMUNE_POPULATION; j++ )
        {
            match = ( immune->shape_antibody[j] & immune->shape_antigen[i] ) |
                    ( ( ~immune->shape_antibody[j] ) & ( ~immune->shape_antigen[i] ) );
            if ( match != 0 )
            {
                /** how good is the fit ? */
                bits_matched = 0;
                for ( bit = 0; bit < 8; bit++ )
                {
                    if ( ( match & ( 1 << bit ) ) != 0 )
                    {
                        bits_matched++;
                    }
                }
                /** record best fit */
                if ( bits_matched > max_bits_matched )
                {
                    max_bits_matched = bits_matched;
                    best_match = j;
                }
            }
        }

        /** select the antibody with the smallest population */
        min_antibodies = immune->antibodies[0];
        j = 0;
        for ( k = 1; k < IMMUNE_POPULATION; k++ )
        {
            if ( immune->antibodies[k] < min_antibodies )
            {
                min_antibodies = immune->antibodies[k];
                j = k;
            }
        }

        /** match antigen and antibody */
        if ( max_bits_matched > IMMUNE_FIT )
        {
            /** Antibodies multiply
             A better fit results in more antibodies */
            if ( immune->antibodies[best_match] < 255 - max_bits_matched )
            {
                immune->antibodies[best_match] += ( n_byte )max_bits_matched;
                /** apply a minimum threshold so that generated
                 antibodies don't overwrite known good fits */
                if ( immune->antibodies[best_match] < MIN_ANTIBODIES )
                {
                    immune->antibodies[best_match] = MIN_ANTIBODIES;
                }
            }
            /** antigens are depleted according to the immune system strength */
            if ( immune->antigens[i] > honor_immune )
            {
                immune->antigens[i] -= honor_immune;
            }
            else
            {
                immune->antigens[i] = 0;
            }
            /** clone antibody with mutation */
            if ( j != best_match )
            {
                immune->antibodies[j] = 1;
                match = immune->shape_antibody[best_match];
                math_random3( ( n_byte2 * )&immune->random_seed );
                if ( ( match & ( 1 << ( immune->random_seed[0] & 7 ) ) ) != 0 )
                {
                    match ^= ( immune->random_seed[0] & 7 );
                }
                else
                {
                    match |= ( immune->random_seed[0] & 7 );
                }
                immune->shape_antibody[j] = match;
            }
        }
        else
        {
            /** If pathogens are not challenged they multiply */
            if ( immune->antigens[i] < 255 )
            {
                immune->antigens[i]++;
            }

            /** produce differently shaped antibodies */
            math_random3( ( n_byte2 * )&immune->random_seed );
            if ( immune->random_seed[0] < being_energy )
            {
                math_random3( ( n_byte2 * )&immune->random_seed );
                immune->shape_antibody[j] = ( n_byte )( immune->random_seed[0] & 255 );
                immune->antibodies[j] = ( n_byte )( immune->random_seed[1] & 7 );
            }
        }
    }

    /** Energy level is reduced based upon pathogens.
     Note that not all pathogens have the same energy cost. */
    total_antigens = 0;
    max_severity = 0;
    for ( i = 0; i < IMMUNE_ANTIGENS; i++ )
    {
        /* total quantity of pathogen */
        total_antigens += immune->antigens[i];
        /* record the maximum pathogen severity */
        if ( immune->shape_antigen[i] > max_severity )
        {
            max_severity = immune->shape_antigen[i];
        }
    }
    math_random3( ( n_byte2 * )&immune->random_seed );
    if ( ( immune->random_seed[0] < ( total_antigens >> 2 ) ) && ( being_energy >= 1 ) )
    {
        return PATHOGEN_SEVERITY( max_severity );
    }
#endif
    return 0;
}


/* ./entity/social.c */
/****************************************************************

 social.c

 =============================================================



 ****************************************************************/

/*! \file   social.c
 *  \brief  This handles social interactions and management of the social graph
 */

#include "entity.h"
#include "entity_internal.h"

/** Status preference */

#define GENE_STATUS_PREFERENCE(gene)        GENE_VAL_REG(gene, 15, 12, 10, 1)

/** Pigmentation preference */

#define GENE_PIGMENTATION_PREFERENCE(gene)  GENE_VAL_REG(gene, 5, 3, 11, 4)

/** mating preference for height */

#define GENE_HEIGHT_PREFERENCE(gene)        GENE_VAL_REG(gene, 9, 8, 14, 10)

/** mating preference for frame */

#define GENE_FRAME_PREFERENCE(gene)         GENE_VAL_REG(gene, 9, 0, 8, 2)

/** mating preference for hair length */

#define GENE_HAIR_PREFERENCE(gene)          GENE_VAL_REG(gene, 10, 7, 14, 15)

/** Groom */

#define GENE_GROOM(gene)                    GENE_VAL_REG(gene, 14, 2, 5, 10)

/** Aggression */

#define GENE_AGGRESSION(gene)               GENE_VAL_REG(gene, 11, 3, 5, 0)

/** Mate bond */

#define GENE_MATE_BOND(gene)                GENE_VAL_REG(gene, 10, 2, 4, 0)

/** Degree of aversion to incest */

#define GENE_INCEST_AVERSION(gene)          GENE_VAL_REG(gene, 10, 8, 4, 9)

/** Latent energy use */

#define GENE_LATENT_ENERGY_USE(gene)        GENE_VAL_REG(gene, 14, 3, 6, 10)

#ifdef FEATURE_SET

static void simulated_feature_copy( simulated_feature *to, simulated_feature *from )
{
    to->type = from->type;
    to->value = from->value;
    to->frequency = from->frequency;
}

static void simulated_feature_set( simulated_feature *to, n_byte feature_type, n_byte2 feature_value )
{
    to->type =  ( n_byte )feature_type;
    to->value =  ( n_byte2 )feature_value;
    to->frequency = ( n_byte2 )1;
}

/**
 * @brief Returns the array index of a given feature type within a set
 * @param s A set of features
 * @param feature_type the feature type
 * @return array index of a given feature type within a set
 */
static n_int simulated_featureset_feature_index( simulated_featureset *s,
        n_byte feature_type )
{
    n_int i = 0;

    while ( i < s->feature_number )
    {
        if ( s->features[i].type >= feature_type )
        {
            break;
        }
        i++;
    }
    if ( i == s->feature_number )
    {
        return -1;
    }
    return i;
}

/**
 * @brief Normalises the feature frequencies within a set
 * @param s a set of features
 */
static void simulated_featureset_normalise_feature_frequencies( simulated_featureset *s )
{
    n_uint i, tot = 0;
    n_uint max = MAX_FEATURE_FREQUENCY >> 1;

    /** get the total frequency count */
    for ( i = 0; i < s->feature_number; i++ )
    {
        tot += ( n_uint )s->features[i].frequency;
    }

    if ( tot == 0 )
    {
        tot = 1;
    }

    for ( i = 0; i < s->feature_number; i++ )
    {
        s->features[i].frequency = ( n_byte2 )( ( n_uint )s->features[i].frequency * max / tot );
    }
}

/**
 * @brief Adds a feature to the given set
 * @param s Pointer to the feature set
 * @param feature_type the type of feature
 * @param feature_value value of the feature
 * @return 0 on success, -1 otherwise
 */
static n_int simulated_featureset_update( simulated_featureset *s,
        n_byte feature_type,
        n_int feature_value )
{
    /** get the index of the feature within the array */
    n_int feature_index = simulated_featureset_feature_index( s, feature_type );
    n_byte2 min;
    n_int i, j;

    if ( s->features[feature_index].type == ( n_byte )feature_type )
    {
        /** alter the value associated with an existing feature type */
        s->features[feature_index].value = ( n_byte2 )feature_value;
        s->features[feature_index].frequency++;
        /** normalise the feature frequencies to prevent them
            from going out of bounds */
        if ( s->features[feature_index].frequency > MAX_FEATURE_FREQUENCY )
        {
            simulated_featureset_normalise_feature_frequencies( s );
        }
        return 0;
    }
    else
    {
        if ( s->feature_number < MAX_FEATURESET_SIZE )
        {
            /** add a new feature type to the array */
            if ( s->feature_number > 1 )
            {
                for ( i = ( n_int )s->feature_number - 1; i >= ( n_int )feature_index; i-- )
                {
                    simulated_feature_copy( &( s->features[i + 1] ), &( s->features[i] ) );
                }
            }

            i = feature_index;
            s->feature_number++;
            simulated_feature_set( &( s->features[i] ), ( n_byte )feature_type, ( n_byte2 )feature_value );
            return 0;
        }
        else
        {
            /** pick the least frequent feature and replace it */
            min = s->features[0].frequency;
            feature_index = 0;
            for ( i = 1; i < ( n_int )s->feature_number; i++ )
            {
                if ( s->features[i].frequency < min )
                {
                    min = s->features[i].frequency;
                    feature_index = i;
                }
            }
            /** re-sort */
            j = 0;
            for ( i = 0; i < ( n_int )s->feature_number; i++ )
            {
                if ( s->features[i].type >= ( n_byte )feature_type )
                {
                    j = i;
                    break;
                }
            }
            for ( i = ( n_int )feature_index; i > j; i-- )
            {
                simulated_feature_copy( &( s->features[i] ), &( s->features[i - 1] ) );
            }


            simulated_feature_set( &( s->features[j] ), ( n_byte )feature_type, ( n_byte2 )feature_value );

            for ( i = 0; i < ( n_int )s->feature_number; i++ )
            {
                for ( j = i + 1; j < ( n_int )s->feature_number; j++ )
                {
                    if ( s->features[j].type < s->features[i].type )
                    {
                        feature_type = s->features[i].type;
                        s->features[i].type = s->features[j].type;
                        s->features[j].type = ( n_byte )feature_type;
                    }
                }
            }
        }
    }
    return -1;
}

static n_int featureset_match_threshold( n_byte feature_type )
{
    if ( feature_type == FEATURESET_TERRITORY )
    {
        return 1;
    }
    return 2;
}

/**
 * @brief Normalises the number of observations for each stereotype
 * @param local_being Pointer to the being
 */
static void social_normalise_stereotype_observations(
    simulated_being *local_being )
{
    simulated_isocial *graph;
    n_uint i, tot = 0;
    simulated_featureset *s;
    n_uint max = MAX_FEATURESET_OBSERVATIONS >> 1;

    /** Get the social graph */
    graph = being_social( local_being );

    if ( graph == 0 )
    {
        return;
    }

    for ( i = SOCIAL_SIZE_BEINGS; i < SOCIAL_SIZE; i++ )
    {
        if ( !SOCIAL_GRAPH_ENTRY_EMPTY( graph, i ) )
        {
            s = &graph[i].classification;
            tot += ( n_uint )s->observations;
        }
    }

    if ( tot == 0 )
    {
        return;
    }

    for ( i = SOCIAL_SIZE_BEINGS; i < SOCIAL_SIZE; i++ )
    {
        if ( !SOCIAL_GRAPH_ENTRY_EMPTY( graph, i ) )
        {
            s = &graph[i].classification;
            s->observations =
                ( n_byte2 )( ( n_uint )s->observations * max / tot );
        }
    }
}

/**
 * @brief Returns the social graph array index of the closest matching
 *        stereotype to the met being
 * @param meeter_being Pointer to the being doing the meeting
 * @param social_graph_index Social graph index of the being which was met
 * @return Social graph array index of the closest stereotype
 *         or -1 of there are no stereotypes
 */
static n_int social_get_stereotype(
    simulated_being *meeter_being,
    n_int social_graph_index )
{
    n_int i, j, diff, dv, index, hits, min = 0, result = -1;
    n_byte normalise_features;
    simulated_isocial *meeter_social_graph;
    simulated_featureset *s1, * s2;

    /** Get the social graph for the being doing the meeting */
    meeter_social_graph = being_social( meeter_being );

    if ( meeter_social_graph == 0 )
    {
        return -1;
    }

    /** get the observed feature set for the met being */
    s2 = &meeter_social_graph[social_graph_index].classification;

    /** the upper range of social graph entries between
        SOCIAL_SIZE_BEINGS and SOCIAL_SIZE contains
        abstract beings or stereotypes */
    for ( i = SOCIAL_SIZE_BEINGS; i < SOCIAL_SIZE; i++ )
    {
        if ( !SOCIAL_GRAPH_ENTRY_EMPTY( meeter_social_graph, i ) )
        {
            /** get the feature set for the stereotype */
            s1 = &meeter_social_graph[i].classification;
            normalise_features = 0;
            diff = 0;
            hits = 0;
            /** for every feature within the stereotype */
            for ( j = 0; j < s1->feature_number; j++ )
            {
                /** does this feature exist for the met being? */
                index = simulated_featureset_feature_index( s2, s1->features[j].type );
                if ( index > -1 )
                {
                    hits++;
                    /** difference between the feature values */
                    dv = ( n_int )s1->features[j].value -
                         ( n_int )s2->features[index].value;
                    if ( dv < 0 )
                    {
                        dv = -dv;
                    }

                    /** update the total difference between the stereotype
                        and the met being */
                    diff += dv;

                    /** does the stereotype feature match the met being feature?
                        if so then increment the observation frequency */
                    if ( dv < featureset_match_threshold( s1->features[j].type ) )
                    {
                        /** increment the frequency of stereotype features */
                        s1->features[j].frequency++;
                        if ( s1->features[j].frequency > MAX_FEATURE_FREQUENCY )
                        {
                            normalise_features = 1;
                        }
                    }
                }
            }
            /** if all stereotype features were matched
                and the match was better than the best found */
            if ( hits == s1->feature_number )
            {
                if ( ( result == -1 ) || ( diff < min ) )
                {
                    min = diff;
                    result  = i;
                }
                /** increment the number of times when this
                    stereotype was fully matched */
                s1->observations++;
                if ( s1->observations > MAX_FEATURESET_OBSERVATIONS )
                {
                    social_normalise_stereotype_observations( meeter_being );
                }
            }

            /** normalise the stereotype feature frequencies if necessary */
            if ( normalise_features == 1 )
            {
                simulated_featureset_normalise_feature_frequencies( s1 );
            }
        }
    }
    return result;
}

/**
 * @brief When one being meets another remember the observable features
 * @param meeter_being the being foing the meeting
 * @param met_being the being which was met
 * @param social_graph_index index within the meeters social graph of the met being
 */
static void social_meet_update_features(
    simulated_being *meeter_being,
    simulated_being *met_being,
    n_int social_graph_index )
{
    simulated_isocial *meeter_social_graph;
#ifdef TERRITORY_ON
    n_int idx;
#endif

    /** Get the social graph for the being doing the meeting */
    meeter_social_graph = being_social( meeter_being );

    if ( meeter_social_graph == 0 )
    {
        return;
    }

    /** Note: perhaps not all features should be observed at once.
        This should maybe be under attentional control.
        Also observations should perhaps include learned biases
        from existing stereotypes */

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_PIGMENTATION,
                                 GENE_PIGMENTATION( being_genetics( met_being ) ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_HAIR,
                                 GENE_HAIR( being_genetics( met_being ) ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_HEIGHT,
                                 being_height( met_being ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_FAT,
                                 GET_BODY_FAT( met_being ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_EYE_SHAPE,
                                 GENE_EYE_SHAPE( being_genetics( met_being ) ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_EYE_COLOR,
                                 GENE_EYE_COLOR( being_genetics( met_being ) ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_EYE_SEPARATION,
                                 GENE_EYE_SEPARATION( being_genetics( met_being ) ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_NOSE_SHAPE,
                                 GENE_NOSE_SHAPE( being_genetics( met_being ) ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_EAR_SHAPE,
                                 GENE_EAR_SHAPE( being_genetics( met_being ) ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_EYEBROW_SHAPE,
                                 GENE_EYEBROW_SHAPE( being_genetics( met_being ) ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_MOUTH_SHAPE,
                                 GENE_MOUTH_SHAPE( being_genetics( met_being ) ) );

#ifdef TERRITORY_ON
    idx = APESPACE_TO_TERRITORY( being_location_y( meeter_being ) ) * TERRITORY_DIMENSION +
          APESPACE_TO_TERRITORY( being_location_x( meeter_being ) );

    simulated_featureset_update( &meeter_social_graph[social_graph_index].classification,
                                 FEATURESET_TERRITORY,
                                 meeter_being->events.territory[idx].name );
#endif
}

#endif

/**
 * @brief Returns a string for the name of the ape in the given social graph array index.
 * @param group Pointer to the simulated_group
 * @param local_being Pinter to the ape
 * @param social_graph_index Array index within the social graph
 * @param met BEING_MEETER=return name for the meeter, BEING_MET=return name for the met
 * @param name Returned ape name
 */
void social_graph_link_name(
    simulated_group *group,
    simulated_being *local_being,
    n_int social_graph_index,
    n_byte met,
    n_string name )
{
    simulated_isocial *local_social_graph;

    /** Get the social graph for the being */
    local_social_graph = being_social( local_being );

    if ( local_social_graph == 0 )
    {
        return;
    }

    switch ( local_social_graph[social_graph_index].entity_type )
    {
    case ENTITY_BEING:
    {
        being_name_byte2( local_social_graph[social_graph_index].first_name[met], local_social_graph[social_graph_index].family_name[met], name );
        break;
    }
    case ENTITY_BEING_GROUP:
        ( void )SHOW_ERROR( "Unimplemented being group entity type" );
        break;
    case ENTITY_OBJECT:
        ( void )SHOW_ERROR( "Unimplemented object entity type" );
        break;
    case ENTITY_TERRITORY:
        ( void )SHOW_ERROR( "Unimplemented territory entity type" );
        break;
    default:
        ( void )SHOW_ERROR( "Unimplemented entity type" );
        break;
    }
}

/**
 * @brief Align learned preferences with another ape, depending upon
 * whether it is part of the ingroup or outgroup.
 * @param group Pointer to the simulated_group
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @param social_graph_index Array index within the meeter social graph for the met ape
 */
static void social_group_align_preferences(
    simulated_group *group,
    simulated_being *meeter_being,
    simulated_being *met_being,
    n_int social_graph_index )
{
    n_int i, incr = -1;
    simulated_isocial *social_graph;

    /** don't align with yourself */
    if ( ( meeter_being == met_being ) || ( social_graph_index < 1 ) )
    {
        return;
    }

    /** get the social graph */
    social_graph = being_social( meeter_being );

    if ( social_graph == 0L )
    {
        return;
    }

    /** the entry in the social graph for the other being shouldn't be empty */
    if ( SOCIAL_GRAPH_ENTRY_EMPTY( social_graph, social_graph_index ) )
    {
        return;
    }

    /** if you are friendly then make your preferences more similar,
    otherwise make them more disimilar */
    if ( social_graph[social_graph_index].friend_foe >=
            ( n_byte )social_respect_mean( meeter_being ) )
    {
        incr = 1;
    }

    /** align preferences */
    for ( i = 0; i < PREFERENCES; i++ )
    {
        n_int resultant = meeter_being->changes.learned_preference[i];
        if ( resultant < met_being->changes.learned_preference[i] )
        {
            if ( ( incr > 0 ) || ( ( incr < 0 ) && ( resultant > 0 ) ) )
            {
                resultant += incr;
            }
        }
        else if ( resultant > met_being->changes.learned_preference[i] )
        {
            if ( ( incr > 0 ) || ( ( incr < 0 ) && ( meeter_being->changes.learned_preference[i] < 255 ) ) )
            {
                resultant -= incr;
            }
        }
        meeter_being->changes.learned_preference[i] = ( n_byte )resultant;
    }
}

/**
 * @brief What is the pigmentation attractiveness of met ape to the meeter being ?
 * @param being_meeter Pointer to the ape doing the meeting
 * @param being_met Pointer to the ape being met
 * @return Attractiveness value
 */
static n_int social_attraction_pigmentation(
    simulated_being *being_meeter,
    simulated_being *being_met )
{
    n_int ppref, pdiff;
    n_byte fem = ( FIND_SEX( GET_I( being_meeter ) ) == SEX_FEMALE );

    /** Either no preference for pigmentation, or only
        favour attractive mates */
    ppref = NATURE_NURTURE(
                GENE_PIGMENTATION_PREFERENCE( being_genetics( being_meeter ) ),
                being_meeter->changes.learned_preference[PREFERENCE_MATE_PIGMENTATION_MALE + fem] );

    pdiff = GENE_PIGMENTATION( being_genetics( being_met ) ) - ppref;

    if ( ( pdiff >= -2 ) && ( pdiff <= 2 ) )
    {
        pdiff = ABS( pdiff );
        return ( 3 - pdiff );
    }
    return 0;
}

/**
 * What is the hair attractiveness of the met ape to the meeter being ?
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @return Attractiveness value
 */
static n_int social_attraction_hair(
    simulated_being *meeter_being,
    simulated_being *met_being )
{
    n_int ppref, pdiff;
    n_byte fem = ( FIND_SEX( GET_I( meeter_being ) ) == SEX_FEMALE );

    /** either no preference for hair length, or only
       favour attractive mates */

    ppref = NATURE_NURTURE(
                GENE_HAIR_PREFERENCE( being_genetics( meeter_being ) ),
                meeter_being->changes.learned_preference[PREFERENCE_MATE_HAIR_MALE + fem] );
    pdiff = GENE_HAIR( being_genetics( met_being ) ) - ppref;

    if ( ( pdiff >= -2 ) && ( pdiff <= 2 ) )
    {
        pdiff = ABS( pdiff );
        return ( 3 - pdiff );
    }
    return 0;
}

/**
 * What is the height attractiveness of the met ape to the meeter being ?
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @return Attractiveness value
 */
static n_int social_attraction_height(
    simulated_being *meeter_being,
    simulated_being *met_being )
{
    n_int ppref;
    n_byte fem = ( FIND_SEX( GET_I( meeter_being ) ) == SEX_FEMALE );

    /** Either don't care about height or
       favour mates who are taller or shorter */

    ppref = NATURE_NURTURE(
                GENE_HEIGHT_PREFERENCE( being_genetics( meeter_being ) ),
                meeter_being->changes.learned_preference[PREFERENCE_MATE_HEIGHT_MALE + fem] );

    /** prefer taller or shorter,
    < 8  don't care about height
    12-15 prefer taller
    8-11 prefer shorter*/
    if ( ppref >= 8 )
    {
        if ( ( ppref >= 12 ) && ( being_height( met_being ) > being_height( meeter_being ) ) )
        {
            /** prefer taller */
            return 1;
        }
        else
        {
            if ( ( ppref < 12 ) && ( being_height( met_being ) < being_height( meeter_being ) ) )
            {
                /** prefer shorter */
                return 1;
            }
        }
    }
    return 0;
}

/**
 * @brief What is the frame attractiveness of the met ape to the meeter being ?
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @return Attractiveness value
 */
static n_int social_attraction_frame(
    simulated_being *meeter_being,
    simulated_being *met_being )
{
    n_int ppref;
    n_byte fem = ( FIND_SEX( GET_I( meeter_being ) ) == SEX_FEMALE );

    /** Either don't care about frame or
    favour mates who are fatter or thinner */

    ppref = NATURE_NURTURE(
                GENE_FRAME_PREFERENCE( being_genetics( meeter_being ) ),
                meeter_being->changes.learned_preference[PREFERENCE_MATE_FRAME_MALE + fem] );

    if ( ( ppref > 6 ) && ( ppref <= 11 ) && ( GET_BODY_FAT( met_being ) > GET_BODY_FAT( meeter_being ) ) )
    {
        /** prefer fatter */
        return 1;
    }
    else
    {
        if ( ( ppref > 11 ) && ( GET_BODY_FAT( met_being ) < GET_BODY_FAT( meeter_being ) ) )
        {
            /** prefer thinner */
            return 1;
        }
    }
    return 0;
}

/**
 * @brief What is the pheromone attractiveness of the met ape to the meeter being ?
 * Pheromone attraction is inversely proportional to genetic similarity.
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @return Attractiveness value
 */
static n_int social_attraction_pheromone(
    simulated_being *meeter_being,
    simulated_being *met_being )
{
    n_int ch, i, different = 0;
    n_genetics *meeter_genetics = being_genetics( meeter_being );
    n_genetics *met_genetics = being_genetics( met_being );

    for ( ch = 0; ch < CHROMOSOMES; ch++ )
    {
        for ( i = 0; i < 32; i++ )
        {
            if ( ( ( meeter_genetics[ch] >> i ) & 1 ) != ( ( met_genetics[ch] >> i ) & 1 ) )
            {
                different++;
            }
        }
    }
    if ( different < MINIMUM_GENETIC_VARIATION )
    {
        return 0 - GENE_INCEST_AVERSION( meeter_genetics );
    }
    else
    {
        return 1;
    }
}

/**
 * @brief If two beings have previously met return the social graph index
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @return Array index within the social graph of the meeter, -1 if not found
 */
n_int get_simulated_isocial(
    simulated_being *meeter_being,
    simulated_being *met_being )
{
    n_byte2 i;
    simulated_isocial *graph = being_social( meeter_being );

    if ( !graph )
    {
        return -1;
    }

    for ( i = 1; i < SOCIAL_SIZE_BEINGS; i++ )
    {
        if ( !SOCIAL_GRAPH_ENTRY_EMPTY( graph, i ) )
        {
            if ( graph[i].entity_type == ENTITY_BEING )
            {
                if ( being_name_comparison( met_being, graph[i].first_name[BEING_MET], graph[i].family_name[BEING_MET] ) )
                {
                    return i;
                }
            }
        }
    }
    return -1;
}

/**
 * @brief Returns the social graph index for the least familiar ape
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @return Array index for the least familiar ape within the social graph of the meeter, -1 if not met
 */
static n_int get_stranger_link(
    simulated_being *meeter_being,
    simulated_being *met_being )
{
    n_byte2 i = 1;
    n_int stranger_index = -1;
    n_byte2 stranger = 65535, familiarity = 0;
    n_int time_since_met;
    simulated_isocial *graph = being_social( meeter_being );
    if ( !graph )
    {
        return 0;
    }

    for ( i = 1; i < SOCIAL_SIZE_BEINGS; i++ )
    {
        if ( !SOCIAL_GRAPH_ENTRY_EMPTY( graph, i ) )
        {
            /** not a family relationship */
            if ( !IS_FAMILY_MEMBER( graph, i ) )
            {
                /** minimum familiarity */
                familiarity = graph[i].familiarity;
                if ( familiarity < stranger )
                {
                    /** Forget old stuff in order to avoid
                        too much inflexibility */
                    time_since_met = land_date() - graph[i].space_time.date;

                    if ( ( time_since_met >= SOCIAL_FORGET_DAYS ) ||
                            ( graph[i].space_time.date == 0 ) )
                    {
                        stranger = familiarity;
                        stranger_index = i;
                    }
                }
            }
        }
        else
        {
            /** If this entry is empty */
            stranger_index = i;
            break;
        }
    }
    return stranger_index;
}

/**
 * @brief When two beings meet this updates the social graph
 * @param meeter_being Pointer to the being doing the meeting
 * @param met_being Pointer to the being who was met
 * @param location_type type of meeting
 * @return Array index within the social graph of the meeter, -1 if not met
 */
static n_int social_meet(
    simulated_being *meeter_being,
    simulated_being *met_being,
    n_byte location_type )
{
    n_int friend_or_foe, index = -1, stereotype_index = -1;

    n_byte2 familiarity = 0;
    simulated_isocial *graph = being_social( meeter_being );
    n_byte2 met = 0;

    if ( !graph )
    {
        return -1;
    }

    /** transmit any pathogens between the meeting beings */
    immune_transmit( &meeter_being->immune_system, &met_being->immune_system, PATHOGEN_TRANSMISSION_AIR );

    /** get the social graph index which will be used to represent this relation */
    index = get_simulated_isocial( meeter_being, met_being );
    if ( index > 0 )
    {
        familiarity = graph[index].familiarity;
        met = 1;
    }
    else
    {
        /** get the index of an existing social graph entry
        which can be overwritten */
        index = get_stranger_link( meeter_being, met_being );
    }

    if ( ( met == 1 ) || ( ( met == 0 ) && ( index > 0 ) ) )
    {
#ifdef FEATURE_SET
        /** record the observable features of the being which was met */
        social_meet_update_features(
            meeter_being, met_being, index );

        /** get the social graph index of the corresponding stereotype */
        stereotype_index = social_get_stereotype(
                               meeter_being, index );
#endif
        /** set the focus of attention to this being */
        being_set_attention( meeter_being, ATTENTION_ACTOR, index );

        /** if we havn't met previously */
        if ( met == 0 )
        {
            if ( stereotype_index > -1 )
            {
                /** get the predisposition towards this stereotype */
                friend_or_foe =
                    graph[stereotype_index].friend_foe;
            }
            else
            {
                /** the prejudice function */
                friend_or_foe =
                    SOCIAL_RESPECT_NORMAL -
                    social_attraction_pheromone( meeter_being, met_being ) +
                    social_attraction_pigmentation( meeter_being, met_being ) +
                    social_attraction_height( meeter_being, met_being ) +
                    social_attraction_frame( meeter_being, met_being ) +
                    social_attraction_hair( meeter_being, met_being )
#ifdef EPISODIC_ON
                    + episodic_met_being_celebrity( meeter_being, met_being )
#endif
                    ;

                /** TODO create new stereotype based upon the met being features */

            }
            /** Met another being */
            graph[index].entity_type = ENTITY_BEING;

            /** who did the meeting */
            graph[index].first_name[BEING_MEETER] = being_gender_name( meeter_being );
            graph[index].family_name[BEING_MEETER] = being_family_name( meeter_being );
            /** who was met */
            graph[index].first_name[BEING_MET] = being_gender_name( met_being );
            graph[index].family_name[BEING_MET] = being_family_name( met_being );

            /** initially no attraction */
            graph[index].attraction = 0;

            /** limit fof within range */
            if ( friend_or_foe < 0 )
            {
                friend_or_foe = 0;
            }
            if ( friend_or_foe > 255 )
            {
                friend_or_foe = 255;
            }
            graph[index].friend_foe = ( n_byte )friend_or_foe;
#ifdef BRAINCODE_ON
            /** initialise the braincode associated with this individual */
            being_init_braincode( meeter_being, met_being, graph[index].friend_foe, BRAINCODE_EXTERNAL );
#endif
        }

        if ( location_type == LOCATION_KNOWN )
        {
            /** this being was seen somewhere in my vicinity */
            graph[index].space_time.location[0] = ( n_byte2 )being_location_x( meeter_being );
            graph[index].space_time.location[1] = ( n_byte2 )being_location_y( meeter_being );
        }
        else
        {
            /** location unknown */
            graph[index].space_time.location[0] = 0;
            graph[index].space_time.location[1] = 0;
        }

        /** record the state of the met beting */
        graph[index].belief = being_state( met_being );

        /** date of the meeting */
        graph[index].space_time.date = land_date();
        graph[index].space_time.time = land_time();

        /** getting more familiar */
        if ( familiarity < 65535 )
        {
            graph[index].familiarity = familiarity + 1;
        }

        /** friendliness can be increased simply through familiarity */
        if ( graph[index].friend_foe < 255 )
        {
            graph[index].friend_foe++;
        }
    }
    return index;
}

/**
 * @brief Returns the social graph index of the given relationship type.
 * This can be used for example to search for the father of an
 * ape within the social graph.
 * @param meeter_being Pointer to the ape
 * @param relationship The type of relationship to search for
 * @return Array index of the social graph for the given type of relationship, -1 if not found
 */
n_int social_get_relationship(
    simulated_being *meeter_being,
    n_byte relationship )
{
    n_int index;
    simulated_isocial *meeter_social_graph;

    /** get the social graph */
    meeter_social_graph = being_social( meeter_being );

    if ( meeter_social_graph == 0L )
    {
        return -1;
    }

    /** Search the social graph */
    for ( index = 1; index < SOCIAL_SIZE_BEINGS; index++ )
    {
        /** Is this the desired relationship type? */
        if ( meeter_social_graph[index].relationship == relationship )
        {
            return index;
        }
    }
    return -1;
}

/**
 * @brief Set the relationship type between two apes
 * @param meeter_being Pointer to the ape doing the meeting
 * @param relationship The type of relationship
 * @param met_being Pointer to the ape being met
 * @param group Pointer to the simulated_group
 * @return Array index of the meeter social graph, -1 if not met
 */
n_int social_set_relationship( simulated_group *group,
                               simulated_being *meeter_being,
                               n_byte relationship,
                               simulated_being *met_being )
{
    n_int index;
    simulated_isocial *meeter_social_graph;

    /** no relationship specified */
    if ( relationship == 0 )
    {
        return -1;
    }

    /** create the social graph entry if necessary and return its array index */
    index = social_meet( meeter_being, met_being, LOCATION_UNKNOWN );
    if ( index > -1 )
    {
        /** get the social graph */
        meeter_social_graph = being_social( meeter_being );

        if ( meeter_social_graph == 0L )
        {
            return -1;
        }

        /** set the relationship type */
        meeter_social_graph[index].relationship = relationship;
    }
    return index;
}

/**
 * @brief When two apes meet within a given maximum range
 * this updates the social graph of both.
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @param distance Distance between the apes
 * @param group Pointer to the simulated_group
 * @return Array index of the meeter social graph, -1 if not met
 */
n_int social_network( simulated_group *group,
                      simulated_being *meeter_being,
                      simulated_being *met_being,
                      n_uint distance )
{
    n_int being_index = -1;
    if ( distance < SOCIAL_RANGE )
    {
        being_index = social_meet( meeter_being, met_being, LOCATION_KNOWN );
    }
    return being_index;
}

static void social_parasite_cycle( simulated_being *meeter_being, simulated_being *met_being, n_int distance )
{
    /** acquire parasites from the environment with some low probability,
     and existing parasites multiply */

    n_int paraprob = being_random( meeter_being );
    if ( paraprob < ( PARASITE_ENVIRONMENT + ( PARASITE_BREED * being_parasites( meeter_being ) ) ) )
    {
        being_add_parasites( meeter_being );
    }

    /** parasites sap energy */
    being_energy_delta( meeter_being, 0 - ( PARASITE_ENERGY_COST * being_parasites( meeter_being ) ) );

    if ( distance < PARASITE_HOP_MAX_DISTANCE )
    {
        /** parasite transmission - e.g. flea hop */
        if ( being_parasites( met_being ) < being_parasites( meeter_being ) )
        {
            being_add_parasites( met_being );
            being_remove_parasites( meeter_being, 1 );
        }
    }

}

/**
 * @brief Grooming behavior
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @param distance Distance between the apes
 * @param awake Whether the met being is awake
 * @param familiarity Familiarity with the met ape
 * @param group Pointer to the simulated_group
 * @return 1 if grooming, 0 otherwise
 */
n_byte social_groom(
    simulated_group *group,
    simulated_being *meeter_being,
    simulated_being *met_being,
    n_uint distance,
    n_int awake,
    n_byte2 familiarity )
{
    n_int meeter_index, met_index;
    n_byte grooming = 0, groom_decisions, groomloc;
    n_int gpref;

    social_parasite_cycle( meeter_being, met_being, distance );

    /** social grooming removes parasites and alters
       social status relationships */
    if ( ( awake != FULLY_ASLEEP ) &&
            ( distance < GROOMING_MAX_SEPARATION ) &&
            ( being_speed( meeter_being ) < MAX_SPEED_WHILST_GROOMING ) )
    {
        n_int  groomprob = being_random( meeter_being ) & 16383;
        if ( familiarity > 16 )
        {
            familiarity = 16;
        }

        {
            /** is the groomee female? */
            n_byte fem = ( FIND_SEX( GET_I( met_being ) ) == SEX_FEMALE );

            /** grooming preference */
            gpref = NATURE_NURTURE(
                        GENE_GROOM( being_genetics( meeter_being ) ),
                        meeter_being->changes.learned_preference[PREFERENCE_GROOM_MALE + fem] );
        }
        /** individuals which are familiar tend to groom more often */
        if ( groomprob <
                GROOMING_PROB + ( gpref * ( 1 + familiarity )*GROOMING_PROB_HONOR * ( 1 + being_honor( met_being ) ) ) )
        {
            /** transmit pathogens via touch */
            immune_transmit( &meeter_being->immune_system, &met_being->immune_system, PATHOGEN_TRANSMISSION_TOUCH );
            immune_transmit( &met_being->immune_system, &meeter_being->immune_system, PATHOGEN_TRANSMISSION_TOUCH );

            /** pick a body location to groom */
            groomloc = being_attention( meeter_being, ATTENTION_BODY );
            groom_decisions = 0;
            while ( ( met_being->changes.inventory[groomloc] & INVENTORY_GROOMED ) && ( groom_decisions < 4 ) )
            {
                met_being->changes.inventory[groomloc] |= INVENTORY_GROOMED;
                groomloc = ( n_byte )( being_random( meeter_being ) % INVENTORY_SIZE );
                groom_decisions++;
            }
            /** groomed wounds disappear */
            if ( met_being->changes.inventory[groomloc] & INVENTORY_WOUND )
            {
                met_being->changes.inventory[groomloc] = INVENTORY_GROOMED;
            }
            /** grooming location becomes the new focus of attention */
            being_set_attention( meeter_being, ATTENTION_BODY, groomloc );

            episodic_interaction( meeter_being, met_being, EVENT_GROOM, AFFECT_GROOM, groomloc );
            episodic_interaction( met_being, meeter_being, EVENT_GROOMED, AFFECT_GROOM, groomloc );

            /** the two beings meet and become more friendly */
            meeter_index = social_meet( meeter_being, met_being, LOCATION_KNOWN );
            if ( meeter_index > -1 )
            {
                met_index = social_meet( met_being, meeter_being, LOCATION_KNOWN );
                if ( met_index > -1 )
                {
                    simulated_isocial *graph = being_social( meeter_being );
                    if ( !graph )
                    {
                        return 0;
                    }

                    if ( ( graph[meeter_index].friend_foe ) < 255 )
                    {
                        graph[meeter_index].friend_foe++;
                    }
                    if ( ( graph[met_index].friend_foe ) < 255 )
                    {
                        graph[met_index].friend_foe++;
                    }
                }
            }
            /** Alter social status relations.
            The groomer gains status, since they are providing a service */
            being_honor_inc_dec( meeter_being, met_being );

            /** Decrement parasites */

            being_remove_parasites( met_being, PARASITES_REMOVED );

            grooming = 1;
        }
    }

    return grooming;
}

/**
 * @brief Squabbling and fighting
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape being met
 * @param distance Distance between the apes
 * @param is_female Whether the met being is female
 * @param group Pointer to the simulated_group
 * @return The new being state: showforce/attack
 */
n_byte2 social_squabble(
    simulated_being *meeter_being,
    simulated_being *met_being,
    n_uint distance,
    n_int is_female,
    simulated_group *group )
{
    n_uint agro;
    n_byte2 ret_val = 0;
    simulated_being *victor, * vanquished;
    n_int victor_index, vanquished_index;
    n_byte2 punchloc;
    n_vect2 delta;

    /** distance between beings */
    being_delta( met_being, meeter_being, &delta );

    /** battle with rival families */
    if ( ( being_family_first_name( meeter_being ) != being_family_first_name( met_being ) ) &&
            ( being_family_second_name( meeter_being ) != being_family_second_name( met_being ) ) )
    {
        being_facing_towards( meeter_being, &delta );
        /** high ranking apes will more aggressively defend their honor */
        agro = GENE_AGGRESSION( being_genetics( meeter_being ) );
        /** females are less agressive (less testosterone) */
        if ( is_female )
        {
            agro >>= 3;
        }
        if ( being_random( meeter_being ) < ( agro * 4096 + agro * being_honor( meeter_being ) * 10 ) )
        {
            /** who is the strongest ? */
            victor = meeter_being;
            vanquished = met_being;

            if ( ( ( being_random( meeter_being ) & 7 )*being_energy( meeter_being ) ) <
                    ( ( being_random( meeter_being ) & 7 )*being_energy( met_being ) ) )
            {
                victor = met_being;
                vanquished = meeter_being;
            }

            vanquished_index = social_meet( victor, vanquished, LOCATION_KNOWN );
            if ( vanquished_index > -1 )
            {
                victor_index = social_meet( vanquished, victor, LOCATION_KNOWN );
                if ( victor_index > -1 )
                {
                    simulated_isocial *victor_social_graph = being_social( victor );
                    simulated_isocial *vanquished_social_graph = being_social( vanquished );

                    if ( ( !victor_social_graph ) || ( !vanquished_social_graph ) )
                    {
                        return 0;
                    }

                    /** victor disrespects the vanquished */
                    if ( victor_social_graph[vanquished_index].friend_foe > SQUABBLE_DISRESPECT )
                    {
                        victor_social_graph[vanquished_index].friend_foe -= SQUABBLE_DISRESPECT;
                    }
                    /** vanquished disrespects the victor */
                    if ( vanquished_social_graph[victor_index].friend_foe > SQUABBLE_DISRESPECT )
                    {
                        vanquished_social_graph[victor_index].friend_foe -= SQUABBLE_DISRESPECT;
                    }
                }
            }
            /** victor increases in honor */
            if ( being_honor( victor ) < 255 - SQUABBLE_HONOR_ADJUST )
            {
                being_honor_delta( victor, SQUABBLE_HONOR_ADJUST );
            }
            /** vanquished decreases in honor */
            if ( being_honor( vanquished ) > SQUABBLE_HONOR_ADJUST )
            {
                being_honor_delta( vanquished, 0 - SQUABBLE_HONOR_ADJUST );
            }

            punchloc = being_random( victor ) % INVENTORY_SIZE;
            if ( distance > SQUABBLE_SHOW_FORCE_DISTANCE )
            {
                /** show of force */
                vanquished->changes.inventory[punchloc] = 0;
                being_energy_delta( victor, 0 - SQUABBLE_ENERGY_SHOWFORCE );
                being_energy_delta( vanquished, 0 - SQUABBLE_ENERGY_SHOWFORCE );

                ret_val |= BEING_STATE_SHOWFORCE;
            }
            else
            {
                /** attack */
                vanquished->changes.inventory[punchloc] = INVENTORY_WOUND;
                being_energy_delta( victor, 0 - SQUABBLE_ENERGY_ATTACK );
                being_energy_delta( vanquished, 0 - SQUABBLE_ENERGY_ATTACK );
                being_honor_swap( victor, vanquished );
                ret_val |= BEING_STATE_ATTACK;
            }

            /** remember the fight */

            episodic_interaction( victor, vanquished, EVENT_HIT, AFFECT_SQUABBLE_VICTOR, punchloc );
            episodic_interaction( vanquished, victor, EVENT_HIT_BY, AFFECT_SQUABBLE_VANQUISHED, punchloc );

            /** vanquished turns away */
            if ( meeter_being == vanquished )
            {
                n_vect2 negative_delta, zero = {0};

                vect2_subtract( &negative_delta, &zero, &delta );

                being_facing_towards( vanquished, &negative_delta );
            }
            else
            {
                being_facing_towards( vanquished, &delta );
            }

            /** vanquished flees */
            being_set_speed( vanquished, SQUABBLE_FLEE_SPEED );
        }
        return ret_val;
    }
    return 0;
}

/**
 * @brief Returns the average friend or foe value
 * @param local_being Pointer to the ape
 * @return The average friend or foe value for all social graph entries
 */
n_uint social_respect_mean(
    simulated_being *local_being )
{
    n_uint simulated_isocials = 0, average = 0;
    simulated_isocial *local_social_graph;
    n_int i;

    local_social_graph = being_social( local_being );
    if ( !local_social_graph )
    {
        return 0;
    }

    /** note that this includes the self */
    for ( i = 0; i < SOCIAL_SIZE; i++ )
    {
        if ( !SOCIAL_GRAPH_ENTRY_EMPTY( local_social_graph, i ) )
        {
            simulated_isocials++;
            average += ( n_uint )( local_social_graph[i].friend_foe );
        }
    }
    if ( simulated_isocials > 0 )
    {
        return average / simulated_isocials;
    }
    return SOCIAL_RESPECT_NORMAL;
}

/**
 * @brief Update for a conception event. This stores the date,
 * details of the father and resets drives and goals.
 * @param female Pointer to the mother
 * @param male Pointer to the father
 * @param group Pointer to the simulated_group
 */
/*static*/ void social_conception(
    simulated_being *female,
    simulated_being *male,
    simulated_group *group )
{

    if ( ( male == 0L ) || ( female == 0L ) )
    {
        return;
    }

    body_genetics( group->beings, group->num, being_fetal_genetics( female ), being_genetics( female ), being_genetics( male ), female->delta.random_seed );

    /** store the date of conception */
    female->changes.date_of_conception = land_date();

    female->changes.father_name[0]   = male->constant.name[0];
    female->changes.father_name[1]   = male->constant.name[1];

    if ( male->constant.generation_min < female->constant.generation_min )
    {
        female->changes.child_generation_min = male->constant.generation_min;
    }
    else
    {
        female->changes.child_generation_min = female->constant.generation_min;
    }

    if ( male->constant.generation_max > female->constant.generation_max )
    {
        female->changes.child_generation_max = male->constant.generation_max;
    }
    else
    {
        female->changes.child_generation_max = female->constant.generation_max;
    }

    /** reset sex drive and goal */
    being_reset_drive( female, DRIVE_SEX );
    being_reset_drive( male, DRIVE_SEX );

    being_set_goal_none( female );
    being_set_goal_none( male );

    /** remember the event */
    episodic_interaction( female, male, EVENT_MATE,  ( GENE_MATE_BOND( being_genetics( female ) )*AFFECT_MATE ), 0 );
    episodic_interaction( male, female, EVENT_MATE,  ( GENE_MATE_BOND( being_genetics( male ) )*AFFECT_MATE ), 0 );
}

/**
 * @brief Mating behavior
 * @param meeter_being Pointer to the ape doing the meeting
 * @param met_being Pointer to the ape whi is being met
 * @param being_index Array index for the met individual within the social graph of the meeter
 * @param distance The Distance between the two apes
 * @param group Pointer to simulated_group
 * @return The being state: reproducing or not
 */
n_int social_mate(
    simulated_being *meeter_being,
    simulated_being *met_being,
    n_int being_index,
    n_uint distance,
    simulated_group *group )
{
    n_int loc_state = 0;
    n_int attraction = 0;
    n_int attract;
    /*    n_byte2 matingprob;*/
    simulated_isocial *meeter_social_graph = being_social( meeter_being );

    if ( !meeter_social_graph )
    {
        return -1;
    }

    /*if ((being_drive(meeter_being, DRIVE_SEX) > THRESHOLD_SEEK_MATE) &&
            (being_drive(met_being, DRIVE_SEX) > THRESHOLD_SEEK_MATE))*/
    {

        /** mating is probabilistic, with a bias towards
            higher status individuals */

        /*

        matingprob = being_random(meeter_being);
        if (matingprob <
                (32000 + (n_byte2)(met_being->honor)*
                 GENE_STATUS_PREFERENCE(being_genetics(meeter_being))*MATING_PROB)) */
        {


            /** attractiveness based upon various criteria */
            attraction = 1 +
                         social_attraction_pheromone( meeter_being, met_being ) +
                         social_attraction_pigmentation( meeter_being, met_being ) +
                         social_attraction_height( meeter_being, met_being ) +
                         social_attraction_frame( meeter_being, met_being ) +
                         social_attraction_hair( meeter_being, met_being )
#ifdef EPISODIC_ON
                         + episodic_met_being_celebrity( meeter_being, met_being )
#endif
                         ;

            /** some minimum level of attraction required for pair bonding */
            /*if (meeter_social_graph[being_index].attraction > PAIR_BOND_THRESHOLD)
            {
                attraction++;
                */
            if ( distance < MATING_RANGE )
            {
                /** transmit pathogens */
                immune_transmit( &meeter_being->immune_system, &met_being->immune_system, PATHOGEN_TRANSMISSION_SEX );
                immune_transmit( &met_being->immune_system, &meeter_being->immune_system, PATHOGEN_TRANSMISSION_SEX );
                /** check opposite sexes */
                if ( ( FIND_SEX( GET_I( meeter_being ) ) == SEX_FEMALE ) &&
                        ( FIND_SEX( GET_I( met_being ) ) != SEX_FEMALE ) )
                {
                    if ( being_pregnant( meeter_being ) == 0 )
                    {
                        social_conception( meeter_being, met_being, group );
                    }
                }
            }
            /*
            }
            else
            {
                attraction--;
            }*/
        }

        attract = meeter_social_graph[being_index].attraction;
        if ( attraction > 0 )
        {
            if ( attraction < PAIR_BOND_THRESHOLD * 4 )
            {
                if ( attract < 255 - attraction )
                {
                    attract += attraction;
                }
            }
        }
        else
        {
            if ( attract > -attraction )
            {
                attract += attraction;
            }
            else
            {
                attract = 0;
            }
        }
        meeter_social_graph[being_index].attraction = ( n_byte )attract; /**< '=' : conversion from 'n_int' to 'n_byte', possible loss of data */
    }
    return loc_state;
}

/**
 * @brief When two beings meet agree on the name for the current territory
 * @param meeter_being Pointer to the being doing the meeting
 * @param met_being Pointer to the being whi is being met
 * @param being_index Array index for the met individual within the social graph of the meeter
 * @param meeter_graph Pointer to the social graph of the meeter
 * @param respect_mean Average friend of foe value within the social graph
 */
static void social_chat_territory(
    simulated_being *meeter_being,
    simulated_being *met_being,
    n_int being_index,
    simulated_isocial *meeter_graph,
    n_uint respect_mean )
{
#ifdef TERRITORY_ON
    n_int idx = 0, idx2, i = 0, x, y;

    idx = APESPACE_TO_TERRITORY( being_location_y( meeter_being ) ) * TERRITORY_DIMENSION +
          APESPACE_TO_TERRITORY( being_location_x( meeter_being ) );
    if ( meeter_being->events.territory[idx].name == 0 )
    {
        i = 0;
        for ( y = -1; y <= 1; y++ )
        {
            for ( x = -1; x <= 1; x++ )
            {
                if ( !( ( x == 0 ) && ( y == 0 ) ) )
                {
                    idx2 = idx + ( y * TERRITORY_DIMENSION + x );
                    if ( idx2 < 0 )
                    {
                        idx2 += TERRITORY_AREA;
                    }
                    if ( idx2 >= TERRITORY_AREA )
                    {
                        idx2 -= TERRITORY_AREA;
                    }
                    i = meeter_being->events.territory[idx2].name;
                    if ( i > 0 )
                    {
                        y = 2;
                        break;
                    }
                }
            }
        }
        /** give the current place a name at random */
        if ( i == 0 )
        {
            i = 1 + ( n_byte )( being_random( meeter_being ) & 255 );
        }
        meeter_being->events.territory[idx].name = ( n_byte )i;
    }

    /** take advice from more honorable friends */
    if ( meeter_graph[being_index].friend_foe >= respect_mean )
    {
        if ( being_honor_compare( met_being, meeter_being ) == 1 )
        {
            if ( met_being->events.territory[idx].name > 0 )
            {
                meeter_being->events.territory[idx].name =
                    met_being->events.territory[idx].name;
            }
        }
        else
        {
            if ( ( being_honor_compare( met_being, meeter_being ) == -1 ) &&
                    ( meeter_being->events.territory[idx].name > 0 ) )
            {
                met_being->events.territory[idx].name =
                    meeter_being->events.territory[idx].name;
            }
        }
    }
#endif
}

/**
 * @brief Dialogue between beings
 * @param meeter_being Pointer to the being doing the meeting
 * @param met_being Pointer to the being which is being met
 * @param being_index Array index for the met individual within the social graph of the meeter
 * @param group Pointer to the simulated_group
 * @return A non-zero value if speaking
 */
n_int social_chat(
    simulated_being *meeter_being,
    simulated_being *met_being,
    n_int being_index,
    simulated_group *group )
{
    n_int idx, i = 0;
    n_byte relationship_index;
    n_byte2 name, family;
    n_int replace;
    n_int speaking = 0;
    simulated_isocial *meeter_graph = being_social( meeter_being );
    simulated_isocial *met_graph = being_social( met_being );
    n_uint respect_mean = social_respect_mean( meeter_being );


    if ( !meeter_graph )
    {
        return 0;
    }

    if ( !met_graph )
    {
        return 0;
    }

    /** agree upon terrirory */
    social_chat_territory( meeter_being, met_being, being_index, meeter_graph, respect_mean );

    /** do I respect their views ? */
    if ( ( meeter_graph[being_index].friend_foe ) >= respect_mean )
    {
        episodic_interaction( meeter_being, met_being, EVENT_CHAT, AFFECT_CHAT, 0 );
        /** pick one of the individuals from their graph */
        idx = -1;

        if ( being_check_goal( meeter_being, GOAL_MATE ) )
        {
            /** ask about an individual we're searching for */
            for ( i = 1; i < SOCIAL_SIZE_BEINGS; i++ )
            {
                if ( !SOCIAL_GRAPH_ENTRY_EMPTY( met_graph, i ) )
                {
                    if ( ( met_graph[i].first_name[BEING_MET] == meeter_being->delta.goal[1] ) &&
                            ( met_graph[i].family_name[BEING_MET] == meeter_being->delta.goal[2] ) )
                    {
                        idx = i;
                        break;
                    }
                }
            }
        }
        if ( idx == -1 )
        {
            /** what type of family relationship is currently being attended to */
            relationship_index = being_attention( meeter_being, ATTENTION_RELATIONSHIP );
            if ( relationship_index > 0 )
            {
                idx = social_get_relationship( meeter_being, relationship_index );
            }
            else
            {
                /** choose randomly */
                idx = 1 + ( being_random( meeter_being ) % ( SOCIAL_SIZE_BEINGS - 1 ) );
            }
        }

        if ( idx > -1 )
        {
            /** have I already met this individual? */
            name = met_graph[idx].first_name[BEING_MET];
            family = met_graph[idx].family_name[BEING_MET];
            if ( !( ( name == 0 ) && ( family == 0 ) ) )
            {
                for ( i = 1; i < SOCIAL_SIZE_BEINGS; i++ )
                {
                    if ( !SOCIAL_GRAPH_ENTRY_EMPTY( meeter_graph, i ) )
                    {
                        if ( ( meeter_graph[i].first_name[BEING_MET] == name ) &&
                                ( meeter_graph[i].family_name[BEING_MET] == family ) )
                        {
                            break;
                        }
                    }
                }

                if ( i < SOCIAL_SIZE_BEINGS )
                {
                    /** was already met */
                    if ( being_honor_compare( met_being, meeter_being ) == 1 )
                    {
                        meeter_graph[i].friend_foe++;
                    }
                    if ( being_honor_compare( met_being, meeter_being ) == -1 )
                    {
                        meeter_graph[i].friend_foe--;
                    }
                    if ( meeter_graph[i].familiarity < 65535 )
                    {
                        meeter_graph[i].familiarity++;
                    }

                    /** update this being's belief */
                    if ( spacetime_after( &met_graph[idx].space_time, &meeter_graph[i].space_time ) )
                    {
                        /** belief about location */
                        spacetime_copy( &meeter_graph[i].space_time, &met_graph[idx].space_time );

                        /** belief about state */
                        meeter_graph[i].belief = met_graph[idx].belief;
                    }
                    speaking |= BEING_STATE_SPEAKING;
                }
                else
                {
                    /** if we have never met then add to my graph as someone I've
                    "heard of". This is like a prior expectation or second
                    hand information.
                    The least familiar relationship is replaced */
                    replace = get_stranger_link( meeter_being, met_being );
                    if ( replace > -1 )
                    {
                        memory_copy( ( n_byte * )&met_graph[idx], ( n_byte * )&meeter_graph[replace], sizeof( simulated_isocial ) );
                        meeter_graph[replace].attraction = 0;
                        speaking |= BEING_STATE_SPEAKING;

                        /** if this is a family member of the previously unknown
                            being then make sure that the family member type is
                            set to OTHER - i.e. not my family someone else's */
                        if ( IS_FAMILY_MEMBER( met_graph, idx ) )
                        {
                            meeter_graph[replace].relationship =
                                meeter_graph[replace].relationship + ( OTHER_MOTHER - RELATIONSHIP_MOTHER );
                        }
#ifdef BRAINCODE_ON
                        /** initialise the braincode */
                        being_init_braincode( meeter_being, met_being, met_graph[idx].friend_foe, BRAINCODE_EXTERNAL );
#endif
                    }
                }
            }
        }
    }
    being_reset_drive( met_being, DRIVE_SOCIAL );
    being_reset_drive( meeter_being, DRIVE_SOCIAL );

#ifdef BRAINCODE_ON
    brain_dialogue(
        group, 1, meeter_being, met_being,
        being_braincode_external( meeter_being ),
        being_braincode_external( met_being ),
        being_index );

#endif
#ifdef EPISODIC_ON
    social_group_align_preferences(
        group, meeter_being, met_being, being_index );
#endif
    if ( speaking != 0 )
    {
        being_add_state( meeter_being, BEING_STATE_SPEAKING );
        being_add_state( met_being, BEING_STATE_SPEAKING );
    }
    return speaking;
}

/**
 * @brief Goal oriented behavior
 * @param local Pointer to the ape
 */
void social_goals( simulated_being *local )
{
    if ( being_check_goal( local, GOAL_LOCATION ) )
    {
        /** move towards a location */

        n_int delta_x = 0, delta_y = 0, distsqr;
        n_vect2 delta_vector, location_vector;

        if ( ( being_state( local ) & BEING_STATE_SWIMMING ) == 0 )
        {
            vect2_byte2( &delta_vector, ( n_byte2 * ) & ( local->delta.goal[1] ) );
            being_space( local, &location_vector );
            vect2_subtract( &delta_vector, &location_vector, &delta_vector );
            being_facing_towards( local, &delta_vector );
        }

        distsqr = delta_x * delta_x + delta_y * delta_y;
        if ( ( distsqr < GOAL_RADIUS ) || ( ( being_state( local ) & BEING_STATE_SWIMMING ) != 0 ) )
        {
            /** destination reached - goal cancelled */
            being_set_goal_none( local );
            /** clear any script override */
            local->braindata.script_overrides -= OVERRIDE_GOAL;
        }
    }
    being_goal_cycle( local );
}

void social_initial_loop( simulated_group *group, simulated_being *local_being, void *data )
{
    n_uint respect_mean = social_respect_mean( local_being );
    n_uint social_loop = 0;
    n_vect2 location, sum_delta = {0, 0};
    n_int   familiar_being_count = 0;
    vect2_byte2( &location, ( n_byte2 * ) & ( local_being->delta.social_coord_x ) );
    while ( social_loop < SOCIAL_SIZE_BEINGS )
    {
        simulated_isocial *specific_individual = &( being_social( local_being )[social_loop] );
        simulated_being   *specific_being;

        if ( !specific_individual )
        {
            return;
        }

        if ( !SOCIAL_GRAPH_ENTRY_EMPTY( being_social( local_being ), social_loop ) )
        {
            specific_being = being_find_name( group, specific_individual->first_name[BEING_MET], specific_individual->family_name[BEING_MET] );

            if ( specific_being != 0L )
            {
                n_vect2 weighted_delta;
                n_vect2 familiar_location;
                n_int    local_friend_or_foe = specific_individual->friend_foe;
                n_int    distance_squared;

                local_friend_or_foe -= respect_mean;

                familiar_being_count++;

                vect2_byte2( &familiar_location, ( n_byte2 * ) & ( specific_being->delta.social_coord_x ) );

                vect2_subtract( &weighted_delta, &familiar_location, &location );

                distance_squared = vect2_dot( &weighted_delta, &weighted_delta, 1, 512 );

                if ( distance_squared < 0 )
                {
                    distance_squared = 0;    /**< Bug fix for division by zero on the following line */
                }

                vect2_d( &sum_delta, &weighted_delta, local_friend_or_foe * 2048,
                         ( distance_squared + 1 ) );
            }
        }

        social_loop++;
    }

    if ( familiar_being_count != 0 )
    {
        vect2_d( &location, &sum_delta, 1, ( familiar_being_count * 20 ) );
    }
    vect2_back_byte2( &location, ( n_byte2 * ) & ( local_being->delta.social_coord_nx ) );
}

void social_secondary_loop_no_sim( simulated_being *local_being )
{
    local_being->delta.social_coord_x = local_being->delta.social_coord_nx;
    local_being->delta.social_coord_y = local_being->delta.social_coord_ny;
}


/* ./entity/speak.c */
/****************************************************************

 speak.c

 =============================================================



 ****************************************************************/



#define _CRT_SECURE_NO_WARNINGS

/** working on the real solution */

#include <stdio.h>
#include <stdlib.h>

#include "entity.h"
#include "entity_internal.h"

/** the sound lengths vary from:

 (8k)  0.185 sec to
 (16k) 0.371 sec to
 (32k) 0.743 sec

 these can contain sounds or pauses
 */

static n_audio  output[AUDIO_FFT_MAX_BUFFER];

static n_uint speak_length( n_byte character )
{
    switch ( character )
    {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
        return 1;
    case 'p':
    case 'b':
    case 'j':
    case 't':
        return 0;
    default:
        return 2;
    }
}

static n_uint speak_length_total( n_string paragraph )
{
    n_int  loop = 0;
    n_int character;
    n_int length = 0;
    do
    {
        character = paragraph[loop++];
        if ( character != '\n' && character != 0 )
        {
            length += 1 << speak_length( ( n_byte )character );
        }
    }
    while ( character != '\n' && character != 0 );
    return ( n_uint )length;
}

static const n_int set_frequencies[24] =
{
    175, 178, 180, 183,
    185, 188, 191, 193,
    196, 199, 202, 205,
    208, 211, 214, 217,
    220, 223, 227, 229,
    233, 237, 240, 244
};


static const n_int vowel_reorder[8] =
{
    4, 7, 0, 2, 1, 6, 3, 5
};

static const n_int consonant_reorder[16] =
{
    6, 13, 3, 7,   0, 14, 1, 12,
    9, 11, 2, 15,  4, 10, 5, 8
};

static const n_int low_freq[13] =
{
    60000, 45000, 30000, 55000,
    30000, 40000, 35000, 60000,
    40000, 20000, 65000, 40000,
    30000
};

static void speak_freq( n_int *high, n_int *low, n_byte value )
{
    const n_string character_building = "aeiovfstpbjm";
    n_int loop = 0;
    do
    {
        if ( value != character_building[loop] )
        {
            loop++;
        }
    }
    while ( ( loop < 12 ) && ( value != character_building[loop] ) );

    if ( loop < 12 )
    {
        low[1] = low_freq[loop  ];
        low[0] = 1;
        low[3] = low_freq[loop + 1];
        low[2] = 2;

        if ( loop < 4 ) /**< vowel */
        {
            high[0] = set_frequencies[vowel_reorder[loop]];
            high[1] = 600000;
            high[2] = set_frequencies[vowel_reorder[loop + 1]];
            high[3] = 300000;
            high[4] = set_frequencies[vowel_reorder[loop + 2] + 2];
            high[5] = 200000;
            high[6] = set_frequencies[vowel_reorder[loop + 4] + 3];
            high[7] =  50000;
        }
        else /**< consonant */
        {
            high[0] = set_frequencies[consonant_reorder[loop - 4]];
            high[1] = 600000;
            high[2] = set_frequencies[consonant_reorder[loop - 2] + 3];
            high[3] = 400000;
            high[4] = set_frequencies[consonant_reorder[loop + 1] + 8];
            high[5] = 100000;
            high[6] = set_frequencies[consonant_reorder[loop + 3] + 8];
            high[7] =  50000;
        }
    }
    else
    {
        low[0] = 0;
        low[1] = 0;
        low[2] = 0;
        low[3] = 0;
        high[0] = 0;
        high[1] = 0;
        high[2] = 0;
        high[3] = 0;
        high[4] = 0;
        high[5] = 0;
        high[6] = 0;
        high[7] = 0;
    }

}

void speak_out( n_string filename, n_string paragraph )
{
    FILE    *out_file = 0L;
    n_uint   total_length = AUDIO_FFT_MAX_BUFFER * speak_length_total( paragraph ) >> 2;
    n_int    loop         = 0;
    n_byte   found_character;

    if ( total_length < 1 )
    {
        ( void )SHOW_ERROR( "Speaking length is less than one" );
        return;
    }

    out_file = fopen( filename, "w" );

    if ( out_file == 0L )
    {
        ( void )SHOW_ERROR( "Failed create speak file!" );
        return;
    }

    audio_aiff_header( out_file, total_length );
    do
    {
        n_uint    power_sample = ( speak_length( found_character = ( n_byte )paragraph[loop++] ) + AUDIO_FFT_MAX_BITS - 2 );
        n_uint    length = 1 << power_sample;
        n_int     division = AUDIO_FFT_MAX_BUFFER / length;

        audio_clear_buffers( length );

        if ( found_character != '\n' && found_character != 0 )
        {
            if ( found_character != ' ' && found_character != '.' )
            {
                n_int local_high[8], local_low[4];

                speak_freq( local_high, local_low, found_character );

                audio_set_frequency( ( n_uint )( local_high[0] / division ), ( n_uint )( local_high[1] / division ) );
                audio_set_frequency( ( n_uint )( local_high[2] / division ), ( n_uint )( local_high[3] / division ) );
                audio_set_frequency( ( n_uint )( local_high[4] / division ), ( n_uint )( local_high[5] / division ) );
                audio_set_frequency( ( n_uint )( local_high[6] / division ), ( n_uint )( local_high[7] / division ) );

                audio_fft( 1, power_sample );

                audio_equal_output( output, length );

                audio_clear_buffers( length );

                audio_set_frequency( ( n_uint )( local_low[0] ), ( n_uint )( local_low[1] / division ) );
                audio_set_frequency( ( n_uint )( local_low[2] ), ( n_uint )( local_low[3] / division ) );

                audio_fft( 1, power_sample );

                audio_multiply_output( output, length );
            }
            else
            {
                audio_clear_output( output, length );
            }
            audio_aiff_body( out_file, output, length );
        }
    }
    while ( found_character != '\n' && found_character != 0 );

    if ( fclose( out_file ) != 0 )
    {
        ( void )SHOW_ERROR( "Failed to close speak file" );
    }
    return;
}



/* ./universe/command.c */
/****************************************************************

 command.c

 =============================================================



 ****************************************************************/

#define _CRT_SECURE_NO_WARNINGS

#define REMOVE_BOLDING_TEXT

#include "entity.h"

#include "universe_internal.h"

#include <stdio.h>

static n_int simulation_running = 1;
static n_int simulation_executing = 0;

const n_string RUN_STEP_CONST = "RSC";

/** The type of watch */
static n_int watch_type = WATCH_NONE;

/** keeps a running count of the total string length */
static n_int watch_string_length = 0;

/** enable or disable logging to file */
static n_int nolog = 0;

/** number of steps to periodically log simulation indicators */
static n_int indicator_index = 1;

/** How many steps at which to periodically save the simulation */
static n_uint save_interval_steps = 60;

static n_int          command_file_interaction = 0;
static n_string_block command_file_name;


static void command_offset( n_byte *start, n_byte *point, n_string text )
{
    printf( "%s %ld\n", text, ( n_int )( point - start ) );
}

#define FILE_CHECK(value) command_offset((n_byte*)&here, (n_byte*)value, #value)

static void command_audit( void )
{
    {
        simulated_being    here;

        FILE_CHECK( &here.delta.location[0] );
        FILE_CHECK( &here.delta.direction_facing );
        FILE_CHECK( &here.delta.velocity );
        FILE_CHECK( &here.delta.stored_energy );
        FILE_CHECK( &here.constant.date_of_birth );
        FILE_CHECK( &here.delta.random_seed[0] );
        FILE_CHECK( &here.delta.macro_state );
        FILE_CHECK( &here.braindata.brain_state[0] );
        FILE_CHECK( &here.delta.height );
        FILE_CHECK( &here.delta.mass );
        FILE_CHECK( &here.braindata.script_overrides );
        FILE_CHECK( &here.changes.shout[0] );
        FILE_CHECK( &here.delta.crowding );
        FILE_CHECK( &here.delta.posture );
        FILE_CHECK( &here.changes.inventory[0] );

        FILE_CHECK( &here.delta.parasites );
        FILE_CHECK( &here.delta.honor );

        FILE_CHECK( &here.changes.date_of_conception ); /* constant */
        FILE_CHECK( &here.braindata.attention[0] );
        FILE_CHECK( &here.constant.genetics[0] );         /* constant */
        FILE_CHECK( &here.changes.fetal_genetics[0] );         /* constant */
        FILE_CHECK( &here.changes.father_name[0] );                /* why is this needed? */
        FILE_CHECK( &here.delta.social_coord_x );
        FILE_CHECK( &here.delta.social_coord_y );
        FILE_CHECK( &here.delta.social_coord_nx ); /* why is this needed? */
        FILE_CHECK( &here.delta.social_coord_ny ); /* why is this needed? */
        FILE_CHECK( &here.changes.drives[0] );
        FILE_CHECK( &here.delta.goal[0] );
        FILE_CHECK( &here.changes.learned_preference[0] );
        FILE_CHECK( &here.constant.generation_min );
        FILE_CHECK( &here.constant.generation_max );
        FILE_CHECK( &here.changes.child_generation_min );
        FILE_CHECK( &here.changes.child_generation_max );
#ifdef TERRITORY_ON
        FILE_CHECK( &here.events.territory[0] );
#endif
#ifdef IMMUNE_ON
        FILE_CHECK( &here.immune_system );
#endif
#ifdef BRAINCODE_ON
        FILE_CHECK( &here.braindata.braincode_register[0] );
        FILE_CHECK( &here.braindata.brainprobe[0] );
#endif
#ifdef BRAIN_ON
        FILE_CHECK( &here.braindata.brain[0] );
#endif
        FILE_CHECK( &here.events.social[0] );
        FILE_CHECK( &here.events.episodic[0] );
    }
    {
        simulated_isocial here;

        FILE_CHECK( &here.space_time.location[0] );
        FILE_CHECK( &here.space_time.time );
        FILE_CHECK( &here.space_time.date );
        FILE_CHECK( &here.first_name[0] );
        FILE_CHECK( &here.family_name[0] );

        FILE_CHECK( &here.attraction );
        FILE_CHECK( &here.friend_foe );
        FILE_CHECK( &here.belief );
        FILE_CHECK( &here.familiarity );
        FILE_CHECK( &here.relationship );
        FILE_CHECK( &here.entity_type );

#ifdef FEATURE_SET
        FILE_CHECK( &here.classification );
#endif

#ifdef BRAINCODE_ON
        FILE_CHECK( &here.braincode[0] );
#endif

    }
    {
        simulated_iepisodic here;

        FILE_CHECK( &here.space_time.location[0] );
        FILE_CHECK( &here.space_time.time );
        FILE_CHECK( &here.space_time.date );
        FILE_CHECK( &here.first_name[0] );
        FILE_CHECK( &here.family_name[0] );
        FILE_CHECK( &here.event );
        FILE_CHECK( &here.food );
        FILE_CHECK( &here.affect );
        FILE_CHECK( &here.arg );
    }
}

n_int command_executing( void )
{
    return simulation_executing;
}

/**
 *
 * @param ptr pointer to simulated_group object
 * @param response command parameters
 * @param output_function the output function
 */
n_int command_being( void *ptr, n_string response, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;
    output_function( being_get_select_name( group ) );
    return 0;
}

static n_byte2 command_friends_first[SOCIAL_SIZE_BEINGS];
static n_byte2 command_friends_family[SOCIAL_SIZE_BEINGS];
static n_int   command_friends_count;

static n_byte2 command_enemies_first[SOCIAL_SIZE_BEINGS];
static n_byte2 command_enemies_family[SOCIAL_SIZE_BEINGS];
static n_int   command_enemies_count;

static n_byte2 command_attract_first[SOCIAL_SIZE_BEINGS];
static n_byte2 command_attract_family[SOCIAL_SIZE_BEINGS];
static n_int   command_attract_count;

n_int command_relationship_count( n_int friend_type )
{
    switch ( friend_type )
    {
    case 0:   /**< friends */
        return command_friends_count;
    case 1:   /**< enemies */
        return command_enemies_count;
    case 2:   /**< attraction */
        return command_attract_count;
    }
    return 0;
}

simulated_being *command_relationship_being( simulated_group *group, n_int friend_type, n_int location )
{
    n_byte2 first_name_look_up;
    n_byte2 family_name_look_up;
    n_uint loop = 0;
    switch ( friend_type )
    {
    case 0:   /**< friends */
        first_name_look_up = command_friends_first[location];
        family_name_look_up = command_friends_family[location];
        break;
    case 1:   /**< enemies */
        first_name_look_up = command_enemies_first[location];
        family_name_look_up = command_enemies_family[location];
        break;
    case 2:   /**< attraction */
        first_name_look_up = command_friends_first[location];
        family_name_look_up = command_friends_family[location];
        break;
    default:
        return 0L;
    }
    while ( loop < group->num )
    {
        simulated_being *local = &group->beings[loop];
        if ( ( being_gender_name( local ) == first_name_look_up ) && ( being_family_name( local ) == family_name_look_up ) )
        {
            return local;
        }
        loop++;
    }
    return 0L;
}

static void command_show_friends_being( void *ptr, simulated_being *local_being,
                                        n_int friend_type, n_string result, n_string four_characters )
{
    simulated_group *group = ( simulated_group * ) ptr;
    n_int i, found, attraction;
    simulated_isocial *local_social_graph;
    n_int first = 1;

    if ( local_being == 0 )
    {
        return;
    }

    /** Get the social graph for the being */
    local_social_graph = being_social( local_being );

    if ( local_social_graph == 0L )
    {
        return;
    }

    switch ( friend_type )
    {
    case 0:   /**< friends */
        command_friends_count = 0;
        break;
    case 1:   /**< enemies */
        command_enemies_count = 0;
        break;
    case 2:   /**< attraction */
        command_attract_count = 0;
        break;
    }
    /** For each entry in the social graph */
    for ( i = 1; i < SOCIAL_SIZE_BEINGS; i++ )
    {
        /** Skip empty entries */
        if ( SOCIAL_GRAPH_ENTRY_EMPTY( local_social_graph, i ) )
        {
            continue;
        }

        found = 0;
        attraction = 0;
        switch ( friend_type )
        {
        case 0:   /**< friends */
        {
            if ( local_social_graph[i].friend_foe >= social_respect_mean( local_being ) )
            {
                if ( local_social_graph[i].entity_type == ENTITY_BEING )
                {
                    if ( local_social_graph[i].attraction > 0 )
                    {
                        attraction = 1;

                    }
                    command_friends_first[command_friends_count] = local_social_graph[i].first_name[BEING_MET];
                    command_friends_family[command_friends_count] = local_social_graph[i].family_name[BEING_MET];
                    command_friends_count++;
                }
                found = 1;
            }
            break;
        }
        case 1:   /**< enemies */
        {
            if ( local_social_graph[i].friend_foe < social_respect_mean( local_being ) )
            {
                if ( local_social_graph[i].entity_type == ENTITY_BEING )
                {
                    if ( local_social_graph[i].attraction > 0 )
                    {
                        attraction = 1;
                    }
                    command_enemies_first[command_enemies_count] = local_social_graph[i].first_name[BEING_MET];
                    command_enemies_family[command_enemies_count] = local_social_graph[i].family_name[BEING_MET];
                    command_enemies_count++;
                }
                found = 1;
            }
            break;
        }
        case 2:   /**< attraction */
        {
            if ( local_social_graph[i].attraction > 0 )
            {
                if ( local_social_graph[i].entity_type == ENTITY_BEING )
                {
                    command_attract_first[command_attract_count] = local_social_graph[i].first_name[BEING_MET];
                    command_attract_family[command_attract_count] = local_social_graph[i].family_name[BEING_MET];
                    command_attract_count++;
                }
                found = 1;
            }
            break;
        }
        }

        if ( found == 1 )
        {
            n_int relationship_index;
            n_string_block relationship_str1;
            n_string_block relationship_str2;
            n_string_block met_being_name;
            n_string_block result_str;

            /** Print the name and familiarity */
            social_graph_link_name( group, local_being, i, BEING_MET, met_being_name );

            /** type of relationship */

            relationship_index = local_social_graph[i].relationship;

            if ( relationship_index > RELATIONSHIP_SELF )
            {
                being_relationship_description( relationship_index, relationship_str1 );

                if ( IS_FAMILY_MEMBER( local_social_graph, i ) )
                {
                    io_three_strings( relationship_str2, " (", relationship_str1, ")", 0 );
                }
                else
                {
                    n_string_block meeter_being_name;
                    n_string_block string_of_strings;
                    io_three_strings( meeter_being_name, " ", "", "", 0 );
                    social_graph_link_name( group, local_being, i, BEING_MEETER, meeter_being_name );
                    io_three_strings( string_of_strings, relationship_str1, " of *", meeter_being_name, 0 );
#ifdef REMOVE_BOLDING_TEXT
                    io_three_strings( relationship_str2, " ", string_of_strings, "*", 0 );
#else
                    io_three_strings( relationship_str2, " <", string_of_strings, "*>", 0 );
#endif
                }
            }
            else
            {
                io_three_strings( relationship_str2, " ", "", "", 0 );
            }

            if ( i != being_attention( local_being, ATTENTION_ACTOR ) )
            {
                /** Not the current focus of attention */

                if ( first )
                {
                    sprintf( result_str, "%s%05d  *%s*%s %ld\n", four_characters, ( int )local_social_graph[i].familiarity, met_being_name, relationship_str2, attraction );
                    first = 0;
                }
                else
                {
                    sprintf( result_str, "    %05d  *%s*%s %ld\n", ( int )local_social_graph[i].familiarity, met_being_name, relationship_str2, attraction );
                }
            }
            else
            {
                if ( first )
                {
                    /** The current focus of attention */
#ifdef REMOVE_BOLDING_TEXT
                    sprintf( result_str, "%s %05d *%s*%s %ld\n", four_characters, ( int )local_social_graph[i].familiarity, met_being_name, relationship_str2, attraction );
#else
                    sprintf( result_str, "%s %05d <*%s*>%s %ld\n", four_characters, ( int )local_social_graph[i].familiarity, met_being_name, relationship_str2, attraction );
#endif
                    first = 0;
                }
                else
                {
#ifdef REMOVE_BOLDING_TEXT
                    sprintf( result_str, "    %05d *%s*%s %ld\n", ( int )local_social_graph[i].familiarity, met_being_name, relationship_str2, attraction );
#else
                    sprintf( result_str, "    %05d <*%s*>%s %ld\n", ( int )local_social_graph[i].familiarity, met_being_name, relationship_str2, attraction );
#endif
                }
            }
            /** Write to the final result string */
            io_string_write( result, result_str, &watch_string_length );
        }
    }
}

/**
 * Show the friends of the given being
 * @param ptr pointer to simulated_group object
 * @param beingname name of the being
 * @param friend_type 0=friends, 1=enemies, 2=mates
 * @param result returned text
 */
static void command_show_friends( void *ptr, n_string beingname, n_int friend_type, n_string result )
{
    simulated_group *group = ( simulated_group * ) ptr;
    simulated_being *local_being;
    n_string local_being_name = io_string_copy( beingname );
    /** Get the being object from its name */
    local_being = being_from_name( group, local_being_name );
    memory_free( ( void ** )&local_being_name );

    if ( local_being == 0 )
    {
        return;
    }

    command_show_friends_being( ptr, local_being, friend_type, result, "        " );
}

/**
 * gets the number of mins/hours/days/months/years
 * @param str text to be processed
 * @param number the number of the time units
 * @param interval the time units
 * @return number of mins/hours/days/months/years
 */
n_int get_time_interval( n_string str, n_int *number, n_int *interval )
{
    n_int i, index = 0, ctr = 0, result = 0, divisor = 0;
    char c;
    n_string_block buf;
    n_int retval = -1;
    n_int length = io_length( str, 256 );

    for ( i = 0; i < length; i++ )
    {
        if ( str[i] != ' ' )
        {
            buf[ctr++] = str[i];
        }

        if ( ( str[i] == ' ' ) || ( i == ( length - 1 ) ) )
        {
            buf[ctr] = 0;

            switch ( index )
            {
            case 0:
            {
                io_number( ( n_string )buf, &result, &divisor );
                *number = result;
                retval = 0;
                break;
            }
            case 1:
            {
                if ( ctr == 1 )
                {
                    char lower_c;
                    lower_c = c = buf[0];
                    IO_LOWER_CHAR( lower_c );
                    if ( c == 'm' )
                    {
                        *interval = INTERVAL_MINS;
                    }
                    if ( lower_c == 'h' )
                    {
                        *interval = INTERVAL_HOURS;
                    }
                    if ( lower_c == 'd' )
                    {
                        *interval = INTERVAL_DAYS;
                    }
                    if ( c == 'M' )
                    {
                        *interval = INTERVAL_MONTHS;
                    }
                    if ( lower_c == 'y' )
                    {
                        *interval = INTERVAL_YEARS;
                    }
                }
                else
                {
                    IO_LOWER_CHAR( buf[0] );
                    if ( io_find( ( n_string )buf, 0, ctr, "min", 3 ) > -1 )
                    {
                        *interval = INTERVAL_MINS;
                    }
                    if ( ( io_find( ( n_string )buf, 0, ctr, "hour", 4 ) > -1 ) ||
                            ( io_find( ( n_string )buf, 0, ctr, "hr", 2 ) > -1 ) )
                    {
                        *interval = INTERVAL_HOURS;
                    }
                    if ( io_find( ( n_string )buf, 0, ctr, "day", 3 ) > -1 )
                    {
                        *interval = INTERVAL_DAYS;
                    }
                    if ( io_find( ( n_string )buf, 0, ctr, "mon", 3 ) > -1 )
                    {
                        *interval = INTERVAL_MONTHS;
                    }
                }

                break;
            }
            }

            index++;
            ctr = 0;
        }
    }
    return retval;
}

static void command_simulation_loop( simulated_group *group, simulated_being *local_being, void *data )
{
    n_int   *int_data = data;
    if ( FIND_SEX( GET_I( local_being ) ) == SEX_FEMALE )
    {
        int_data[0]++;
    }
    if ( ( land_date() - being_dob( local_being ) ) < AGE_OF_MATURITY )
    {
        int_data[1]++;
    }
}

/**
 * Show details of the overall simulation
 * @param ptr pointer to simulated_group object
 * @param response parameters of the command
 * @param output_function function to be used to display the result
 * @return 0
 */
n_int command_simulation( void *ptr, n_string response, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;
    simulated_timing *timing = sim_timing();
    n_string_block beingstr, time;
    n_int int_data[2];
    n_byte2 *local_land_genetics = land_genetics();
    n_string_block land_dimension, land_genetics0, land_genetics1, genetics, population;
    n_string_block adults, juveniles, tide_level;

    loop_no_thread( group, 0L, command_simulation_loop, int_data );

    io_number_to_string( land_dimension, ( n_uint )land_map_dimension() );
    io_number_to_string( land_genetics0, local_land_genetics[0] );
    io_number_to_string( land_genetics1, local_land_genetics[1] );
    io_number_to_string( population, group->num );

    io_number_to_string( adults, ( n_uint )( ( n_int )( group->num ) - int_data[1] ) );
    io_number_to_string( juveniles, ( n_uint )int_data[1] );

    io_number_to_string( tide_level, land_tide_level() );

    io_three_strings( beingstr, "Map dimension: ", land_dimension, "", 1 );

    io_three_strings( genetics, land_genetics0, " ", land_genetics1, 0 );

    io_three_strings( beingstr, beingstr, "Land seed: ", genetics, 1 );
    io_three_strings( beingstr, beingstr, "Population: ", population, 1 );
    io_three_strings( beingstr, beingstr, "Adults: ", adults, 0 );
    io_three_strings( beingstr, beingstr, "   Juveniles: ", juveniles, 1 );


    if ( group->num > 0 )
    {
        n_string_block males, females, males_percent, females_percent;
        io_number_to_string( males, ( group->num - int_data[0] ) );
        io_number_to_string( females, int_data[0] );

        io_number_to_string( males_percent, ( ( group->num - int_data[0] ) * 100 ) / group->num );
        io_number_to_string( females_percent, ( int_data[0] * 100 ) / group->num );

        io_three_strings( beingstr, beingstr, "Females: ", females, 0 );
        io_three_strings( beingstr, beingstr, " (", females_percent, 0 );
        io_three_strings( beingstr, beingstr, "%)   Males: ", males, 0 );
        io_three_strings( beingstr, beingstr, " (", males_percent, 0 );
        io_three_strings( beingstr, beingstr, "%)", "", 1 );
    }

    io_three_strings( beingstr, beingstr, "Tide level: ", tide_level, 1 );

    spacetime_to_string( time );

    if ( timing->delta_cycles )
    {
        n_string_block delta_cycles;

        io_number_to_string( delta_cycles, timing->delta_cycles );

        io_three_strings( beingstr, beingstr, "Brain Cycles Per Second: ", delta_cycles, 1 );
    }

    if ( simulation_executing )
    {
        io_three_strings( beingstr, beingstr, time, " Simulation running", 0 );
    }
    else
    {
        io_three_strings( beingstr, beingstr, time, " Simulation not running", 0 );
    }

    output_function( beingstr );

    return 0;
}

/**
 * Shows the names of all beings
 * @param ptr pointer to simulated_group
 * @param response parameters of the command
 * @param output_function function used to display the result
 * @return 0
 */
n_int command_list( void *ptr, n_string response, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;

    simulated_being *local_being;
    n_string_block line_text;
    n_int          location = 0;
    n_uint          loop = 0;

    if ( group->num == 0 )
    {
        output_function( "No apes present. Trying (re)running the Simulation" );
        return 0;
    }

    /** show names in index order */
    while ( loop < group->num )
    {
        n_string_block name;
        n_int          length;
        /** get the being */
        local_being = &group->beings[loop];

        /** get the name of the being */
        being_name_simple( local_being, name );

        io_string_write( line_text, name, &location );

        length = io_length( name, STRING_BLOCK_SIZE );

        while ( length < 24 )
        {
            io_string_write( line_text, " ", &location );
            length++;
        }

        if ( ( loop % 3 ) == 2 )
        {
            output_function( line_text );
            location = 0;
        }
        loop++;
    }

    if ( location != 0 )
    {
        output_function( line_text );
    }

    return 0;
}

void command_change_selected( simulated_group *group, n_byte forwards )
{
    simulated_being *local_select = group->select;
    simulated_being *first = group->beings;
    simulated_being *last = &( group->beings[group->num - 1] );
    if ( forwards )
    {
        if ( group->select != last )
        {
            local_select++;
        }
        else
        {
            local_select = first;
        }
    }
    else
    {
        if ( group->select != first )
        {
            local_select--;
        }
        else
        {
            local_select = last;
        }
    }
    sim_set_select( local_select );
}

static n_int command_check_ape_present( void *ptr, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;

    if ( group->select )
    {
        return 1;
    }
    if ( group->num )
    {
        output_function( "No apes selected." );
    }
    else
    {
        output_function( "No apes selected. Trying (re)running the Simulation" );
    }
    return 0;
}

n_int command_next( void *ptr, n_string response, n_console_output output_function )
{
    if ( command_check_ape_present( ptr, output_function ) )
    {
        command_change_selected( ( simulated_group * ) ptr, 1 );
    }
    return 0;
}

n_int command_previous( void *ptr, n_string response, n_console_output output_function )
{
    if ( command_check_ape_present( ptr, output_function ) )
    {
        command_change_selected( ( simulated_group * ) ptr, 0 );
    }
    return 0;
}

#ifdef BRAINCODE_ON
void command_populate_braincode( simulated_group *group, line_braincode function )
{
    if ( group->select )
    {
        simulated_being *local_being = group->select;
        n_byte       *internal_bc = being_braincode_internal( local_being );
        n_byte       *external_bc = being_braincode_external( local_being );
        n_int         loop = 0;

        n_string_block  initial_information;
        n_int           position = 0;

        io_string_write( initial_information, "EXT                                                         INT", &position );

        ( *function )( initial_information, -1 );

        while ( loop < 22 )
        {
            n_string_block command_information;

            n_string_block first_internal;
            n_string_block first_external;

            position = 0;

            brain_three_byte_command( ( n_string )first_internal, &internal_bc[loop * BRAINCODE_BYTES_PER_INSTRUCTION] );
            brain_three_byte_command( ( n_string )first_external, &external_bc[loop * BRAINCODE_BYTES_PER_INSTRUCTION] );

            if ( loop == 21 )
            {
                io_string_write( command_information, first_external, &position );
                io_string_write( command_information, "                   ", &position );
                io_string_write( command_information, first_internal, &position );
            }
            else
            {
                n_string_block second_internal;
                n_string_block second_external;

                brain_three_byte_command( ( n_string )second_internal, &internal_bc[( loop + 22 )*BRAINCODE_BYTES_PER_INSTRUCTION] );
                brain_three_byte_command( ( n_string )second_external, &external_bc[( loop + 22 )*BRAINCODE_BYTES_PER_INSTRUCTION] );

                io_string_write( command_information, first_external, &position );
                io_string_write( command_information, "  ", &position );
                io_string_write( command_information, second_external, &position );
                io_string_write( command_information, "   ", &position );
                io_string_write( command_information, first_internal, &position );
                io_string_write( command_information, "  ", &position );
                io_string_write( command_information, second_internal, &position );
            }
            ( *function )( command_information, loop );
            loop++;
        }
    }

}
#endif

/**
 * Show the appearance parameters for a being
 * @param ptr pointer to simulated_group object
 * @param beingname name of the being
 * @param local_being being to be shown
 * @param result resulting text containing appearance
 */
static void watch_appearance( void *ptr, n_string beingname, simulated_being *local_being, n_string result )
{
    n_string_block str;
    n_genetics *genetics = being_genetics( local_being );

    sprintf( str, "Height: %.3f m\n", ( int )GET_BEING_HEIGHT( local_being ) / 1000.0f );
    io_string_write( result, str, &watch_string_length );

    sprintf( str, "Mass: %.2f Kg\n", ( float )GET_M( local_being ) / 100.0f );
    io_string_write( result, str, &watch_string_length );

    sprintf( str, "Body fat: %.2f Kg\n", ( float )GET_BODY_FAT( local_being ) / 100.0f );
    io_string_write( result, str, &watch_string_length );

    sprintf( str, "Hair length: %.1f mm\n", ( float )( GENE_HAIR( genetics ) * 100.0f / 160.0f ) );
    io_string_write( result, str, &watch_string_length );

    sprintf( str, "Pigmentation: %02d\n", ( int )( GENE_PIGMENTATION( genetics ) ) );
    io_string_write( result, str, &watch_string_length );

    sprintf( str, "Body frame: %02d\n", ( int )( GENE_FRAME( genetics ) ) );
    io_string_write( result, str, &watch_string_length );

    sprintf( str, "Eye separation: %.1f mm\n",
             80.0f + ( ( float )( GENE_EYE_SEPARATION( genetics ) ) ) );
    io_string_write( result, str, &watch_string_length );

    sprintf( str, "Eye color: %02d       Eye shape: %02d\n",
             ( int )( GENE_EYE_COLOR( genetics ) ),
             ( int )( GENE_EYE_SHAPE( genetics ) ) );
    io_string_write( result, str, &watch_string_length );

    sprintf( str, "Nose shape: %02d      Ear shape: %02d\n",
             ( int )( GENE_NOSE_SHAPE( genetics ) ),
             ( int )( GENE_EAR_SHAPE( genetics ) ) );
    io_string_write( result, str, &watch_string_length );

    sprintf( str, "Eyebrow shape: %02d   Mouth shape: %02d\n",
             ( int )( GENE_EYEBROW_SHAPE( genetics ) ),
             ( int )( GENE_MOUTH_SHAPE( genetics ) ) );
    io_string_write( result, str, &watch_string_length );
}


#ifdef BRAINCODE_ON

static n_string static_result;

static void watch_line_braincode( n_string string, n_int line )
{
    io_string_write( static_result, string, &watch_string_length );
    io_string_write( static_result, "\n", &watch_string_length );
}

#endif

/**
 * Shows braincode for the given being
 * @param ptr pointer to simulated_group object
 * @param beingname Name of the being
 * @param local_being being to be viewed
 * @param result returned text
 */
static void watch_braincode( void *ptr, n_string beingname, simulated_being *local_being, n_string result )
{
#ifdef BRAINCODE_ON
    n_int i;
    io_string_write( result, "\nRegisters:\n", &watch_string_length );
    for ( i = 0; i < BRAINCODE_PSPACE_REGISTERS; i++ )
    {
        result[watch_string_length++] = ( n_char )( 65 + ( local_being->braindata.braincode_register[i] % 60 ) );
    }
    result[watch_string_length++] = '\n';
    result[watch_string_length++] = '\n';

    static_result = result;

    command_populate_braincode( ptr, watch_line_braincode );

    static_result = 0L;
    result[watch_string_length++] = '\n';
#endif
}

static void watch_speech( void *ptr, n_string beingname, simulated_being *local, n_string result )
{
#ifdef BRAINCODE_ON
    n_int loop;
    n_byte *external_bc = being_braincode_external( local );
    for ( loop = 0; loop < BRAINCODE_SIZE / BRAINCODE_BYTES_PER_INSTRUCTION; loop++ )
    {
        n_string_block sentence;

        brain_sentence( ( n_string )sentence, &external_bc[loop * 3] );

        io_string_write( result, sentence, &watch_string_length );
        if ( ( loop & 3 ) == 3 )
        {
            result[watch_string_length++] = '.';
        }
        if ( loop < BRAINCODE_SIZE / BRAINCODE_BYTES_PER_INSTRUCTION - 1 )
        {
            result[watch_string_length++] = ' ';
        }
    }
    result[watch_string_length++] = '.';
    result[watch_string_length++] = '\n';
#endif
}



/**
 * Shows the social graph for the given being
 * @param ptr pointer to simulated_group object
 * @param beingname Name of the being
 * @param local_being being to be viewed
 * @param result returned text
 */
static void watch_social_graph( void *ptr, n_string beingname, simulated_being *local_being, n_string result )
{
    io_string_write( result, "\nFriends:\n", &watch_string_length );
    command_show_friends( ptr, beingname, 0, result );
    io_string_write( result, "\nEnemies:\n", &watch_string_length );
    command_show_friends( ptr, beingname, 1, result );
}

static void watch_pathogen_graph( void *ptr, n_string beingname, simulated_being *local_being, n_string result )
{
#ifdef IMMUNE_ON
    n_uint j;
    n_uint antibodies[256] = {0};
    n_uint antigens[256] = {0};

    simulated_immune_system *immune = &( local_being->immune_system );
    for ( j = 0; j < IMMUNE_POPULATION; j++ )
    {
        antibodies[immune->shape_antibody[j]]++;
    }
    for ( j = 0; j < IMMUNE_ANTIGENS; j++ )
    {
        antigens[immune->shape_antigen[j]]++;
    }

    for ( j = 0; j < 256; j++ )
    {
        if ( antibodies[j] != 0 )
        {
            n_string_block result_str;
            sprintf( result_str, "AB( %ld ) = %ld\n", j,  antibodies[j] );
            io_string_write( result, result_str, &watch_string_length );
        }
        if ( antigens[j] != 0 )
        {
            n_string_block result_str;
            sprintf( result_str, "AG( %ld ) = %ld\n", j,  antigens[j] );
            io_string_write( result, result_str, &watch_string_length );
        }
    }
#endif
}

/**
 * Shows the episodic memory for the given being
 * @param ptr pointer to simulated_group object
 * @param beingname Name of the being
 * @param local_being being to be viewed
 * @param result returned text
 */
static void watch_episodic( void *ptr, n_string beingname, simulated_being *local_being, n_string result )
{
    n_uint i;
    for ( i = 0; i < EPISODIC_SIZE; i++ )
    {
        n_string_block str = {0};
        n_string_block description = {0};
        n_int          position = 0;
        ( void )episode_description( local_being, i, str );
        if ( io_length( str, STRING_BLOCK_SIZE ) > 0 )
        {
#ifdef REMOVE_BOLDING_TEXT
            io_string_write( description, "  ", &position );
            io_string_write( description, str, &position );
            io_string_write( description, "\n", &position );
#else
            if ( being_attention( local_being, ATTENTION_EPISODE ) != i )
            {
                io_string_write( description, "  ", &position );
                io_string_write( description, str, &position );
                io_string_write( description, "\n", &position );
            }
            else
            {
                io_string_write( description, " <", &position );
                io_string_write( description, str, &position );
                io_string_write( description, ">\n", &position );
            }
#endif
            io_string_write( result, description, &watch_string_length );
        }
    }
}

/**
 * Shows the genome for the given being
 * @param ptr pointer to simulated_group object
 * @param beingname Name of the being
 * @param local_being being to be viewed
 * @param result returned text
 */
static void watch_genome( void *ptr, n_string beingname, simulated_being *local_being, n_string result )
{
    n_int i, j;
    n_byte genome[CHROMOSOMES * 8 + 1];

    for ( i = 0; i < 2; i++ )
    {
        body_genome( ( n_byte )i, being_genetics( local_being ), genome );
        for ( j = 0; j < CHROMOSOMES * 8; j++ )
        {
            if ( ( j > 0 ) && ( j % 8 == 0 ) )
            {
                io_string_write( result, "\t", &watch_string_length );
            }
            result[watch_string_length++] = genome[j];
        }
        io_string_write( ( n_string )result, "\n", &watch_string_length );
    }
}

/**
 * Shows brainprobes for the given being
 * @param ptr pointer to simulated_group object
 * @param beingname Name of the being
 * @param local_being being to be viewed
 * @param result returned text
 */
static void watch_brainprobes( void *ptr, n_string beingname, simulated_being *local_being, n_string result )
{
#ifdef BRAINCODE_ON
    n_int i;
    n_string_block str2;
    n_string_block type_str;
    io_string_write( result, "\n  Type    Posn  Freq Offset Addr State\n  ", &watch_string_length );
    for ( i = 0; i < 36; i++ )
    {
        io_string_write( result, "-", &watch_string_length );
    }
    io_string_write( result, "\n", &watch_string_length );

    io_three_strings( type_str, "Input ", "", "", 0 );
    for ( i = 0; i < BRAINCODE_PROBES; i++ )
    {
        if ( local_being->braindata.brainprobe[i].type == INPUT_SENSOR )
        {
            sprintf( ( n_string )str2, "  %s  %03d   %02d   %03d    %03d  %d\n",
                     type_str,
                     local_being->braindata.brainprobe[i].position,
                     local_being->braindata.brainprobe[i].frequency,
                     local_being->braindata.brainprobe[i].offset,
                     local_being->braindata.brainprobe[i].address,
                     local_being->braindata.brainprobe[i].state );
            io_string_write( result, ( n_string )str2, &watch_string_length );
        }
    }

    io_three_strings( type_str, "Output ", "", "", 0 );

    for ( i = 0; i < BRAINCODE_PROBES; i++ )
    {
        if ( local_being->braindata.brainprobe[i].type == OUTPUT_ACTUATOR )
        {
            sprintf( ( n_string )str2, "  %s  %03d   %02d   %03d    %03d  %d\n",
                     type_str,
                     local_being->braindata.brainprobe[i].position,
                     local_being->braindata.brainprobe[i].frequency,
                     local_being->braindata.brainprobe[i].offset,
                     local_being->braindata.brainprobe[i].address,
                     local_being->braindata.brainprobe[i].state );
            io_string_write( result, ( n_string )str2, &watch_string_length );
        }
    }
#endif
}

static n_string watch_resolve_drives( n_byte *drives )
{
    n_byte max_value = 0;
    n_int loop = 0;
    n_int dominant = -1;
    while ( loop < DRIVES )
    {
        if ( drives[loop] > max_value )
        {
            max_value = drives[loop];
            dominant = loop;
        }
        loop++;
    }
    loop = 0;
    while ( loop < DRIVES )
    {
        if ( ( drives[loop] > ( max_value / 2 ) ) && ( loop != dominant ) )
        {
            return "Mixed drives";
        }
        loop++;
    }
    if ( dominant == DRIVE_SEX )
    {

        return "Find mate";
    }
    if ( dominant == DRIVE_HUNGER )
    {

        return "Find food";
    }
    if ( dominant == DRIVE_SOCIAL )
    {
        return "Find friends";
    }
    if ( dominant == DRIVE_FATIGUE )
    {

        return "Find rest";
    }
    return "No Drive";
}

static n_string sixteen_wind[16] =
{
    "E  ",
    "ESE",
    "SE ",
    "SSE",

    "S  ",
    "SSW",
    "SW ",
    "WSW",

    "W  ",
    "WNW",
    "NW ",
    "NNW",

    "N  ",
    "NNE",
    "NE ",
    "ENE",
};

static n_string watch_sixteenth_wind( n_byte facing )
{
    n_int   round_facing = facing + 7;
    return sixteen_wind[( round_facing >> 4 ) & 15];
}
/**
 * Shows the main parameters for the given being
 * @param ptr pointer to simulated_group object
 * @param beingname Name of the being
 * @param local_being being to be viewed
 * @param result returned text
 */
static void watch_stats( void *ptr, n_string beingname, simulated_being *local_being, n_string result )
{
    n_string_block     str;
    n_string_block     relationship_str;
    n_string_block     status;

    if ( local_being == 0L )
    {
        ( void )SHOW_ERROR( "No being for stats" );
        return;
    }

    being_state_description( being_state( local_being ), status );
    being_relationship_description( being_attention( local_being, ATTENTION_RELATIONSHIP ), relationship_str );

    sprintf( str, "%s (%ld %ld) %s\n%s: %s\nGen %lu:%lu  %s  ERG:%ld SPD:%ld\nHonor:%d  HEI:%ld  Days Old:%ld\n",
             beingname,
             being_location_x( local_being ) / 16, being_location_y( local_being ) / 16,
             watch_sixteenth_wind( being_facing( local_being ) ),
             watch_resolve_drives( being_drives( local_being ) ),
             status,
             ( n_uint )local_being->constant.generation_min,
             ( n_uint )local_being->constant.generation_max,
             ( ( FIND_SEX( GET_I( local_being ) ) == SEX_FEMALE ) ? "Female" : "Male  " ),
             being_energy( local_being ),
             being_ten_minute_distance( local_being ),

             being_honor( local_being ),
             GET_BEING_HEIGHT( local_being ),
             land_date() - being_dob( local_being )
           );

    io_string_write( result, str, &watch_string_length );

    if ( being_pregnant( local_being ) )
    {
        sprintf( str, "Days Preg: %ld\n", land_date() - being_pregnant( local_being ) );
        io_string_write( result, str, &watch_string_length );
    }
    sprintf( str, "Aware Body: %s Link: %s\n", being_body_inventory_description( being_attention( local_being, ATTENTION_BODY ) ),
             relationship_str );

    io_string_write( result, str, &watch_string_length );

    io_string_write( result, "Friend\n", &watch_string_length );
    command_show_friends_being( ptr, local_being, 0, result, "    " );
    io_string_write( result, "Enemy\n", &watch_string_length );
    command_show_friends_being( ptr, local_being, 1, result, "    " );
    io_string_write( result, "\n", &watch_string_length );
    watch_episodic( ptr, beingname, local_being, result );
}


void watch_control( void *ptr, n_string beingname, simulated_being *local_being, n_string result )
{
    watch_string_length = 0;
    watch_stats( ptr, beingname, local_being, result );
}

/**
 * This should duplicate all console for watch functions
 * @param ptr pointer to simulated_group object
 * @param response command parameters
 * @param output_function function used to show the output
 * @param title title
 * @param watch_function watch function
 * @return 0
 */
static n_int command_duplicate( void *ptr, n_string response, n_console_output output_function, n_string title, console_generic watch_function )
{
    simulated_group *group = ( simulated_group * ) ptr;

    simulated_being *local_being = 0L;
    n_string_block beingstr;

    watch_string_length = 0;

    if ( ( response == 0 ) && ( group->select ) )
    {
        response = being_get_select_name( group );
        if ( title != 0L )
        {
            io_string_write( ( n_string )beingstr, "\n", &watch_string_length );
            io_string_write( ( n_string )beingstr, title, &watch_string_length );
            io_string_write( ( n_string )beingstr, " for ", &watch_string_length );
            io_string_write( ( n_string )beingstr, response, &watch_string_length );
            io_string_write( ( n_string )beingstr, "\n", &watch_string_length );
        }
    }

    if ( response != 0L )
    {
        local_being = being_from_name( group, response );
        if ( local_being == 0L )
        {
            ( void )SHOW_ERROR( "Being not found" );
            return 0;
        }
        being_set_select_name( group, response );

        watch_function( ptr, being_get_select_name( group ), local_being, ( n_string )beingstr );
        beingstr[watch_string_length] = 0;
        output_function( beingstr );
        return 0;
    }

    ( void )SHOW_ERROR( "No being was specified" );
    return 0;
}

/**
 *
 * @param ptr pointer to simulated_group object
 * @param response response string
 * @param output_function output function
 * @return 0
 */
n_int command_genome( void *ptr, n_string response, n_console_output output_function )
{
    return command_duplicate( ptr, response, output_function, "Genome", watch_genome );
}

/**
 *
 * @param ptr pointer to simulated_group object
 * @param response response string
 * @param output_function output function
 * @return 0
 */
n_int command_stats( void *ptr, n_string response, n_console_output output_function )
{
    return command_duplicate( ptr, response, output_function, 0L, watch_stats );
}

/**
 *
 * @param ptr pointer to simulated_group object
 * @param response response string
 * @param output_function output function
 * @return 0
 */
n_int command_probes( void *ptr, n_string response, n_console_output output_function )
{
    return command_duplicate( ptr, response, output_function, "Brain probes", watch_brainprobes );
}

/**
 * Show the episodic memory
 * @param ptr pointer to simulated_group object
 * @param response response string
 * @param output_function output function
 * @return 0
 */
n_int command_episodic( void *ptr, n_string response, n_console_output output_function )
{
    return command_duplicate( ptr, response, output_function, "Episodic memory", watch_episodic );
}


n_int command_pathogen_graph( void *ptr, n_string response, n_console_output output_function )
{
    return command_duplicate( ptr, response, output_function, "Pathogen graph", watch_pathogen_graph );
}

/**
 * Show the social graph
 * @param ptr pointer to simulated_group object
 * @param response response string
 * @param output_function output function
 * @return 0
 */
n_int command_social_graph( void *ptr, n_string response, n_console_output output_function )
{
    return command_duplicate( ptr, response, output_function, "Social graph", watch_social_graph );
}

/**
 * Show the braincode
 * @param ptr pointer to simulated_group object
 * @param response response string
 * @param output_function output function
 * @return 0
 */
n_int command_braincode( void *ptr, n_string response, n_console_output output_function )
{
    return command_duplicate( ptr, response, output_function, "Braincode", watch_braincode );
}

n_int command_speech( void *ptr, n_string response, n_console_output output_function )
{
    return command_duplicate( ptr, response, output_function, "Speech", watch_speech );
}


/**
 * Show appearance values
 * @param ptr pointer to simulated_group object
 * @param response response string
 * @param output_function output function
 * @return 0
 */
n_int command_appearance( void *ptr, n_string response, n_console_output output_function )
{
    return command_duplicate( ptr, response, output_function, "Appearance", watch_appearance );
}

static void histogram_being_state_loop( simulated_group *group, simulated_being *local_being, void *data )
{
    n_uint *histogram = data;
    n_uint n = 2;
    if ( being_state( local_being ) == BEING_STATE_ASLEEP )
    {
        histogram[0]++;
    }
    else
    {
        while ( n < BEING_STATES )
        {
            if ( being_state( local_being ) & ( 1 << ( n - 1 ) ) )
            {
                histogram[n]++;
            }
            n++;
        }
    }
}

/**
 * Update a histogram of being states
 * @param group pointer to simulated_group object
 * @param histogram histogram array to be updated
 * @param normalize whether to normalize the histogram
 */
static void histogram_being_state( simulated_group *group, n_uint *histogram, n_byte normalize )
{
    n_uint i;

    for ( i = 0; i < BEING_STATES; i++ )
    {
        histogram[i] = 0;
    }

    loop_no_thread( group, 0L, histogram_being_state_loop, histogram );

    if ( normalize )
    {
        n_uint tot = 0;
        for ( i = 0; i < BEING_STATES; i++ )
        {
            tot += histogram[i];
        }
        if ( tot > 0 )
        {
            for ( i = 0; i < BEING_STATES; i++ )
            {
                histogram[i] = histogram[i] * 1000 / tot;
            }
        }
    }
}

/**
 * Watch a particular being
 * @param ptr pointer to simulated_group object
 * @param output_function output function to be used
 */
static void watch_being( void *ptr, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;
    simulated_being *local_being;
    n_string_block beingstr;
    n_uint i;
    n_int  j;
    n_byte2 state;


    if ( being_remove_internal() )
    {
        do {}
        while ( being_remove_internal() );
    }

    being_remove_external_set( 1 );

    if ( watch_type == WATCH_STATES )
    {
        n_uint histogram[16];
        n_string_block str;

        watch_string_length = 0;

        spacetime_to_string( str );
        io_string_write( beingstr, str, &watch_string_length );
        histogram_being_state( group, ( n_uint * )histogram, 1 );
        for ( i = 0; i < BEING_STATES; i++ )
        {
            if ( i == 1 )
            {
                continue;    /**< skip the awake state */
            }

            if ( i == 0 )
            {
                state = 0;
            }
            else
            {
                state = ( n_byte2 )( 1 << ( i - 1 ) );
            }

            being_state_description( state, ( n_string )str );
            io_string_write( beingstr, ( n_string )str, &watch_string_length );
            io_string_write( beingstr, ":", &watch_string_length );
            for ( j = 0; j < 12 - io_length( ( n_string )str, STRING_BLOCK_SIZE ); j++ )
            {
                io_string_write( beingstr, " ", &watch_string_length );
            }

            if ( histogram[i] > 0 )
            {
                sprintf( ( n_string )str, "%.1f\n", histogram[i] / 10.0f );
                io_string_write( beingstr, str, &watch_string_length );
            }
            else
            {
                io_string_write( beingstr, "----\n", &watch_string_length );
            }
        }
        output_function( beingstr );
        return;
    }

    if ( group->select )
    {
        local_being = group->select;

        watch_string_length = 0;

        switch ( watch_type )
        {
        case WATCH_ALL:
        {
            watch_stats( ptr, being_get_select_name( group ), local_being, beingstr );
            break;
        }
        case WATCH_SOCIAL_GRAPH:
        {
            watch_social_graph( ptr, being_get_select_name( group ), local_being, beingstr );
            break;
        }
        case WATCH_EPISODIC:
        {
            watch_episodic( ptr, being_get_select_name( group ), local_being, beingstr );
            break;
        }
        case WATCH_BRAINCODE:
        {
            watch_braincode( ptr, being_get_select_name( group ), local_being, beingstr );
            break;
        }
        case WATCH_BRAINPROBES:
        {
            watch_brainprobes( ptr, being_get_select_name( group ), local_being, beingstr );
            break;
        }

        case WATCH_APPEARANCE:
        {
            watch_appearance( ptr, being_get_select_name( group ), local_being, beingstr );
            break;
        }
        case WATCH_SPEECH:
        {
            watch_speech( ptr, being_get_select_name( group ), local_being, beingstr );
            break;
        }
        case WATCH_PATHOGENS:
        {
            watch_pathogen_graph( ptr, being_get_select_name( group ), local_being, beingstr );
            break;
        }
        }

        if ( watch_type != WATCH_NONE )
        {
            output_function( beingstr );
        }
    }
    being_remove_external_set( 0 );
}

static n_int command_on_off( n_string response )
{
    n_int length;

    if ( response == 0 )
    {
        return -1;
    }

    length = io_length( response, STRING_BLOCK_SIZE );
    if ( ( io_find( response, 0, length, "off", 3 ) > -1 ) ||
            ( io_find( response, 0, length, "0", 1 ) > -1 ) ||
            ( io_find( response, 0, length, "false", 5 ) > -1 ) ||
            ( io_find( response, 0, length, "no", 2 ) > -1 ) )
    {
        return 0;
    }

    if ( ( io_find( response, 0, length, "on", 2 ) > -1 ) ||
            ( io_find( response, 0, length, "1", 1 ) > -1 ) ||
            ( io_find( response, 0, length, "true", 4 ) > -1 ) ||
            ( io_find( response, 0, length, "yes", 3 ) > -1 ) )
    {
        return 1;
    }

    return -1;
}

n_int command_event( void *ptr, n_string response, n_console_output output_function )
{
#ifdef EPISODIC_ON
    n_int return_response = command_on_off( response );

    if ( ( return_response == -1 ) && response )
    {
        if ( io_find( response, 0, io_length( response, STRING_BLOCK_SIZE ), "social", 6 ) > -1 )
        {
            episodic_logging( output_function, 1 );
            output_function( "Event output for social turned on" );
        }
        return 0;
    }

    if ( return_response == 0 )
    {
        episodic_logging( 0L, 0 );
        output_function( "Event output turned off" );
    }
    else
    {
        episodic_logging( output_function, 0 );
        output_function( "Event output turned on" );
    }
#else
    output_function( "Episodic not supported in this build" );
#endif
    return 0;
}

n_int command_memory( void *ptr, n_string response, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;
    n_string_block str2;
    sprintf( str2, "maximum memory %ld\nallocated memory %ld\nmaximum apes %ld",
             sim_memory_allocated( 1 ), sim_memory_allocated( 0 ), group->max );
    output_function( str2 );
    return 0;
}

/**
 * Enable or disable logging
 * @param ptr pointer to simulated_group object
 * @param response command parameters - off/on/0/1/yes/no
 * @param output_function function to be used to display output
 * @return 0
 */
n_int command_logging( void *ptr, n_string response, n_console_output output_function )
{
    n_int return_response = command_on_off( response );

    if ( return_response == -1 )
    {
        return 0;
    }
    if ( return_response == 0 )
    {
        nolog = 1;
        indicator_index = 0;
        watch_type = WATCH_NONE;
        output_function( "Logging turned off" );
    }
    else
    {
        nolog = 0;
        indicator_index = 1;
        output_function( "Logging turned on" );
    }
    return 0;
}

#ifdef BRAINCODE_ON

/**
 * Compare two braincode arrays
 * @param braincode0 Braincode array for the first being
 * @param braincode1 Braincode byte array for the second being
 * @param block_size The number of instructions to compare within a block
 * @returns Location of the first match within the first braincode array
 */
static n_int command_compare_brain( n_byte *braincode0, n_byte *braincode1, n_int block_size )
{
    n_int block_size_bytes = block_size * BRAINCODE_BYTES_PER_INSTRUCTION;
    n_int loop = 0;
    while ( loop < ( BRAINCODE_SIZE - block_size_bytes ) )
    {
        n_int loop2 = 0;
        while ( loop2 < ( BRAINCODE_SIZE - block_size_bytes ) )
        {
            n_int block_step = 0;
            while ( block_step < block_size )
            {
                if ( braincode0[loop + block_step * BRAINCODE_BYTES_PER_INSTRUCTION] ==
                        braincode1[loop2 + block_step * BRAINCODE_BYTES_PER_INSTRUCTION] )
                {
                    block_step++;
                    if ( block_step == block_size )
                    {
                        return loop;
                    }
                }
                else
                {
                    break;
                }
            }
            loop2 += BRAINCODE_BYTES_PER_INSTRUCTION;
        }
        loop += BRAINCODE_BYTES_PER_INSTRUCTION;
    }
    return -1;
}

#endif

/**
 * Shows repeated sections of braincode
 * @param ptr pointer to simulated_group
 * @param response response string
 * @param output_function output function
 * @returns 0
 */
n_int command_idea( void *ptr, n_string response, n_console_output output_function )
{
#ifdef BRAINCODE_ON
#ifndef CONSOLE_IDEA_MIN_BLOCK_SIZE
#define CONSOLE_IDEA_MIN_BLOCK_SIZE 3
#define CONSOLE_IDEA_MAX_BLOCK_SIZE 8
#endif
    const n_int min_block_size = 3;
    const n_int max_block_size = 8;
    n_uint i, total_matches = 0, total_tests = 0;
    n_uint histogram[5 + 1];
    simulated_group *group = ( simulated_group * ) ptr;
    /* clear the histogram */
    for ( i = 0; i <= ( n_uint )( max_block_size - min_block_size ); i++ )
    {
        histogram[i] = 0;
    }

    if ( group->select )
    {
        n_uint loop = 0;
        while ( loop < group->num )
        {
            simulated_being *local_being = &( group->beings[loop] );
            n_byte *bc_external = being_braincode_external( local_being );
            if ( bc_external )
            {

                n_uint loop2 = loop + 1;
                while ( loop2 < group->num )
                {
                    simulated_being *local_being2 = &( group->beings[loop2] );
                    n_byte *bc_external2 = being_braincode_external( local_being2 );

                    if ( bc_external2 )
                    {
                        n_int   location = 0;
                        n_int   block_size = min_block_size;

                        while ( block_size <= max_block_size )
                        {
                            location = command_compare_brain( bc_external,
                                                              bc_external2,
                                                              block_size );

                            if ( location != -1 )
                            {
                                histogram[block_size - min_block_size]++;
                                total_matches++;
                            }
                            total_tests++;
                            block_size++;
                        }
                    }
                    loop2++;
                }

            }
            loop++;
        }
    }

    if ( total_tests > 0 )
    {
        n_string_block output;

        sprintf( output, "Matches %03u.%04u percent\n",
                 ( n_c_int )( total_matches * 100 / total_tests ),
                 ( n_c_int )( total_matches * 1000000 / total_tests ) % 10000 );
        output_function( output );


        output_function( "Block Percent   Instances" );
        output_function( "-------------------------" );

        for ( i = 0; i <= ( n_uint )( max_block_size - min_block_size ); i++ )
        {
            sprintf( output, "%02u    %03u.%04u  %04u",
                     ( n_c_int )( i + min_block_size ),
                     ( n_c_int )( histogram[i] * 100 / total_tests ),
                     ( n_c_int )( ( histogram[i] * 1000000 / total_tests ) % 10000 ),
                     ( n_c_int )histogram[i] );
            output_function( output );
        }
    }

#endif
    return 0;
}

/**
 * Watch a particular being
 * @param ptr pointer to simulated_group object
 * @param response command parameters
 * @param output_function function to be used to display output
 * @return 0
 */
n_int command_watch( void *ptr, n_string response, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;
    n_int          length;
    n_string_block output;
    n_int          position = 0;

    if ( command_check_ape_present( ptr, output_function ) == 0 )
    {
        return 0;
    }

    if ( response == 0L )
    {
        return 0;
    }
    else
    {
        length = io_length( response, STRING_BLOCK_SIZE );
    }

    if ( ( length < 5 ) && ( io_find( response, 0, length, "off", 3 ) > -1 ) )
    {
        output_function( "Stopped watching" );
        watch_type = WATCH_NONE;
        return 0;
    }

    if ( ( length < 10 ) && ( io_find( response, 0, length, "state", 5 ) > -1 ) )
    {
        watch_type = WATCH_STATES;
        output_function( "Watching being states" );
        return 0;
    }

    if ( being_from_name( group, response ) != 0 )
    {
        being_set_select_name( group, response );
        io_string_write( output, "Watching ", &position );
        io_string_write( output, being_get_select_name( group ), &position );
        output_function( output );
        position = 0;
        watch_type = WATCH_ALL;
    }
    else
    {
        if ( group->select )
        {
            if ( io_find( response, 0, length, "braincode", 9 ) > -1 )
            {
                watch_type = WATCH_BRAINCODE;
                io_string_write( output, "Watching braincode for ", &position );
                io_string_write( output, being_get_select_name( group ), &position );
                output_function( output );
                return 0;
            }
            if ( ( io_find( response, 0, length, "brainprobe", 10 ) > -1 ) ||
                    ( io_find( response, 0, length, "brain probe", 11 ) > -1 ) ||
                    ( io_find( response, 0, length, "probes", 6 ) > -1 ) )
            {
                watch_type = WATCH_BRAINPROBES;
                io_string_write( output, "Watching brain probes for ", &position );
                io_string_write( output, being_get_select_name( group ), &position );
                output_function( output );
                return 0;
            }
            if ( ( io_find( response, 0, length, "graph", 5 ) > -1 ) ||
                    ( io_find( response, 0, length, "friend", 6 ) > -1 ) )
            {
                watch_type = WATCH_SOCIAL_GRAPH;

                io_string_write( output, "Watching social graph for ", &position );
                io_string_write( output, being_get_select_name( group ), &position );
                output_function( output );
                return 0;
            }
            if ( ( io_find( response, 0, length, "episodic", 8 ) > -1 ) ||
                    ( io_find( response, 0, length, "episodic memory", 15 ) > -1 ) ||
                    ( io_find( response, 0, length, "memory", 6 ) > -1 ) )
            {
                watch_type = WATCH_EPISODIC;

                io_string_write( output, "Watching episodic memory for ", &position );
                io_string_write( output, being_get_select_name( group ), &position );
                output_function( output );
                return 0;
            }
            if ( io_find( response, 0, length, "pathogen", 8 ) > -1 )
            {
                watch_type = WATCH_PATHOGENS;

                io_string_write( output, "Watching pathogen for ", &position );
                io_string_write( output, being_get_select_name( group ), &position );
                output_function( output );
                return 0;
            }
            if ( io_find( response, 0, length, "speech", 6 ) > -1 )
            {
                watch_type = WATCH_SPEECH;

                io_string_write( output, "Watching speech for ", &position );
                io_string_write( output, being_get_select_name( group ), &position );
                output_function( output );
                return 0;
            }
            if ( ( length < 5 ) && ( io_find( response, 0, length, "all", 3 ) > -1 ) )
            {
                watch_type = WATCH_ALL;

                io_string_write( output, "Watching ", &position );
                io_string_write( output, being_get_select_name( group ), &position );
                output_function( output );
                return 0;
            }

            if ( io_find( response, 0, length, "appear", 6 ) > -1 )
            {
                watch_type = WATCH_APPEARANCE;
                io_string_write( output, "Watching appearance for ", &position );
                io_string_write( output, being_get_select_name( group ), &position );
                output_function( output );
                return 0;
            }
        }

        output_function( "Being not found\n" );
    }
    return 0;
}

/**
 * Set the time interval for simulation
 * @param ptr pointer to simulated_group object
 * @param response command parameters
 * @param output_function function used to display the output
 * @return 0
 */
n_int command_interval( void *ptr, n_string response, n_console_output output_function )
{
    n_int number = 1, interval = INTERVAL_DAYS, interval_set = 0;

    if ( response != 0 )
    {
        if ( io_length( response, STRING_BLOCK_SIZE ) > 0 )
        {
            if ( get_time_interval( response, &number, &interval ) > -1 )
            {
                if ( number > 0 )
                {
                    n_string_block  output, number_string;
                    save_interval_steps = number * interval_steps[interval];
                    io_number_to_string( number_string, number );
                    io_three_strings( output, "Logging interval set to ", number_string, ( n_string )interval_description[interval], 0 );
                    output_function( output );
                    interval_set = 1;
                }
            }
        }
    }

    if ( interval_set == 0 )
    {
        if ( save_interval_steps < 60 )
        {
            n_string_block  output, number_string;
            io_number_to_string( number_string, save_interval_steps );
            io_three_strings( output, "Current time interval is ", number_string, " min(s)", 0 );
            output_function( output );
        }
        else
        {
            if ( save_interval_steps < 60 * 24 )
            {
                n_string_block  output, number_string;
                io_number_to_string( number_string, save_interval_steps / 60 );
                io_three_strings( output, "Current time interval is ", number_string, " hour(s)", 0 );
                output_function( output );
            }
            else
            {
                n_string_block  output, number_string;
                io_number_to_string( number_string, save_interval_steps / ( 60 * 24 ) );
                io_three_strings( output, "Current time interval is ", number_string, " day(s)", 0 );
                output_function( output );
            }
        }
    }
    return 0;
}

n_int command_stop( void *ptr, n_string response, n_console_output output_function )
{
    simulation_running = 0;
    if ( output_function )
    {
        output_function( "Simulation stopped" );
    }
    return 0;
}

/**
 *
 * @param ptr pointer to simulated_group
 * @param response response string
 * @param output_function output function
 */
n_int command_file( void *ptr, n_string response, n_console_output output_function )
{
    io_search_file_format( simulated_file_format, response );
    return 0;
}

/**
 * Run the simulation for a single time interval
 * @param ptr pointer to simulated_group object
 * @param response command parameters
 * @param output_function function used to display the output
 * @return 0
 */
n_int command_step( void *ptr, n_string response, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;
    n_uint loop = 0;

    if ( response != RUN_STEP_CONST )
    {
        if ( simulation_executing == 1 )
        {
            output_function( "Simulation already running" );
            return 0;
        }

        if ( command_file_interaction )
        {
            output_function( "File interaction in use: step" );
            return 0;
        }

        simulation_executing = 1;
    }
    simulation_running = 1;

    while ( ( loop < save_interval_steps ) && simulation_running )
    {
        sim_cycle();
        if ( group->num == 0 )
        {
            simulation_running = 0;
        }
        loop++;
    }
    if ( response != RUN_STEP_CONST )
    {
        watch_being( group, output_function );
    }

    if ( response != RUN_STEP_CONST )
    {
        simulation_executing = 0;
    }

    return 0;
}

/**
 * Run the simulation
 * @param ptr pointer to simulated_group object
 * @param response command parameters
 * @param output_function function used to display the output
 * @return 0
 */
n_int command_run( void *ptr, n_string response, n_console_output output_function )
{
    n_uint run = 0;
    n_int  number = 0, interval = INTERVAL_DAYS;
    n_int  forever = 0;

    if ( simulation_executing == 1 )
    {
        output_function( "Simulation already running" );
        return 0;
    }

    if ( command_file_interaction )
    {
        output_function( "File interaction in use: run" );
        return 0;
    }

    simulation_executing = 1;

    simulation_running = 1;

    if ( response != 0L )
    {
        n_int length = io_length( response, STRING_BLOCK_SIZE );
        if ( length > 0 )
        {
            if ( ( io_find( response, 0, length, "forever", 7 ) > -1 ) )
            {
                forever = 1;
                number = 1;
            }
            else if ( get_time_interval( response, &number, &interval ) <= -1 )
            {
                number = -1;
            }

            if ( number > 0 )
            {
                n_uint i = 0;
                n_string_block  output;
                n_uint end_point = ( number * interval_steps[interval] );
                n_uint temp_save_interval_steps = save_interval_steps;
                n_uint count = 0;
                save_interval_steps = 1;

                if ( forever )
                {
                    io_three_strings( output, "Running forever (type \"stop\" to end)", "", "", 0 );
                }
                else
                {
                    n_string_block  number_string;
                    io_number_to_string( number_string, number );
                    io_three_strings( output, "Running for ", number_string, ( n_string )interval_description[interval], 0 );
                }

                output_function( output );

                while ( ( i < end_point ) && simulation_running )
                {
                    command_step( ptr, RUN_STEP_CONST, output_function );

                    if ( temp_save_interval_steps )
                    {
                        if ( ( count % temp_save_interval_steps ) == 0 )
                        {
                            watch_being( ptr, output_function );
                        }
                    }
                    count++;
                    if ( !forever )
                    {
                        i++;
                    }
                }

                if ( temp_save_interval_steps )
                {
                    if ( ( count % temp_save_interval_steps ) != 1 )
                    {
                        watch_being( ptr, output_function );
                    }
                }

                save_interval_steps = temp_save_interval_steps;
                run = 1;
            }
        }
    }

    simulation_executing = 0;

    if ( run == 0 )
    {
        ( void )SHOW_ERROR( "Time not specified, examples: run 2 days, run 6 hours" );
    }

    return 0;
}

/**
 * Reset the simulation
 * @param ptr pointer to simulated_group object
 * @param response command parameters
 * @param output_function function used to display the output
 * @return 0
 */
n_int command_reset( void *ptr, n_string response, n_console_output output_function )
{
    n_byte2 seed[2];
    n_byte2 *local_land_genetics = land_genetics();

    seed[0] = local_land_genetics[0];
    seed[1] = local_land_genetics[1];

    math_random3( seed );

    if ( sim_init( KIND_NEW_SIMULATION, ( n_uint )( ( seed[0] << 16 ) | seed[1] ), MAP_AREA, 0 ) )
    {
        output_function( "Simulation reset" );
        return 0;
    }
    output_function( "Simulation has not enough memory" );
    return 1;
}

/**
 * Returns a mode value used by epic and top commands
 * @param response command parameter: female/male/juvenile
 * @return 0
 */
static n_byte command_get_response_mode( n_string response )
{
    n_int length;
    if ( response == 0L )
    {
        return 0;
    }
    length = io_length( response, STRING_BLOCK_SIZE );
    if ( response != 0 )
    {
        /** females */
        if ( io_find( response, 0, length, "fem", 3 ) > -1 )
        {
            return 1;
        }
        /** males */
        if ( io_find( response, 0, length, "male", 4 ) > -1 )
        {
            return 2;
        }
        /** juveniles */
        if ( ( io_find( response, 0, length, "juv", 3 ) > -1 ) ||
                ( io_find( response, 0, length, "chil", 4 ) > -1 ) )
        {
            return 3;
        }
    }
    return 0;
}

n_int command_speak( void *ptr, n_string response, n_console_output output_function )
{
    n_string_block paragraph = {0};
    simulated_group *group = ( simulated_group * ) ptr;
    simulated_being *local = group->select;
    watch_speech( ptr, 0L, local, paragraph );
    watch_string_length = 0;
    speak_out( response, paragraph );
    return 0;
}

n_int command_alphabet( void *ptr, n_string response, n_console_output output_function )
{
    speak_out( response, " aeio a e i o vfstpbjm abefijmopstv a b e f i j m o p s t v.  .  \n" );
    return 0;
}


n_int command_save( void *ptr, n_string response, n_console_output output_function )
{
    n_file *file_opened;
    n_string_block output_string;

    if ( response == 0L )
    {
        return 0;
    }

    if ( command_file_interaction )
    {
        if ( output_function )
        {
            output_function( "File interaction in use: save" );
        }
        return 0;
    }

    command_stop( ptr, "", output_function );

    file_opened = tranfer_out_json();
    if ( file_opened == 0L )
    {
        return SHOW_ERROR( "Failed to generate output contents" );
    }

    command_file_interaction = 1;

    io_disk_write( file_opened, response );
    io_file_free( &file_opened );

    if ( output_function )
    {
        n_int position = 0;
        io_string_write( command_file_name, response, &position );
        position = 0;

        io_string_write( output_string, "Simulation file ", &position );
        io_string_write( output_string, response, &position );
        io_string_write( output_string, " saved\n", &position );
        output_function( output_string );
    }

    command_file_interaction = 0;

    return 0;
}

/* load simulation-data/script */
static n_int command_base_open( void *ptr, n_string response, n_console_output output_function, n_byte script )
{
    if ( response == 0L )
    {
        return 0;
    }

    if ( command_file_interaction )
    {
        if ( output_function )
        {
            output_function( "File interaction in use: open" );
        }
        return 0;
    }

    command_stop( ptr, "", output_function );
    command_file_interaction = 1;

    if ( io_disk_check( response ) != 0 )
    {
        n_file *file_opened = io_file_new();
        n_string_block output_string;

        if ( io_disk_read( file_opened, response ) != FILE_OKAY )
        {
            io_file_free( &file_opened );
            command_file_interaction = 0;
            return SHOW_ERROR( "Failed to open file" );
        }

        if ( script )
        {
            if ( sim_interpret( file_opened ) != 0 )
            {
                io_file_free( &file_opened );
                command_file_interaction = 0;
                return SHOW_ERROR( "Failed to interpret file" );
            }
        }
        else
        {
            if ( tranfer_in( file_opened ) != 0 )
            {
                io_file_free( &file_opened );
                command_file_interaction = 0;
                return SHOW_ERROR( "Failed to read in file" );
            }
            if ( sim_init( KIND_LOAD_FILE, 0, MAP_AREA, 0 ) == 0L )
            {
                return SHOW_ERROR( "Not enough memory to load file" );
            }
            io_file_free( &file_opened );
        }
        command_file_interaction = 0;
        if ( output_function )
        {
            n_int position = 0;
            io_string_write( command_file_name, response, &position );

            position = 0;

            io_string_write( output_string, "Simulation file ", &position );
            io_string_write( output_string, response, &position );
            io_string_write( output_string, " open\n", &position );

            output_function( output_string );
        }
    }
    return 0;
}

/* load simulation data */
n_int command_open( void *ptr, n_string response, n_console_output output_function )
{
    return command_base_open( ptr, response, output_function, 0 );
}

/* load apescript file */
n_int command_script( void *ptr, n_string response, n_console_output output_function )
{
    return command_base_open( ptr, response, output_function, 1 );
}

/**
 * Displays beings in descending order of honor value
 * @param ptr pointer to simulated_group object
 * @param response command parameters
 * @param output_function function used to display the output
 * @return 0
 */
n_int command_top( void *ptr, n_string response, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;

    n_uint i, j;
    n_int  k;
    n_uint max = 10;
    n_byte *eliminated;
    n_uint current_date, local_dob, age_in_years, age_in_months, age_in_days;
    n_string_block str;
    simulated_being *b;
    n_byte mode = command_get_response_mode( response );

    output_function( "Honor Name                     Sex\tAge" );
    output_function( "-----------------------------------------------------------------" );

    eliminated = ( n_byte * )memory_new( group->num * sizeof( n_byte ) );
    for ( i = 0; i < group->num; i++ )
    {
        eliminated[i] = 0;
    }

    if ( group->num < max )
    {
        max = group->num;
    }
    for ( i = 0; i < max; i++ )
    {
        n_int winner = -1;
        n_int max_honor = 0;
        n_byte passed;
        n_string_block output_value;

        for ( j = 0; j < group->num; j++ )
        {
            if ( eliminated[j] == 0 )
            {
                n_int honor;
                b = &group->beings[j];

                honor = being_honor( b );

                if ( honor >= max_honor )
                {
                    passed = 0;
                    switch ( mode )
                    {
                    case 0:
                    {
                        passed = 1;
                        break;
                    }
                    case 1:
                    {
                        if ( FIND_SEX( GET_I( b ) ) == SEX_FEMALE )
                        {
                            passed = 1;
                        }
                        break;
                    }
                    case 2:
                    {
                        if ( FIND_SEX( GET_I( b ) ) != SEX_FEMALE )
                        {
                            passed = 1;
                        }
                        break;
                    }
                    case 3:
                    {
                        if ( AGE_IN_DAYS( b ) < AGE_OF_MATURITY )
                        {
                            passed = 1;
                        }
                        break;
                    }
                    }

                    if ( passed != 0 )
                    {
                        winner = ( n_int )j;
                        max_honor = honor;
                    }
                }
            }
        }

        if ( winner == -1 )
        {
            break;
        }

        eliminated[winner] = 1;
        b = &group->beings[winner];

        sprintf( output_value, "%03d   ", ( int )( being_honor( b ) ) );

        being_name_simple( b, str );

        io_three_strings( output_value, output_value, str, "", 0 );

        for ( k = 0; k < 25 - io_length( str, STRING_BLOCK_SIZE ); k++ )
        {
            io_three_strings( output_value, output_value, " ", "", 0 );
        }
        if ( FIND_SEX( GET_I( b ) ) == SEX_FEMALE )
        {
            io_three_strings( output_value, output_value, "Female\t", "", 0 );
        }
        else
        {
            io_three_strings( output_value, output_value, "Male\t", "", 0 );
        }

        current_date = land_date();
        local_dob = ( n_uint )being_dob( b );
        age_in_years = ( n_uint )AGE_IN_YEARS( b );
        age_in_months = ( ( current_date - local_dob ) - ( age_in_years * TIME_YEAR_DAYS ) ) / ( TIME_YEAR_DAYS / 12 );
        age_in_days = ( current_date - local_dob ) - ( ( TIME_YEAR_DAYS / 12 ) * age_in_months ) - ( age_in_years * TIME_YEAR_DAYS );

        if ( age_in_years > 0 )
        {
            n_string_block number;
            io_number_to_string( number, age_in_years );
            io_three_strings( output_value, output_value, number, " yrs ", 0 );
        }
        if ( age_in_months > 0 )
        {
            n_string_block number;
            io_number_to_string( number, age_in_months );
            io_three_strings( output_value, output_value, number, " mnths ", 0 );
        }
        {
            n_string_block number;
            io_number_to_string( number, age_in_days );
            io_three_strings( output_value, output_value, number, "  days", 0 );
        }
        output_function( output_value );

    }

    memory_free( ( void ** )&eliminated );

    return 0;
}

n_int command_debug( void *ptr, n_string response, n_console_output output_function )
{
    command_audit();
    return 0;
}

/**
 * Lists the most talked about beings, based upon episodic memories
 * @param ptr pointer to simulated_group object
 * @param response command parameters
 * @param output_function function used to display the output
 * @return 0
 */
n_int command_epic( void *ptr, n_string response, n_console_output output_function )
{
    simulated_group *group = ( simulated_group * ) ptr;

    n_uint i, j, k, e;
    simulated_being *local_being;
    simulated_iepisodic *local_episodic;
    const n_uint max = 1024;
    n_byte2 *first_name = ( n_byte2 * )memory_new( max * sizeof( n_byte2 ) );
    n_byte2 *family_name = ( n_byte2 * )memory_new( max * sizeof( n_byte2 ) );
    n_byte2 *hits = ( n_byte2 * )memory_new( max * sizeof( n_byte2 ) );
    n_byte2 temp;
    n_string_block name;
    n_byte passed, mode = command_get_response_mode( response );

    /** clear the list of beings and their hit scores */
    for ( i = 0; i < max; i++ )
    {
        first_name[i] = 0;
        family_name[i] = 0;
        hits[i] = 0;
    }

    for ( i = 0; i < group->num; i++ )
    {
        /** get the being */
        local_being = &group->beings[i];

        /** get the episodic memories for the being */
        local_episodic = being_episodic( local_being );

        /** skip is no memories were retrieved */
        if ( local_episodic == 0L )
        {
            continue;
        }

        /** for all memories */
        for ( e = 0; e < EPISODIC_SIZE; e++ )
        {
            /** non-empty slot */
            if ( local_episodic[e].event > 0 )
            {
                /** j = 0 is the being having the memory
                     j = 1 is the being who is the subject of the memory */
                for ( j = BEING_MEETER; j <= BEING_MET; j++ )
                {
                    /** name should be non-zero */
                    if ( local_episodic[e].first_name[j] +
                            local_episodic[e].family_name[j] > 0 )
                    {
                        passed = 0;
                        switch ( mode )
                        {
                        case 0:
                        {
                            passed = 1;
                            break;
                        }
                        case 1:
                        {
                            if ( ( local_episodic[e].first_name[j] >> 8 ) == SEX_FEMALE )
                            {
                                passed = 1;
                            }
                            break;
                        }
                        case 2:
                        {
                            if ( ( local_episodic[e].first_name[j] >> 8 ) != SEX_FEMALE )
                            {
                                passed = 1;
                            }
                            break;
                        }
                        case 3:
                        {
                            simulated_being *b = 0L;
                            n_string_block name;

                            being_name_byte2( local_episodic[e].first_name[j], local_episodic[e].family_name[j], name );

                            b = being_from_name( group, name );
                            if ( b != 0L )
                            {
                                if ( AGE_IN_DAYS( b ) < AGE_OF_MATURITY )
                                {
                                    passed = 1;
                                }
                            }
                            break;
                        }
                        }

                        if ( passed != 0 )
                        {
                            /** Avoid memories about yourself, since we're interested
                               in gossip about other beings */

                            if ( being_name_comparison( local_being, local_episodic[e].first_name[j], local_episodic[e].family_name[j] ) )
                            {
                                if ( ( ( j == BEING_MET ) &&
                                        ( local_episodic[e].event != EVENT_SEEK_MATE ) &&
                                        ( local_episodic[e].event != EVENT_EAT ) ) ||
                                        ( j == BEING_MEETER ) )
                                {
                                    /** add this being to the list, or increment its hit score */
                                    for ( k = 0; k < max; k++ )
                                    {
                                        if ( hits[k] == 0 ) /**< last entry in the list */
                                        {
                                            first_name[k] = local_episodic[e].first_name[j];
                                            family_name[k] = local_episodic[e].family_name[j];
                                            break;
                                        }
                                        if ( first_name[k] == local_episodic[e].first_name[j] )
                                        {
                                            if ( family_name[k] == local_episodic[e].family_name[j] )
                                            {
                                                /** being found in the list */
                                                break;
                                            }
                                        }
                                    }
                                    /** increment the hit score for the being */
                                    if ( k < max )
                                    {
                                        hits[k]++;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /** top 10 most epic beings */
    for ( i = 0; i < 10; i++ )
    {
        /** search the rest of the list */
        for ( j = i + 1; j < max; j++ )
        {
            if ( hits[j] == 0 )
            {
                break;    /**< end of the list */
            }

            /** if this being has more hits then swap list entries, so that
             the most popular beings are at the top of the list */
            if ( hits[j] > hits[i] )
            {
                /** swap */
                temp = first_name[j];
                first_name[j] = first_name[i];
                first_name[i] = temp;

                temp = family_name[j];
                family_name[j] = family_name[i];
                family_name[i] = temp;

                temp = hits[j];
                hits[j] = hits[i];
                hits[i] = temp;
            }
        }
        if ( hits[i] > 0 )
        {
            n_string_block output_value;
            /** get the name of the being */

            being_name_byte2( first_name[i], family_name[i], name );

            sprintf( output_value, "%06d %s", ( int )hits[i], name );
            output_function( output_value );
        }
    }

    /** free list memory */
    memory_free( ( void ** )&first_name );
    memory_free( ( void ** )&family_name );
    memory_free( ( void ** )&hits );

    return 0;
}

n_int command_quit( void *ptr, n_string response, n_console_output output_function )
{
    simulation_executing = 0;

    ( void )command_stop( ptr, response, output_function );
    return io_quit( ptr, response, output_function );
}



/* ./universe/loop.c */
/****************************************************************

 loop.c

 =============================================================



 ****************************************************************/

#include "entity.h"

#include "universe.h"

#include <stdio.h>


void loop_no_thread( simulated_group *group, simulated_being *being_not, loop_fn bf_func, void *data )
{
    n_uint loop = 0;
    while ( loop < group->num )
    {
        simulated_being *output = &( group->beings[loop] );
        if ( output != being_not )
        {
            bf_func( group, output, data );
        }
        loop++;
    }
}


void loop_being_no_sim( simulated_being *beings, n_uint number_beings, loop_no_sim_fn bf_func, void *data )
{
    n_uint loop  = 0;
    while ( loop < number_beings )
    {
        simulated_being *output = &( beings[loop] );
        bf_func( output, data );
        loop++;
    }
}

void loop_being_no_sim_no_data( simulated_being *beings, n_uint number_beings, loop_no_sim_no_data_fn bf_func )
{
    n_uint loop  = 0;
    while ( loop < number_beings )
    {
        simulated_being *output = &( beings[loop] );
        bf_func( output );
        loop++;
    }
}


static void loop_add_generic( execute_function *function, void *general_data, void *read_data, void *write_data, n_int count, n_int size )
{
    if ( size )
    {
        n_byte *location = ( n_byte * )read_data;
        n_int   loop = 0;
        while ( loop < count )
        {
            if ( function( general_data, ( void * )&location[loop * size], 0L ) == -1 )
            {
                break;
            }
            loop++;
        }
    }
    else
    {
        function( general_data, read_data, write_data );
    }
}

void loop_being( simulated_group *group, loop_fn bf_func, n_int beings_per_thread )
{
    n_uint loop  = 0;
    n_uint count = ( n_uint )beings_per_thread;
    n_uint beings_per_thread_uint = ( n_uint )beings_per_thread;
    while ( loop < group->num )
    {
        simulated_being *output = &( group->beings[loop] );

        if ( ( beings_per_thread_uint + loop ) >= group->num )
        {
            count = group->num - loop;
        }

        loop_add_generic( ( execute_function * )bf_func, ( void * )group, ( void * )output, 0L, ( n_int )count, sizeof( simulated_being ) );

        if ( count != beings_per_thread_uint )
        {
            break;
        }
        else
        {
            loop += count;
        }
    }
}


typedef struct
{
    n_string name;
    simulated_being *being_from_name;
} being_from_name_loop_struct;

static void being_from_name_loop( simulated_group *group, simulated_being *local, void *data )
{
    being_from_name_loop_struct *bfns = ( being_from_name_loop_struct * )data;
    n_string_block str;

    if ( bfns->being_from_name )
    {
        return;
    }

    being_name_simple( local, str );

    io_lower( str, io_length( str, STRING_BLOCK_SIZE ) );

    if ( io_find( str, 0, io_length( str, STRING_BLOCK_SIZE ), bfns->name, io_length( bfns->name, STRING_BLOCK_SIZE ) ) > -1 )
    {
        bfns->being_from_name = local;
    }
}

/**
 * @brief return the being array index with the given name
 * @param group Pointer to the simulated_group object
 * @param name Name of the being
 * @return Array index of the being within the simulation object
 */
simulated_being *being_from_name( simulated_group *group, n_string name )
{
    being_from_name_loop_struct bfns;
    bfns.being_from_name = 0L;
    io_lower( name, io_length( name, STRING_BLOCK_SIZE ) );
    bfns.name = name;
    loop_no_thread( group, 0L, being_from_name_loop, &bfns );
    return bfns.being_from_name;
}

void being_set_select_name( simulated_group *group, n_string name )
{
    simulated_being *response = being_from_name( group, name );
    if ( response == 0L )
    {
        ( void )SHOW_ERROR( "Ape not found" );
        return;
    }
    group->select = response;
}

n_string being_get_select_name( simulated_group *group )
{
    static n_string_block name;
    n_int  position = 0;
    if ( group->select == 0L )
    {
        io_string_write( name, "*** ALL APES DEAD ***", &position );
    }
    else
    {
        being_name_simple( group->select, name );
    }
    return ( n_string )name;
}

typedef struct
{
    n_int         parse_requirements;
    n_int         older;
    n_uint        comparison_best;
    n_int         actual_age;
    n_genetics   *genetics;
    simulated_being *return_value;
} being_find_closest_struct;

static void being_find_closest_loop( simulated_group *group, simulated_being *local, void *data )
{
    being_find_closest_struct *bfcs = ( being_find_closest_struct * )data;

    n_byte success = 0;
    n_int  local_dob = being_dob( local );

    if ( bfcs->older == 0 )
    {
        success = 1;
    }

    if ( ( bfcs->older == 1 ) && ( ( local_dob - AGE_OF_MATURITY ) > bfcs->actual_age ) )
    {
        success = 1;
    }

    if ( ( bfcs->older == -1 ) && ( ( bfcs->actual_age - AGE_OF_MATURITY ) > local_dob ) )
    {
        success = 1;
    }

    if ( success )
    {
        n_uint comparison = being_genetic_comparison( bfcs->genetics, being_genetics( local ), bfcs->parse_requirements );
        if ( comparison > bfcs->comparison_best )
        {
            bfcs->comparison_best = comparison;
            bfcs->return_value = local;
        }
    }

}

static simulated_being *being_find_closest( simulated_group *group, simulated_being *actual, n_int parse_requirements, n_int older )
{
    being_find_closest_struct bfcs;
    bfcs.parse_requirements = parse_requirements;
    bfcs.older = older;
    /** comparison must be better than average */
    bfcs.comparison_best = 3 * sizeof( n_genetics ) * CHROMOSOMES;
    bfcs.return_value = 0L;
    bfcs.genetics = being_genetics( actual );
    bfcs.actual_age = being_dob( actual );

    loop_no_thread( group, actual, being_find_closest_loop, &bfcs );

    return bfcs.return_value;
}

typedef struct
{
    n_uint        comparison_best;
    n_int         max_age;
    n_genetics   *genetics;
    simulated_being *return_value;
} being_find_child_struct;

static void being_find_child_loop( simulated_group *group, simulated_being *local, void *data )
{
    being_find_child_struct *bfcs = ( being_find_child_struct * ) data;
    n_uint  comparison = being_genetic_comparison( bfcs->genetics, being_genetics( local ), -1 );
    if ( ( comparison > bfcs->comparison_best ) &&
            ( ( land_date() - being_dob( local ) ) < bfcs->max_age ) )
    {
        bfcs->comparison_best = comparison;
        bfcs->return_value = local;
    }
}

static simulated_being *being_find_child( simulated_group *group, n_genetics *genetics, n_int max_age )
{
    being_find_child_struct bfcs;
    bfcs.comparison_best = 0;
    bfcs.max_age = max_age;
    bfcs.genetics = genetics;
    bfcs.return_value = 0L;
    loop_no_thread( group, 0L, being_find_child_loop, &bfcs );
    return bfcs.return_value;
}

typedef struct
{
    n_byte2 first_gender;
    n_byte2 family;
    simulated_being *local;
} being_find_name_struct;

static void being_find_name_loop( simulated_group *group, simulated_being *local, void *data )
{
    being_find_name_struct *bfns = ( being_find_name_struct * )data;
    if ( bfns->local == 0L )
    {
        if ( being_name_comparison( local, bfns->first_gender, bfns->family ) )
        {
            bfns->local = local;
        }
    }
}

simulated_being *being_find_name( simulated_group *group, n_byte2 first_gender, n_byte2 family )
{
    being_find_name_struct bfns;
    bfns.first_gender = first_gender;
    bfns.family = family;
    bfns.local = 0L;
    loop_no_thread( group, 0L, being_find_name_loop, &bfns );
    return bfns.local;
}

/** returns the total positive and negative affect within memory */
n_uint being_affect( simulated_being *local, n_byte is_positive )
{
    n_uint affect = 0;
#ifdef EPISODIC_ON
    n_uint i;
    simulated_iepisodic *local_episodic = being_episodic( local );
    if ( !local_episodic )
    {
        return affect;
    }

    for ( i = 0; i < EPISODIC_SIZE; i++ )
    {
        if ( is_positive != 0 )
        {
            if ( local_episodic[i].affect > EPISODIC_AFFECT_ZERO )
            {
                affect += ( n_uint )( local_episodic[i].affect ) - EPISODIC_AFFECT_ZERO;
            }
        }
        else
        {
            if ( local_episodic[i].affect < EPISODIC_AFFECT_ZERO )
            {
                affect += EPISODIC_AFFECT_ZERO - ( n_uint )( local_episodic[i].affect );
            }
        }
    }
#endif
    return affect;
}

const n_string body_inventory_description[INVENTORY_SIZE] =
{
    "Head", "Teeth", "Back", "Front", "Left hand", "Right hand", "Left foot", "Right foot"
};

n_string being_body_inventory_description( n_int index )
{
    return body_inventory_description[index % INVENTORY_SIZE];
}

const n_string relationship_description[RELATIONSHIPS] =
{
    "Associate", "Self", "Mother", "Father", "Daughter",
    "Son", "Granddaughter", "Grandson", "Sister", "Brother",
    "Maternal Grandmother", "Maternal Grandfather", "Paternal Grandmother", "Paternal Grandson", "Mother",
    "Father", "Daughter", "Son", "Granddaughter", "Grandson",
    "Sister", "Brother", "Maternal Grandmother", "Maternal Grandfather", "Paternal Grandmother",
    "Paternal Grandson"
};

void being_relationship_description( n_int index, n_string description )
{
    n_int position = 0;
    if ( index >= RELATIONSHIPS )
    {
        n_string_block index_string;
        io_number_to_string( index_string, ( n_uint )index );
        io_three_strings( description, "ERROR: relationship out of range ", index_string, "", 1 );
        return;
    }
    io_string_write( description, relationship_description[index], &position );
}

static void being_inventory_string( n_string string, n_int *location, n_int item )
{
    switch ( item )
    {
    case INVENTORY_BRANCH:
        io_string_write( string, "branch", location );
        break;
    case INVENTORY_ROCK:
        io_string_write( string, "rock", location );
        break;
    case INVENTORY_SHELL:
        io_string_write( string, "shell", location );
        break;
    case INVENTORY_TWIG:
        io_string_write( string, "twig", location );
        break;
    case INVENTORY_NUT_CRACKED:
        io_string_write( string, "cracked nut", location );
        break;
    case INVENTORY_GRASS:
        io_string_write( string, "piece of grass", location );
        break;
    case INVENTORY_SCRAPER:
        io_string_write( string, "scraper", location );
        break;
    case INVENTORY_SPEAR:
        io_string_write( string, "spear", location );
        break;
    case INVENTORY_FISH:
        io_string_write( string, "fish", location );
        break;
    case INVENTORY_BIRD_EGGS:
        io_string_write( string, "bird eggs", location );
        break;
    case INVENTORY_LIZARD_EGGS:
        io_string_write( string, "lizard eggs", location );
        break;
    case INVENTORY_CHILD:
    case INVENTORY_WOUND:
    case INVENTORY_GROOMED:
    default:
        io_string_write( string, "thing being carried", location );
        break;
    }
}

static void being_social_event_string( n_string string, n_int *location, n_int event_type, n_string name_str )
{
    switch ( event_type )
    {
    case EVENT_MATE:
        io_string_write( string, "Mated with ", location );
        break;
    case EVENT_SEEK_MATE:
        io_string_write( string, "Searched for ", location );
        break;
    /*case EVENT_GROOM:
         io_string_write(string,"Groomed ",location);
         break; */
    case EVENT_GROOMED:
        io_string_write( string, "Groomed by ", location );
        break;
    case EVENT_CHAT:
        io_string_write( string, "Chatted with ", location );
        break;
    case EVENT_BIRTH:
        io_string_write( string, "Gave birth to ", location );
        break;
    case EVENT_HURLED:
        io_string_write( string, "Hurled a rock at ", location );
        break;
    case EVENT_HURLED_BY:
        io_string_write( string, "Hit by a rock hurled by ", location );
        break;

    case EVENT_HIT:
        io_string_write( string, "Hit ", location );
        break;
    case EVENT_HIT_BY:
        io_string_write( string, "Hit by ", location );
        break;
    case EVENT_CARRIED:
        io_string_write( string, "Carried ", location );
        break;
    case EVENT_CARRIED_BY:
        io_string_write( string, "Carried by ", location );
        break;
    case EVENT_SUCKLED:
        io_string_write( string, "Suckled ", location );
        break;
    case EVENT_SUCKLED_BY:
        io_string_write( string, "Suckled by ", location );
        break;
    case EVENT_WHACKED:
        io_string_write( string, "Whacked ", location );
        break;
    case EVENT_WHACKED_BY:
        io_string_write( string, "Whacked by ", location );
        break;
    case EVENT_HUGGED:
        io_string_write( string, "Hugged ", location );
        break;
    case EVENT_HUGGED_BY:
        io_string_write( string, "Hugged by ", location );
        break;
    case EVENT_PRODDED:
        io_string_write( string, "Prodded ", location );
        break;
    case EVENT_PRODDED_BY:
        io_string_write( string, "Prodded by ", location );
        break;
    case EVENT_GIVEN:
        io_string_write( string, "Given ", location );
        break;
    case EVENT_GIVEN_BY:
        io_string_write( string, "Given by ", location );
        break;
    case EVENT_POINT:
        io_string_write( string, "Pointed to ", location );
        break;
    case EVENT_POINTED:
        io_string_write( string, "Pointed to by ", location );
        break;
    case EVENT_SMILED:
        io_string_write( string, "Smiled at ", location );
        break;
    case EVENT_SMILED_BY:
        io_string_write( string, "Smiled at by ", location );
        break;
    case EVENT_TICKLED:
        io_string_write( string, "Tickled ", location );
        break;
    case EVENT_TICKLED_BY:
        io_string_write( string, "Tickled by ", location );
        break;
    case EVENT_GLOWERED:
        io_string_write( string, "Glowered at ", location );
        break;
    case EVENT_GLOWERED_BY:
        io_string_write( string, "Glowered at by ", location );
        break;
    case EVENT_PATTED:
        io_string_write( string, "Patted ", location );
        break;
    case EVENT_PATTED_BY:
        io_string_write( string, "Patted by ", location );
        break;
    default:
    {
        n_string_block  number_str;
        io_number_to_string( number_str, ( n_uint )event_type );

        io_string_write( string, "Erroneous action (", location );
        io_string_write( string, number_str, location );
        io_string_write( string, ") with ", location );
        break;
    }
    }
    io_string_write( string, "*", location );
    io_string_write( string, name_str, location );
    io_string_write( string, "*", location );
}

void being_remains_init( simulated_remains *remains )
{
    remains->count = 0;
    remains->location = 0;
}

static void being_remains( simulated_group *group, simulated_being *dead )
{
    simulated_remains *remains  = &( group->remains );
    n_byte2         location = remains->location;

    remains->bodies[location].location[0] = dead->delta.location[0];
    remains->bodies[location].location[1] = dead->delta.location[1];
    remains->location = ( remains->location + 1 ) % NUMBER_OF_BODIES;

    if ( remains->count <= NUMBER_OF_BODIES )
    {
        remains->count++;
    }
}

n_int episode_description( simulated_being *local_being,
                           n_int index,
                           n_string description )
{
    n_string_block str = {0};
    n_int string_index = 0;
    n_int social = 0;
#ifdef EPISODIC_ON
    n_string_block str2, name_str;
    simulated_iepisodic *local_episodic;
    n_uint days_elapsed, time_elapsed;

    local_episodic = being_episodic( local_being );

    if ( local_episodic == 0L )
    {
        return SHOW_ERROR( "No episodic description" );
    }

    if ( ( local_episodic[index].event > 0 ) &&
            being_name_comparison( local_being, local_episodic[index].first_name[0], local_episodic[index].family_name[0] ) )
    {
        being_name_byte2( local_episodic[index].first_name[BEING_MET], local_episodic[index].family_name[BEING_MET], name_str );

        if ( local_episodic[index].event & ( EVENT_INTENTION ) )
        {
            io_string_write( str, "Intends ", &string_index );
        }

        switch ( local_episodic[index].event & ( EVENT_INTENTION - 1 ) )
        {
        case EVENT_EAT:
        {
            io_string_write( str, "Was eating ", &string_index );
            switch ( local_episodic[index].food )
            {
            case FOOD_VEGETABLE:
            {
                io_string_write( str, "vegetation", &string_index );
                break;
            }
            case FOOD_FRUIT:
            {
                io_string_write( str, "fruit", &string_index );
                break;
            }
            case FOOD_SHELLFISH:
            {
                io_string_write( str, "shellfish", &string_index );
                break;
            }
            case FOOD_SEAWEED:
            {
                io_string_write( str, "seaweed", &string_index );
                break;
            }
            case FOOD_BIRD_EGGS:
            {
                io_string_write( str, "bird eggs", &string_index );
                break;
            }
            case FOOD_LIZARD_EGGS:
            {
                io_string_write( str, "lizard eggs", &string_index );
                break;
            }
            }
            break;
        }
        case EVENT_SWIM:
        {
            io_string_write( str, "Went swimming", &string_index );
            break;
        }
        case EVENT_GROOM: // this appears to be a duplicate
        {
            io_string_write( str, "Groomed *", &string_index );
            io_string_write( str, name_str, &string_index );
            io_string_write( str, "*'s ", &string_index );
            io_string_write( str, being_body_inventory_description( local_episodic[index].arg ), &string_index );

            social = 1;
            break;
        }
        case EVENT_SHOUT:
        {
            io_string_write( str, "Shouted ", &string_index );
            break;
        }
        case EVENT_FISH:
        {
            io_string_write( str, "Caught a fish ", &string_index );
            break;
        }
        case EVENT_CHEW:
        {
            io_string_write( str, "Chewing ", &string_index );
            if ( local_episodic[index].arg & INVENTORY_GRASS )
            {
                io_string_write( str, "grass ", &string_index );
            }
            else
            {
                if ( local_episodic[index].arg & INVENTORY_TWIG )
                {
                    io_string_write( str, "twig ", &string_index );
                }
                else
                {
                    if ( local_episodic[index].arg & INVENTORY_FISH )
                    {
                        io_string_write( str, "fish ", &string_index );
                    }
                    else
                    {
                        if ( local_episodic[index].arg & INVENTORY_NUT_CRACKED )
                        {
                            io_string_write( str, "a cracked nut ", &string_index );
                        }
                        else
                        {
                            {
                                if ( local_episodic[index].arg & INVENTORY_BIRD_EGGS )
                                {
                                    io_string_write( str, "birds eggs ", &string_index );
                                }
                                else
                                {
                                    if ( local_episodic[index].arg & INVENTORY_LIZARD_EGGS )
                                    {
                                        io_string_write( str, "lizard eggs ", &string_index );
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if ( local_episodic[index].arg & 1 )
            {
                io_string_write( str, "held in right hand ", &string_index );
            }
            else
            {
                io_string_write( str, "held in left hand ", &string_index );
            }
            break;
        }
        case EVENT_DRAG:
            io_string_write( str, "Dragged a ", &string_index );
            being_inventory_string( str, &string_index, local_episodic[index].arg );
            break;
        case EVENT_BRANDISH:
            io_string_write( str, "Waved a ", &string_index );
            being_inventory_string( str, &string_index, local_episodic[index].arg );
            break;
        case EVENT_DROP:
            io_string_write( str, "Dropped a ", &string_index );
            being_inventory_string( str, &string_index, local_episodic[index].arg );
            break;
        case EVENT_PICKUP:
            io_string_write( str, "Picked up a ", &string_index );
            being_inventory_string( str, &string_index, local_episodic[index].arg );
            break;
        default:
            being_social_event_string( str, &string_index, local_episodic[index].event & ( EVENT_INTENTION - 1 ), name_str );
            social = 1;
            break;
        }

        if ( string_index == 0 )
        {
            return SHOW_ERROR( "No string in episodic description" );
        }

        days_elapsed = land_date() - local_episodic[index].space_time.date;
        if ( days_elapsed == 0 )
        {
            time_elapsed = land_time() - local_episodic[index].space_time.time;

            if ( time_elapsed < 60 )
            {
                if ( time_elapsed == 0 )
                {
                    io_string_write( str, " now", &string_index );
                }
                else if ( time_elapsed == 1 )
                {
                    io_string_write( str, " a minute ago", &string_index );
                }
                else if ( time_elapsed < 5 )
                {
                    io_string_write( str, " a few minutes ago", &string_index );
                }
                else
                {
                    n_string_block time_elapsed_string;
                    io_number_to_string( time_elapsed_string, time_elapsed );
                    io_three_strings( str2, " ", time_elapsed_string, " minutes ago", 0 );
                    io_string_write( str, str2, &string_index );
                }
            }
            else
            {
                if ( time_elapsed < 120 )
                {
                    io_string_write( str, " an hour ago", &string_index );
                }
                else
                {
                    n_string_block time_elapsed_string;
                    io_number_to_string( time_elapsed_string, time_elapsed / 60 );
                    io_three_strings( str2, " ", time_elapsed_string, " hours ago", 0 );
                    io_string_write( str, str2, &string_index );
                }
            }
        }
        else
        {
            if ( days_elapsed == 1 )
            {
                io_string_write( str, " yesterday", &string_index );
            }
            else
            {
                n_string_block days_elapsed_string;
                io_number_to_string( days_elapsed_string, days_elapsed );
                io_three_strings( str2, " ", days_elapsed_string, " days ago", 0 );
                io_string_write( str, str2, &string_index );
            }
        }
    }
#endif
    str[string_index] = 0;

    string_index = 0;

    io_string_write( description, str, &string_index );

    return social;
}


/**
 This checks to see if the Simulated Ape is awake
 @param local The simulation pointer
 @return 2 is fully awake, 1 is slightly awake to eat, 0 is asleep
 */
n_byte being_awake( simulated_being *local )
{
    if ( local )
    {
        if ( being_energy_less_than( local, BEING_DEAD + 1 ) )
        {
            return FULLY_ASLEEP;
        }

        /** if it is not night, the being is fully awake */
        if ( IS_NIGHT( land_time() ) == 0 )
        {
            return FULLY_AWAKE;
        }

        /** if it  night the being is... */

        /** ... fully awake to swim */
        {
            n_vect2 location;

            being_space( local, &location );
            spacetime_convert_to_map( &location );

            if ( WATER_TEST( land_location_vect( &location ), land_tide_level() ) )
            {
                return FULLY_AWAKE;
            }
        }
        /** ... slightly awake to eat */

        if ( being_energy_less_than( local, BEING_HUNGRY + 1 ) )
        {
#ifdef DEBUG_LACK_OF_MOVEMENT
            being_register_movement( local, "set slightly awake due to energy" );
#endif
            return SLIGHTLY_AWAKE;
        }

        /** ... slightly awake to slow down */

        if ( being_speed( local ) > 0 )
        {
#ifdef DEBUG_LACK_OF_MOVEMENT
            being_register_movement( local, "set slightly awake due to speed" );
#endif
            return SLIGHTLY_AWAKE;
        }

        /** ... asleep */
    }
    return FULLY_ASLEEP;
}

/*

 Rough sketch on brain compression method

 Hypthesis:

 From a zeroed brain,

 After n OUTPUT_ACTUATOR firings into the brain, and,

 After m brain_cycle occurrences with the states recorded,

 There should be a near identical brain to a standard run brain.

 n and m are independent but an acceptable level needs to be recorded.

 Data set:

 Type (either output actuator or brain cycle)

 For output actuator, record position in brain (n_byte2) and set value (n_byte)

 For brain cycle, record awake or asleep.

 Position in brain is on the 32k boundry, the delimiting could be:

 Position in brain - if 32k-1 then actuator set. If 64k-1, then brain cycle

 Set value is set value if actuator set, 0 is asleep, 1 is awake if brain cycle

 */


#ifdef BRAINCODE_ON
#ifdef BRAIN_ON

static void being_brain_probe( simulated_being *local )
{
    n_byte *local_brain = being_brain( local );
    n_int    i = 0;
    n_int    count[NUMBER_BRAINPROBE_TYPES] = {0};


    if ( local_brain == 0L )
    {
        return;
    }

    while ( i < BRAINCODE_PROBES )
    {
        count[local->braindata.brainprobe[i++].type]++;
    }

    /** check to ensure that there are a minimum number of sensors and actuators */
    if ( count[INPUT_SENSOR] < ( BRAINCODE_PROBES >> 2 ) )
    {
        local->braindata.brainprobe[0].type = INPUT_SENSOR;
    }
    else if ( count[OUTPUT_ACTUATOR] < ( BRAINCODE_PROBES >> 2 ) )
    {
        local->braindata.brainprobe[0].type = OUTPUT_ACTUATOR;
    }

    /** update each probe */
    i = 0;

    while ( i < BRAINCODE_PROBES )
    {
        local->braindata.brainprobe[i].state++;
        if ( local->braindata.brainprobe[i].state >= local->braindata.brainprobe[i].frequency )
        {
            n_byte *local_braincode = being_braincode_internal( local );
            /** position within the brain */
            n_int position_in_brain = ( ( local->braindata.brainprobe[i].position * ( SINGLE_BRAIN >> 8 ) ) ) & ( SINGLE_BRAIN - 1 );
            n_int position_in_braincode = local->braindata.brainprobe[i].address % BRAINCODE_SIZE;

            local->braindata.brainprobe[i].state = 0;

            if ( local->braindata.brainprobe[i].type == INPUT_SENSOR )
            {
                /** address within braincode */
                n_int set_value = ( local_brain[position_in_brain] + local->braindata.brainprobe[i].offset ) & 255;
                /** read from brain */
                local_braincode[position_in_braincode] = ( n_byte )set_value;
            }
            else
            {
                /** address within braincode */
                n_int set_value = ( local_braincode[position_in_braincode] + local->braindata.brainprobe[i].offset ) & 255;
                /** write to brain */
                local_brain[position_in_brain] = ( n_byte )set_value;
            }
        }
        i++;
    }
}
#endif
#endif

/** stuff still goes on during sleep */
void being_cycle_universal( simulated_being *local )
{
    n_int immune_energy_used = immune_response( &local->immune_system, being_honor_immune( local ), being_energy( local ) );

    NA_ASSERT( ( immune_energy_used >= 0 ), "Positive energy added back from immune response" );

    if ( immune_energy_used > 0 )
    {
        being_energy_delta( local, 0 - immune_energy_used );
    }

#ifdef BRAINCODE_ON
#ifdef BRAIN_ON
    /** may need to add external probe linking too */
    being_brain_probe( local );
#endif
#endif

    if ( ( local->delta.awake == 0 ) && local )
    {
        being_set_state( local, BEING_STATE_ASLEEP );
        being_reset_drive( local, DRIVE_FATIGUE );
    }
}

/* For a new child this populates the social graph with family relationships */
static void being_create_family_links( simulated_being *mother,
                                       simulated_being *child,
                                       simulated_group *group )
{
    n_int i, j, index;
    simulated_being *parent[6] = {0L};
    simulated_being *sibling;
    n_byte parent_relation[6];
    n_byte child_relation[6];
    n_byte sibling_relation;
    simulated_isocial *parent_social_graph;

    if ( mother == 0L )
    {
        return;
    }

    /** First tow entries in the array are parents.
     Subsequent entries are grandparents */
    parent[0] = mother;
    parent[1] = being_find_name( group, mother->changes.father_name[0], mother->changes.father_name[1] );

    parent_relation[0] = RELATIONSHIP_DAUGHTER;
    parent_relation[1] = RELATIONSHIP_DAUGHTER;
    parent_relation[2] = RELATIONSHIP_GRANDDAUGHTER;
    parent_relation[3] = RELATIONSHIP_GRANDDAUGHTER;
    parent_relation[4] = RELATIONSHIP_GRANDDAUGHTER;
    parent_relation[5] = RELATIONSHIP_GRANDDAUGHTER;

    child_relation[0] = RELATIONSHIP_MOTHER;
    child_relation[1] = RELATIONSHIP_MOTHER;
    child_relation[2] = RELATIONSHIP_MATERNAL_GRANDMOTHER;
    child_relation[3] = RELATIONSHIP_MATERNAL_GRANDMOTHER;
    child_relation[4] = RELATIONSHIP_PATERNAL_GRANDMOTHER;
    child_relation[5] = RELATIONSHIP_PATERNAL_GRANDMOTHER;

    /** grandparents */
    for ( j = 0; j < 2; j++ ) /** maternal or paternal */
    {
        if ( parent[j] )
        {
            /** social graph for mother or father */
            parent_social_graph = being_social( parent[j] );
            if ( parent_social_graph )
            {
                for ( i = 0; i < 2; i++ ) /** grandmother or grandfather */
                {
                    parent[2 + ( j * 2 ) + i] = 0L;
                    /** graph index for parent's mother or father */
                    index = social_get_relationship( parent[j], ( n_byte )( RELATIONSHIP_MOTHER + i ) );
                    if ( ( index > -1 ) && ( parent_social_graph != 0L ) )
                    {
                        /** store the grandparent reference if still living */
                        parent[2 + ( j * 2 ) + i] =
                            being_find_name( group,
                                             parent_social_graph[index].first_name[BEING_MET],
                                             parent_social_graph[index].family_name[BEING_MET] );
                    }
                }
            }
        }
    }

    /** brothers and sisters */
    sibling_relation = RELATIONSHIP_BROTHER;
    if ( FIND_SEX( GET_I( child ) ) == SEX_FEMALE )
    {
        sibling_relation = RELATIONSHIP_SISTER;
    }

    for ( j = 0; j < 2; j++ )
    {
        /** social graph for mother or father */
        if ( parent[j] )
        {
            parent_social_graph = being_social( parent[j] );
            if ( parent_social_graph )
            {
                for ( i = 1; i < SOCIAL_SIZE_BEINGS; i++ )
                {
                    if ( ( parent_social_graph[i].relationship == RELATIONSHIP_SON ) ||
                            ( parent_social_graph[i].relationship == RELATIONSHIP_DAUGHTER ) )
                    {
                        sibling = being_find_name( group, parent_social_graph[i].first_name[BEING_MET], parent_social_graph[i].family_name[BEING_MET] );
                        if ( sibling != 0L )
                        {
                            if ( parent_social_graph[i].relationship == RELATIONSHIP_SON )
                            {
                                social_set_relationship( group, child, RELATIONSHIP_BROTHER, sibling );
                            }
                            else
                            {
                                social_set_relationship( group, child, RELATIONSHIP_SISTER, sibling );
                            }
                            social_set_relationship( group, sibling, sibling_relation, child );
                        }
                    }
                }
            }
        }
    }

    /** set relationships */
    for ( i = 0; i < 6; i++ )
    {
        if ( parent[i] == 0L )
        {
            continue;
        }

        /** create the parent/child social graph relation */
        if ( FIND_SEX( GET_I( child ) ) == SEX_FEMALE )
        {
            social_set_relationship( group, parent[i], parent_relation[i], child );
        }
        else
        {
            social_set_relationship( group, parent[i], parent_relation[i] + 1, child );
        }

        if ( i % 2 == 0 )
        {
            social_set_relationship( group, child, child_relation[i], parent[i] );
        }
        else
        {
            social_set_relationship( group, child, child_relation[i] + 1, parent[i] );
        }
    }

}

void being_set_goal_mate( simulated_being *local, n_byte2 first_name, n_byte2 family_name )
{
    local->delta.goal[0] = GOAL_MATE;
    local->delta.goal[1] = first_name;
    local->delta.goal[2] = family_name;
    local->delta.goal[3] = GOAL_TIMEOUT;
}

void being_set_goal_none( simulated_being *local )
{
    local->delta.goal[0] = GOAL_NONE;
}

void being_set_goal_location( simulated_being *local, n_byte2 lx, n_byte2 ly )
{
    local->delta.goal[0] = GOAL_LOCATION;
    local->delta.goal[1] = lx;
    local->delta.goal[2] = ly;
    local->delta.goal[3] = GOAL_TIMEOUT;
}

n_int being_check_goal( simulated_being *local, goal_types goal )
{
    return ( local->delta.goal[0] == goal );
}

void being_goal_cycle( simulated_being *local )
{
    /** decrement the goal counter */
    if ( local->delta.goal[3] > 0 )
    {
        local->delta.goal[3]--;
    }
    else
    {
        /** timed out */
        being_set_goal_none( local );
    }
}

static void being_follow_loop1( simulated_group *group, simulated_being *other, void *data )
{
    being_nearest *nearest = ( being_nearest * )data;
    n_vect2        difference_vector;

    /** is this the same as the name of the being to which we are paying attention? */
    if ( ( FIND_SEX( GET_I( other ) ) != FIND_SEX( GET_I( nearest->local ) ) ) &&
            being_name_comparison( other, nearest->local->delta.goal[1], nearest->local->delta.goal[2] ) )
    {
        n_vect2 other_location;
        being_delta( nearest->local, other, &difference_vector );
        being_space( other, &other_location );

        if ( being_line_of_sight( nearest->local, &other_location ) ) /* incorrect use of los */
        {
            n_uint compare_distance = ( n_uint )vect2_dot( &difference_vector, &difference_vector, 1, 1 );
            if ( compare_distance < nearest->opposite_sex_distance )
            {
                nearest->opposite_sex = other;
                nearest->opposite_sex_distance = compare_distance;
            }
        }
    }
}

static void being_follow_loop2( simulated_group *group, simulated_being *other, void *data )
{
    being_nearest *nearest = ( being_nearest * )data;
    n_vect2        difference_vector;

    /** is this the same as the name of the being to which we are paying attention? */
    if ( being_name_comparison( other,
                                nearest->local_social->first_name[BEING_MET],
                                nearest->local_social->family_name[BEING_MET] ) )
    {
        /** Is this being within sight? */

        n_vect2 other_location;
        being_delta( nearest->local, other, &difference_vector );
        being_space( other, &other_location );
        if ( being_line_of_sight( nearest->local, &other_location ) )
        {
            n_uint compare_distance = ( n_uint )vect2_dot( &difference_vector, &difference_vector, 1, 1 );
            if ( FIND_SEX( GET_I( other ) ) != FIND_SEX( GET_I( nearest->local ) ) )
            {
                if ( compare_distance < nearest->opposite_sex_distance )
                {
                    nearest->opposite_sex = other;
                    nearest->opposite_sex_distance = compare_distance;
                }
            }
            else
            {
                if ( compare_distance < nearest->same_sex_distance )
                {
                    nearest->same_sex = other;
                    nearest->same_sex_distance = compare_distance;
                }
            }
        }
    }

}

/**
 * Follow a being to which we are paying attention
 * @param group Pointer to the simulated_group
 * @param local The current being
 * @param nearest The nearest being structure
 */
static void being_follow( simulated_group *group,
                          simulated_being *local,
                          being_nearest *nearest )
{
    /* There is a bug here where same_sex and opposite_sex appears to never be set */
    simulated_isocial *local_social_graph;
    n_int          social_graph_index;

    nearest->local = local;
    nearest->opposite_sex_distance = 0xffffffff;
    nearest->same_sex_distance = 0xffffffff;
    nearest->opposite_sex = 0L;
    nearest->same_sex = 0L;

    /** is a mate in view? */
    if ( being_check_goal( local, GOAL_MATE ) )
    {
        loop_no_thread( group, local, being_follow_loop1, nearest );
        if ( nearest->opposite_sex != 0L )
        {
            return;
        }
    }

    local_social_graph = being_social( local );
    if ( local_social_graph == 0L )
    {
        return;
    }

    /** which entry in the social graph are we paying attention to? */
    social_graph_index = being_attention( local, ATTENTION_ACTOR );

    nearest->local_social = &local_social_graph[social_graph_index];

    /** Does this entry correspond to another being? */
    if ( ( social_graph_index > 0 ) &&
            ( local_social_graph[social_graph_index].entity_type == ENTITY_BEING ) &&
            ( !SOCIAL_GRAPH_ENTRY_EMPTY( local_social_graph, social_graph_index ) ) )
    {
        loop_no_thread( group, local, being_follow_loop2, nearest );
    }
}

void being_listen_loop_no_sim( simulated_being *other, void *data )
{
    being_listen_struct *bls = ( being_listen_struct * )data;
    n_vect2       difference_vector;
    n_uint        compare_distance;

    being_delta( bls->local, other, &difference_vector );
    compare_distance = ( n_uint )vect2_dot( &difference_vector, &difference_vector, 1, 1 );
    /** listen for the nearest shout out */
    if ( ( being_state( other )&BEING_STATE_SHOUTING ) &&
            ( compare_distance < SHOUT_RANGE ) &&
            ( other->changes.shout[SHOUT_VOLUME] > bls->max_shout_volume ) )
    {
        bls->max_shout_volume = other->changes.shout[SHOUT_VOLUME];
        bls->local->changes.shout[SHOUT_HEARD] = other->changes.shout[SHOUT_CONTENT];
        bls->local->changes.shout[SHOUT_FAMILY0] = being_family_first_name( other );
        bls->local->changes.shout[SHOUT_FAMILY1] = being_family_second_name( other );
    }
}

/**
 * Listen for shouts
 * @param group Pointer to the simulated_group
 * @param local_being Array index of the current being
 * @param data Unused here
 */
void being_listen( simulated_group *group, simulated_being *local_being, void *data )
{
    being_listen_struct bls;

    if ( local_being->delta.awake == 0 )
    {
        return;
    }

    bls.max_shout_volume = 127;
    bls.local = local_being;
    /** clear shout values */
    if ( local_being->changes.shout[SHOUT_CTR] > 0 )
    {
        local_being->changes.shout[SHOUT_CTR]--;
    }
    loop_being_no_sim( group->beings, group->num, being_listen_loop_no_sim, &bls );
}

static void being_closest_loop( simulated_group *group, simulated_being *test_being, void *data )
{
    being_nearest *nearest = ( being_nearest * )data;
    n_vect2       difference_vector;
    n_uint        compare_distance;
    n_vect2       location_test;
    being_delta( nearest->local, test_being, &difference_vector );
    compare_distance = ( n_uint )vect2_dot( &difference_vector, &difference_vector, 1, 1 );

    if ( FIND_SEX( GET_I( test_being ) ) != FIND_SEX( GET_I( nearest->local ) ) )
    {
        if ( compare_distance < nearest->opposite_sex_distance )
        {
            being_space( test_being, &location_test );
            /* 'function' : conversion from 'n_int' to 'n_byte2', possible loss of data x 2 */
            if ( being_line_of_sight( nearest->local, &location_test ) )
            {
                nearest->opposite_sex_distance = compare_distance;
                nearest->opposite_sex = test_being;
            }
        }
    }
    else
    {
        if ( compare_distance < nearest->same_sex_distance )
        {
            being_space( test_being, &location_test );

            if ( being_line_of_sight( nearest->local, &location_test ) )
            {
                nearest->same_sex_distance = compare_distance;
                nearest->same_sex = test_being;
            }
        }
    }
}

/**
 * Returns the closest beings
 * @param group Pointer to the simulated_group
 * @param local Array index of the current being
 */
static void being_closest( simulated_group *group,
                           simulated_being *local,
                           being_nearest *nearest )
{
    nearest->local = local;
    nearest->opposite_sex_distance = 0xffffffff;
    nearest->same_sex_distance = 0xffffffff;
    nearest->opposite_sex = 0L;
    nearest->same_sex = 0L;
    loop_no_thread( group, local, being_closest_loop, nearest );
}

/**
 * One being interacts with another
 * @param group Pointer to the simulated_group
 * @param local Array index of the being
 * @param other_being Array index of the other being
 * @param other_being_distance Distance to the other being
 * @param awake Whether the being is awake
 * @param state The state of the being
 * @param speed The speed of the being
 * @param opposite_sex Non zero if the other being is the opposite sex
 */
static void being_interact( simulated_group *group,
                            simulated_being *local,
                            simulated_being     *other_being,
                            n_uint   other_being_distance,
                            n_int   *awake,
                            n_byte2 *state,
                            n_int   *speed,
                            n_byte   opposite_sex )
{
    if ( other_being != 0L )
    {
        n_int         today_days   = land_date();
        n_int         birth_days   = being_dob( local );
        n_int         local_is_female = FIND_SEX( GET_I( local ) );

        n_vect2 delta_vector;

        /** social networking */
        n_byte2 familiarity = 0;
        n_int   being_index = social_network( group, local, other_being, other_being_distance );

        being_delta( local, other_being, &delta_vector );

        if ( being_index > -1 )
        {
            simulated_isocial *local_social_graph = being_social( local );
            if ( local_social_graph )
            {
                familiarity = local_social_graph[being_index].familiarity;
            }
        }

        being_facing_towards( local, &delta_vector );

        if ( ( birth_days + AGE_OF_MATURITY ) < today_days )
        {
            if ( social_groom( group, local, other_being, other_being_distance, *awake, familiarity ) )
            {
                *state |= BEING_STATE_GROOMING;

                /* both beings stop */
                *speed = 0;
                being_set_speed( other_being, 0 );
            }
            else
            {
                /* squabbling between adults */
                if ( ( other_being_distance < SQUABBLE_RANGE ) && ( ( being_dob( other_being ) + AGE_OF_MATURITY ) < today_days ) )
                {
                    n_byte2 squabble_val;
                    being_set_speed( local, ( n_byte )*speed );
#ifdef DEBUG_LACK_OF_MOVEMENT
                    if ( *speed == 0 )
                    {
                        being_register_movement( local, "speed is zero" );
                    }
#endif
                    squabble_val = social_squabble( local, other_being, other_being_distance, local_is_female, group );
                    if ( squabble_val != 0 )
                    {
                        *state |= squabble_val;
                        *speed = being_speed( local );
                    }
                }
            }

        }
        if ( ( other_being_distance < SOCIAL_RANGE ) && ( being_index > -1 ) )
        {
            /* attraction and mating */
            if ( opposite_sex != 0 )
            {
                *state |= social_mate( local, other_being, being_index, other_being_distance, group );
            }

            /* chat */
            *state |= social_chat( local, other_being, being_index, group );
        }
    }
}

typedef struct
{
    n_int counter;
    n_int return_value;
    simulated_being *being;
} being_index_loop_struct;

static void being_index_loop( simulated_group *group, simulated_being *local_being, void *data )
{
    being_index_loop_struct *bils = ( being_index_loop_struct * ) data;

    if ( bils->return_value != -1 )
    {
        return;
    }

    if ( local_being == bils->being )
    {
        bils->return_value = bils->counter;
    }
    else
    {
        bils->counter++;
    }
}

n_int being_index( simulated_group *group, simulated_being *local )
{
    being_index_loop_struct value;

    value.return_value = -1;
    value.being = local;
    value.counter = 0;

    loop_no_thread( group, 0L, being_index_loop, &value );
    return value.return_value;
}

void being_territory_index( simulated_being *local )
{
    n_uint territory_index =
        APESPACE_TO_TERRITORY( being_location_y( local ) ) * TERRITORY_DIMENSION +
        APESPACE_TO_TERRITORY( being_location_x( local ) );

    if ( local->events.territory[territory_index].familiarity < 65534 )
    {
        local->events.territory[territory_index].familiarity++;
    }
    else
    {
        /** rescale familiarity values */
        for ( territory_index = 0; territory_index < TERRITORY_AREA; territory_index++ )
        {
            local->events.territory[territory_index].familiarity >>= 2;
        }
    }
}

static n_int being_temporary_speed( simulated_being *local, n_int *test_land, n_int *az )

{
    n_vect2 location_vector;
    n_vect2 facing_vector;
    n_vect2 slope_vector;
    n_vect2 looking_vector;

    being_space( local, &location_vector );

    being_facing_vector( local, &facing_vector, 4 );
    land_vect2( &slope_vector, az, &location_vector );
    vect2_add( &looking_vector, &location_vector, &facing_vector );
    spacetime_convert_to_map( &looking_vector );

    *test_land = ( WATER_TEST( land_location_vect( &looking_vector ), land_tide_level() ) != 0 );

    {
        n_int delta_z = vect2_dot( &slope_vector, &facing_vector, 1, 24 );
        n_int tmp_speed = ( ( delta_z + 280 ) >> 4 );
#ifdef DEBUG_LACK_OF_MOVEMENT
        if ( tmp_speed == 0 )
        {
            being_register_movement( local, "temp speed zero in setting temp speed" );
        }
#endif
        return tmp_speed;
    }
}

static n_int being_conception_child_mass( simulated_group *group, simulated_being *local, n_byte2 loc_state )
{
    n_int         birth_days = being_dob( local );
    n_int         today_days = land_date();
    n_int         child_mass = 0;
    n_int         carrying_child = 0;
    n_genetics   *genetics = being_genetics( local );

    /** a certain time after giving birth females become receptive again */
    if ( ( being_pregnant( local ) != 0 ) &&
            ( ( being_pregnant( local ) + GESTATION_DAYS + CONCEPTION_INHIBITION_DAYS ) < today_days ) )
    {
        /** zero value indicates ready to conceive */
        local->changes.date_of_conception = 0;
    }

    if ( ( loc_state & ( BEING_STATE_AWAKE | BEING_STATE_SWIMMING ) ) == BEING_STATE_AWAKE )
    {
        n_int conception_days = being_pregnant( local ) ;
        if ( conception_days > 0 )
        {
            n_int gestation_days = conception_days + GESTATION_DAYS;
            if ( today_days > gestation_days )
            {
                /** A mother could have multiple children, so only find the youngest */
                simulated_being *being_child = being_find_child( group, genetics, CARRYING_DAYS );

                /** Birth */
                if ( being_child == 0L )
                {
                    if ( ( group->num + 1 ) < group->max )
                    {
                        being_child = &( group->beings[group->num] );

                        if ( being_init( group->beings, ( n_int )group->num, being_child, local, 0L ) == 0 )
                        {
#ifdef EPISODIC_ON
                            episodic_close( local, being_child, EVENT_BIRTH, AFFECT_BIRTH, 0 );
#endif
                            being_create_family_links( local, being_child, group );
                            if ( group->ext_birth != 0 )
                            {
                                group->ext_birth( being_child, local, group );
                            }
                            group->num++;
                        }
                    }
                }
                else
                {
                    /** mother carries the child */
                    n_int carrying_days = conception_days + GESTATION_DAYS + CARRYING_DAYS;
                    if ( today_days < carrying_days )
                    {
                        if ( !( ( local->changes.inventory[BODY_FRONT] & INVENTORY_CHILD ) ||
                                ( local->changes.inventory[BODY_BACK] & INVENTORY_CHILD ) ) )
                        {
                            local->changes.inventory[BODY_BACK] |= INVENTORY_CHILD;
                            being_set_attention( local, ATTENTION_BODY, BODY_BACK );
                        }
                        carrying_child = 1;

                        being_set_location( being_child, being_location( local ) );

                        child_mass = GET_M( being_child );
#ifdef EPISODIC_ON
                        episodic_close( local, being_child, EVENT_CARRIED, AFFECT_CARRYING, 0 );
                        episodic_close( being_child, local, EVENT_CARRIED_BY, AFFECT_CARRIED, 0 );
#endif
                    }
                }
            }
            else
            {
                /** Compute the mass of the unborn child.
                 This will be added to the mass of the mother */
                child_mass = ( today_days - conception_days ) * BIRTH_MASS / GESTATION_DAYS;
            }
        }

        /** child follows the mother */
        if ( ( birth_days + WEANING_DAYS ) > today_days )
        {
            simulated_being *mother = being_find_closest( group, local, 1, 1 );
            if ( mother != 0L )
            {
                /** orient towards the mother */
                n_vect2    mother_vector;

                being_delta( mother, local, &mother_vector );

                being_facing_towards( local, &mother_vector );

                /** suckling */
                if ( ( loc_state & BEING_STATE_HUNGRY ) != 0 )
                {
                    n_int distance = vect2_dot( &mother_vector, &mother_vector, 1, 1 );
                    if ( distance < SUCKLING_MAX_SEPARATION )
                    {
                        /** child moves from back to front */
                        if ( mother->changes.inventory[BODY_BACK] & INVENTORY_CHILD )
                        {
                            mother->changes.inventory[BODY_BACK] -= INVENTORY_CHILD;
                        }
                        mother->changes.inventory[BODY_FRONT] |= INVENTORY_CHILD;
                        being_set_attention( mother, ATTENTION_BODY, BODY_FRONT );
                        /** sucking causes loss of grooming */
                        if ( mother->changes.inventory[BODY_FRONT] & INVENTORY_GROOMED )
                        {
                            mother->changes.inventory[BODY_FRONT] -= INVENTORY_GROOMED;
                        }
                        /** hungry mothers stop producing milk */
                        if ( being_energy_less_than( mother, BEING_HUNGRY ) == 0 )
                        {
                            /** mother loses energy */
                            being_energy_delta( mother, 0 - SUCKLING_ENERGY );
                            /** child gains energy */

                            being_energy_delta( local, SUCKLING_ENERGY );

                            /** set child state to suckling */
                            loc_state |= BEING_STATE_SUCKLING;
                            /** child acquires immunity from mother */
                            immune_seed( &mother->immune_system, &local->immune_system );
#ifdef EPISODIC_ON
                            episodic_close( mother, local, EVENT_SUCKLED, AFFECT_SUCKLING, 0 );
                            episodic_close( local, mother, EVENT_SUCKLED_BY, AFFECT_SUCKLING, 0 );
#endif
                        }
                    }
                }
            }
        }
    }

    /** no longer carrying the child */
    if ( ( carrying_child == 0 ) && ( FIND_SEX( GET_I( local ) ) == SEX_FEMALE ) )
    {
        if ( local->changes.inventory[BODY_FRONT] & INVENTORY_CHILD )
        {
            local->changes.inventory[BODY_FRONT] -= INVENTORY_CHILD;
        }
        if ( local->changes.inventory[BODY_BACK] & INVENTORY_CHILD )
        {
            local->changes.inventory[BODY_BACK] -= INVENTORY_CHILD;
        }
    }
    return child_mass;
}

static n_byte2 being_state_find( simulated_being *local, n_int az, n_int loc_s )
{
    n_byte2        loc_state  = BEING_STATE_ASLEEP;
    n_int         awake = local->delta.awake;

#ifdef LAND_ON
    /* TODO why not test_land here? */
    if ( WATER_TEST( az, land_tide_level() ) != 0 )
    {
        loc_state |= BEING_STATE_SWIMMING;
    }
#endif

    if ( awake != FULLY_ASLEEP )
    {
        loc_state |= BEING_STATE_AWAKE;
    }

    if ( loc_s != 0 )
    {
        loc_state |= BEING_STATE_MOVING;
    }

    {
        n_int   hungry = being_energy_less_than( local, BEING_HUNGRY );

        if ( ( loc_state & ( BEING_STATE_AWAKE | BEING_STATE_SWIMMING | BEING_STATE_MOVING ) ) == BEING_STATE_AWAKE )
        {
            hungry = being_energy_less_than( local, BEING_FULL );
#ifdef DEBUG_LACK_OF_MOVEMENT
            being_register_movement( local, "is eating path" );
#endif
        }

        if ( hungry != 0 )
        {
#ifdef DEBUG_LACK_OF_MOVEMENT
            being_register_movement( local, "is hungry" );
#endif
            loc_state |= BEING_STATE_HUNGRY;
        }
    }
    return loc_state;
}

static void being_not_swimming( simulated_group *group, simulated_being *local, n_int *tmp_speed, being_nearest *nearest, n_int *loc_s, n_byte2 *loc_state )
{
    n_genetics   *genetics = being_genetics( local );

    /** adjust speed using genetics */
    *tmp_speed = ( *tmp_speed * ( GENE_SPEED( genetics ) + 8 ) ) >> 3;

    /** is the being to which we are paying attention within view? */
    being_follow( group, local, nearest );
    if ( nearest->opposite_sex == 0L )
    {
        /** Find the closest beings */
        being_closest( group, local, nearest );
    }

    /* TODO: SOCIAL_THRESHOLD should not be a macro, it should be a function returning n_int */
    if ( being_drive( local, DRIVE_SOCIAL ) > SOCIAL_THRESHOLD( local ) )
    {
        n_int  awake = local->delta.awake;

        being_interact( group,
                        local,
                        nearest->same_sex, nearest->same_sex_distance,
                        &awake, loc_state,
                        loc_s, 0 );

        being_interact( group,
                        local,
                        nearest->opposite_sex, nearest->opposite_sex_distance,
                        &awake, loc_state,
                        loc_s, 1 );
    }
}

static void being_swimming( simulated_group *group, simulated_being *local, n_int *tmp_speed )
{
    n_uint          loop;
    n_genetics   *genetics = being_genetics( local );

    being_turn_away_from_water( local );

    /** horizontally oriented posture */
    being_set_posture( local, 0 );

    /** When swimming drop everything except what's on your head or back.
     Note that the groomed flag is also cleared */

    for ( loop = 0; loop < INVENTORY_SIZE; loop++ )
    {
        if ( !( ( loop == BODY_HEAD ) || ( loop == BODY_BACK ) ) )
        {
            local->changes.inventory[loop] = 0;
        }
    }
    /** swimming proficiency */
    *tmp_speed = ( *tmp_speed * ( GENE_SWIM( genetics ) + 8 ) ) >> 4;

    /* TODO: affect_type should probably be used rather than energy? */
#ifdef EPISODIC_ON
    episodic_self( local, EVENT_SWIM, AFFECT_GROOM, ( n_byte2 )being_energy( local ) );
#endif
    /** bathing removes parasites */
    being_remove_parasites( local, 1 );
}

static void being_mass_calculation( simulated_group *group, simulated_being *local, n_byte2  loc_state )
{
    n_int          loc_h      = being_height( local );
    n_int child_mass = being_conception_child_mass( group, local, loc_state );
    /** amount of body fat in kg */
    n_int fat_mass = GET_BODY_FAT( local );
    if ( fat_mass > BEING_MAX_MASS_FAT_G )
    {
        fat_mass = BEING_MAX_MASS_FAT_G;
    }
    GET_M( local ) = ( n_byte2 )( ( BEING_MAX_MASS_G * loc_h / BEING_MAX_HEIGHT ) + fat_mass + child_mass );
}

void being_genetic_wandering( simulated_being *local, being_nearest *nearest )
{
    n_genetics   *genetics = being_genetics( local );

    if ( being_check_goal( local, GOAL_NONE ) &&
            ( nearest->opposite_sex == 0L ) &&
            ( nearest->same_sex == 0L ) &&
            ( being_random( local ) < 1000 + 3600 * GENE_STAGGER( genetics ) ) )
    {
        n_int     wander = math_spread_byte( being_random( local ) & 7 );
        being_wander( local, wander );
    }
}

void being_calculate_speed( simulated_being *local, n_int tmp_speed, n_byte2 loc_state )
{
    n_int          loc_s      = being_speed( local );

    if ( tmp_speed > 39 )
    {
        tmp_speed = 39;
    }
    if ( tmp_speed < 0 )
    {
        tmp_speed = 0;
    }

    if ( ( local->delta.awake != FULLY_AWAKE ) || ( ( loc_state & ( BEING_STATE_HUNGRY | BEING_STATE_NO_FOOD ) ) == BEING_STATE_HUNGRY ) )
    {
        if ( ( loc_state & BEING_STATE_SWIMMING ) != 0 )
        {
            tmp_speed = ( being_energy( local ) >> 7 );
        }
        else
        {
            if ( ( loc_state & BEING_STATE_NO_FOOD ) != BEING_STATE_NO_FOOD )
            {
                tmp_speed = 0;
#ifdef DEBUG_LACK_OF_MOVEMENT
                being_register_movement( local, "not fully awake and hungry not swimming" );
#endif
            }
        }
    }

    if ( tmp_speed > loc_s )
    {
        loc_s++;
    }
    if ( tmp_speed < loc_s )
    {
        loc_s--;
    }
    if ( tmp_speed < loc_s )
    {
        loc_s--;
    }
    if ( tmp_speed < loc_s )
    {
        loc_s--;
    }

    being_set_speed( local, ( n_byte )loc_s );
}

void being_cycle_awake( simulated_group *group, simulated_being *local )
{
    n_int          loc_s      = being_speed( local );
    n_int          loc_h      = being_height( local );
    n_int         birth_days = being_dob( local );
    n_int         today_days = land_date();

    /** tmp_speed is the optimum speed based on the gradient */
    /** delta_energy is the energy required for movement */
    n_int    az;
    being_nearest nearest;
    n_int   test_land = 1;
    n_int   tmp_speed = being_temporary_speed( local, &test_land, &az );
    n_byte2  loc_state = being_state_find( local, az, loc_s );

    nearest.opposite_sex = 0L;
    nearest.same_sex = 0L;

    /** If it sees water in the distance then turn */
    if ( ( ( loc_state & BEING_STATE_SWIMMING ) != 0 ) || test_land )
    {
        being_swimming( group, local, &tmp_speed );
    }
    else
    {
        being_not_swimming( group, local, &tmp_speed, &nearest, &loc_s, &loc_state );
    }
#ifdef DEBUG_LACK_OF_MOVEMENT
    if ( tmp_speed == 0 )
    {
        being_register_movement( local, "temp speed zero" );
    }
#endif
    if ( ( loc_state & ( BEING_STATE_SWIMMING | BEING_STATE_GROOMING | BEING_STATE_ATTACK | BEING_STATE_SHOWFORCE ) ) == 0 )
    {
        if ( ( loc_state & BEING_STATE_HUNGRY ) == BEING_STATE_HUNGRY )
        {
            if ( loc_s == 0 )
            {
                /** eating when stopped */
                n_byte  food_type;
                n_int   energy = food_eat( being_location_x( local ), being_location_y( local ), az, &food_type, local );

#ifdef DEBUG_LACK_OF_MOVEMENT
                {
                    n_string_block energy_string;
                    sprintf( energy_string, "energy delta is %ld tmp_speed is %ld", energy, tmp_speed );
                    being_register_movement( local, energy_string );
                }
#endif
                if ( energy != 0 )
                {
#ifdef EPISODIC_ON
                    /** remember eating */
                    episodic_food( local, energy, food_type );
#endif

                    being_energy_delta( local, energy );
                    being_reset_drive( local, DRIVE_HUNGER );
                    loc_state |= BEING_STATE_EATING;
                    /** grow */
                    if ( loc_h < BEING_MAX_HEIGHT )
                    {
                        if ( ( birth_days + AGE_OF_MATURITY ) > today_days )
                        {
                            loc_h += ENERGY_TO_GROWTH( local, energy );
                        }
                    }
                }
                else
                {
                    loc_state |= BEING_STATE_NO_FOOD;
#ifdef DEBUG_LACK_OF_MOVEMENT
                    {
                        being_register_movement( local, "no food state set" );
                    }
#endif
                }
            }
        }
        else
        {
            /** orient towards a goal */
            social_goals( local );
            if ( loc_s == 0 )
            {
                loc_s = 10;
            }
        }
    }

    being_set_height( local, loc_h );
    being_set_state( local, loc_state );
    being_calculate_speed( local, tmp_speed, loc_state );
    being_genetic_wandering( local, &nearest );
#ifdef TERRITORY_ON
    being_territory_index( local );
#endif
    being_mass_calculation( group, local, loc_state );
}

void being_tidy_loop_no_sim( simulated_being *local_being, void *data )
{
    n_genetics  *genetics = being_genetics( local_being );
    n_int        local_honor = being_honor( local_being );
    n_int        delta_e = 0;
    n_int        conductance = 5;
    n_int       *max_honor = data;
    if ( local_honor >= 254 )
    {
        max_honor[0] = 1;
    }
    if ( local_being->delta.awake != FULLY_ASLEEP )
    {
        delta_e = being_move_energy( local_being, &conductance );
    }
    else
    {
        being_set_speed( local_being, 0 );
#ifdef DEBUG_LACK_OF_MOVEMENT
        being_register_movement( local_being, "not fully awake" );
#endif
        delta_e += ( 7 ) >> 2;
    }

    if ( delta_e > 0 )
    {
        /** hairy creatures are better insulated */
        delta_e -= ( ( GENE_HAIR( genetics ) * delta_e ) >> conductance );
        if ( delta_e < 1 )
        {
            delta_e = 1;
        }
    }

    being_energy_delta( local_being, 0 - delta_e );

    if ( land_time() == 0 )
    {
        n_int age_in_years = AGE_IN_YEARS( local_being );
        /** this simulates natural death or at least some trauma the ape may or may not be able to recover from */
        if ( age_in_years > 29 )
        {
            if ( being_random( local_being ) < ( age_in_years - 29 ) )
            {
                being_energy_delta( local_being, 0 - BEING_HUNGRY );
            }
        }
    }
}

void  being_recalibrate_honor_loop_no_sim( simulated_being *value )
{
    value->delta.honor = ( n_byte )( ( ( n_int )( value->delta.honor ) * 220 ) / 255 );
}

static n_int being_remove_internal_value = 0;
static n_int being_remove_external_value = 0;

n_int being_remove_internal( void )
{
    return being_remove_internal_value;
}

void being_remove_external_set( n_int value )
{
    being_remove_external_value = value;
}

void being_remove_loop1( simulated_group *group, simulated_being *local_being, void *data )
{
    if ( being_energy_less_than( local_being, BEING_DEAD + 1 ) )
    {
        group->ext_death( local_being, group );
    }
}

void being_remove_loop2( simulated_group *group, simulated_being *local, void *data )
{
    being_remove_loop2_struct *brls = ( being_remove_loop2_struct * )data;

    if ( being_energy_less_than( local, BEING_DEAD + 1 ) == 0 )
    {
        if ( local != brls->being_count )
        {
            memory_copy( ( n_byte * )local, ( n_byte * )brls->being_count, sizeof( simulated_being ) );
        }
        brls->being_count++;
        brls->count++;
    }
    else
    {
        being_remains( group, local );
        if ( local == brls->reference )
        {
            brls->selected_died = 1;
        }
    }
}

being_remove_loop2_struct *being_remove_initial( simulated_group *group )
{
    being_remove_loop2_struct *brls = ( being_remove_loop2_struct * )memory_new( sizeof( being_remove_loop2_struct ) );

    brls->reference = group->select;
    brls->being_count = group->beings;
    brls->selected_died = 0;
    brls->count = 0;

    if ( being_remove_external_value )
    {
        do {}
        while ( being_remove_external_value );
    }

    being_remove_internal_value = 1;
    return brls;
}

void being_remove_internal_clear( void )
{
    being_remove_internal_value = 0;
}



/* ./universe/sim.c */
/****************************************************************

 sim.c

 =============================================================



 ****************************************************************/

#define CONSOLE_REQUIRED
#define CONSOLE_ONLY

#include "toolkit.h"
#include "script.h"
#include "sim.h"
#include "universe.h"
#include "entity.h"

#include <stdio.h>

#include "universe_internal.h"

#ifndef    _WIN32

#include <pthread.h>

#endif

static variable_string    apescript_variable_codes[VARIABLE_MAX] =
{
    /* special "variables" */
    "function",
    "run",

    "while",
    "if",

    /* output only */
    "vector_x",
    "vector_y",

    "random",
    "water_level",

    "biology_area",
    "biology_height",

    "biology_water",
    "biology_moving_sun",

    "biology_total_sun",
    "biology_salt",
    "biology_bush",

    "biology_grass",
    "biology_tree",

    "biology_seaweed",
    "biology_rockpool",
    "biology_beach",

    "biology_insect",
    "biology_mouse",

    "biology_parrot",
    "biology_lizard",

    "biology_eagle",
    "biology_output",

    "hungry",
    "energy",
    "location_z",

    "test_z",
    "is_visible",

    "time",
    "date",

    "current_being",
    "number_beings",

    "location_x",
    "location_y",

    "state",

    "id_number",
    "date_of_birth",

    "is_error",
    "weather",

    "brain_value",        /* special input/output */
    /* actual variables start here */

    "vector_angle",
    "facing",

    "speed",
    "energy_delta",

    "honor",
    "parasites",
    "height",

    "first_name",
    "family_name_one",
    "family_name_two",

    "goal_type",
    "goal_x",
    "goal_y",

    "drive_hunger",
    "drive_social",
    "drive_fatigue",
    "drive_sex",

    "brain_x",
    "brain_y",

    "brain_z",
    "select_being",

    "test_x",
    "test_y",

    "biology_operator",

    "posture",

    "preference_mate_height_male",
    "preference_mate_height_female",
    "preference_mate_pigment_male",
    "preference_mate_pigment_female",
    "preference_mate_hair_male",
    "preference_mate_hair_female",
    "preference_mate_frame_male",
    "preference_mate_frame_female",
    "preference_groom_male",
    "preference_groom_female",
    "preference_anecdote_event",
    "preference_anecdote_affect",
    "preference_chat",

    "attention_actor_index",
    "attention_episode_index",
    "attention_body_index",

    "shout_content",
    "shout_heard",
    "shout_counter",
    "shout_volume",
    "shout_family_first",
    "shout_family_last",

    "social_graph_location_x",
    "social_graph_location_y",
    "social_graph_time",
    "social_graph_date",
    "social_graph_attraction",
    "social_graph_fof",
    "social_graph_familiarity",
    "social_graph_first_name",
    "social_graph_family_first",
    "social_graph_family_last",

    "memory_location_x",
    "memory_location_y",
    "memory_time",
    "memory_date",
    "memory_first_name_zero",
    "memory_family_first_zero",
    "memory_family_last_zero",
    "memory_first_name_one",
    "memory_family_first_one",
    "memory_family_last_one",
    "memory_event",
    "memory_affect",

    "being"
};

n_byte     *offbuffer = 0L;

/* Twice the minimum number of apes the Simulation will allow to run */
#define MIN_BEINGS        4

static  simulated_group group;
static  simulated_timing timing;

static n_interpret *interpret = 0L;

static n_int        sim_new_progress = 0;

static n_int        sim_new_run = 0;

static n_uint       initial_memory_allocated;

static n_int        sim_desire_output = 0;
static n_int        sim_writing_output = 0;

static n_string_block sim_console_output;

#ifndef    _WIN32

static n_int      sim_quit_value = 0;
static pthread_t  threads[2] = {0};
static n_byte     threads_running[2] = {0};

n_int sim_thread_console_quit( void )
{
    return sim_quit_value;
}

n_int sim_new_run_condition( void )
{
    return sim_new_run;
}

static void sim_console_clean_up( void )
{
    if ( ( io_command_line_execution() == 0 ) || sim_quit_value )
    {
        return;
    }

    sim_quit_value = 1;

    command_quit( 0L, 0L, 0L );

    while ( command_executing() ) {}
}


static n_console_input *input_function = &io_console_entry_clean;
static n_console_output *output_function = &io_console_out;

void sim_set_console_input( n_console_input *local_input_function )
{
    if ( local_input_function != 0L )
    {
        input_function = local_input_function;
    }
}

void sim_set_console_output( n_console_output *local_output_function )
{
    if ( local_output_function != 0L )
    {
        output_function = local_output_function;
    }
}

static void *sim_thread_posix( void *threadid )
{
    n_byte *local = ( n_byte * )threadid;
    if ( io_console( &group, ( simulated_console_command * ) control_commands, *input_function, *output_function ) != 0 )
    {
        sim_console_clean_up();
    }
    local[0] = 0;
    pthread_exit( 0L );
}

void sim_thread_console( void )
{
    if ( io_command_line_execution() == 0 )
    {
        return;
    }

    if ( ( threads_running[0] == 0 ) || ( threads_running[1] == 0 ) )
    {
        n_int loop = 0;
        while ( loop < 2 )
        {
            if ( threads_running[loop] == 0 )
            {
                threads_running[loop] = 1;
                pthread_create( &threads[loop], 0L, sim_thread_posix, &threads_running[loop] );
                return;
            }
            loop++;
        }
    }
}

#endif

void sim_console( n_string simulation_filename, n_uint randomise )
{
    printf( "\n *** %sConsole, %s ***\n", SHORT_VERSION_NAME, FULL_DATE );
    printf( "      For a list of commands type 'help'\n\n" );

    io_command_line_execution_set();
    sim_init( KIND_START_UP, randomise, MAP_AREA, 0 );

    if ( simulation_filename )
    {
        if ( io_disk_check( simulation_filename ) != 0 )
        {
            simulated_group *group = sim_group();
            command_open( group, simulation_filename, io_console_out );
            printf( "Simulation file %s loaded\n", simulation_filename );
        }
    }

#ifndef    _WIN32
    do
    {
        sim_thread_console();
    }
    while ( sim_thread_console_quit() == 0 );
#else
    {
        do
        {}
        while ( io_console( &group,
                            ( simulated_console_command * )control_commands,
                            io_console_entry,
                            io_console_out ) == 0 );
    }
#endif
    sim_close();
}


void sim_set_output( n_int value )
{
    sim_desire_output = value;
}

n_int sim_get_writing_output( void )
{
    return sim_writing_output;
}

n_string sim_output_string( void )
{
    return sim_console_output;
}

n_int sim_new( void )
{
    return sim_new_progress;
}

void sim_realtime( n_uint time )
{
    timing.real_time = time;
}

static simulated_being *sim_being_local( void )
{
    simulated_group *group = sim_group();

    if ( group == 0L )
    {
        return 0L;
    }

    return group->select;
}


void sim_move( n_int rel_vel, n_byte kind )
{
    simulated_being *local;
    if ( ( local = sim_being_local() ) )
    {
        being_move( local, rel_vel, kind );
    }
}

void sim_view_options( n_int px, n_int py )
{
    simulated_being *local;
    if ( ( local = sim_being_local() ) )
    {
        n_byte2    location[2];

        location[0] = APESPACE_CONFINED( MAPSPACE_TO_APESPACE( px ) );
        location[1] = APESPACE_CONFINED( MAPSPACE_TO_APESPACE( py ) );

        being_set_location( local, location );
    }
}

#define MAX_POSSIBLE_CONTROL_CHARACTER_X ((2048 - CHARACTER_WIDTH)/CHARACTER_WIDTH)
#define MAX_POSSIBLE_CONTROL_CHARACTER_Y ((2048 - CHARACTER_WIDTH)/CHARACTER_HEIGHT)

static n_byte sim_control_string[255 * 40];
static n_int  sim_control_string_offset[255];

static n_byte sim_control[MAX_POSSIBLE_CONTROL_CHARACTER_X * MAX_POSSIBLE_CONTROL_CHARACTER_Y];

static n_int  sim_control_max_x;

static n_byte sim_control_previous_character;
static n_byte sim_control_character_location;

simulated_timing *sim_timing( void )
{
    return &timing;
}

simulated_group *sim_group( void )
{
    return &group;
}


n_int sim_control_translate( n_int px, n_int py, n_int *character_x, n_int *character_y )
{
    *character_x = ( px - CHARACTER_WIDTH ) / CHARACTER_WIDTH;
    if ( ( *character_x > -1 ) && ( *character_x < MAX_POSSIBLE_CONTROL_CHARACTER_X ) )
    {
        *character_y = ( py - CHARACTER_WIDTH ) / CHARACTER_HEIGHT;
        if ( ( *character_y > -1 ) && ( *character_y < MAX_POSSIBLE_CONTROL_CHARACTER_Y ) )
        {
            return 1;
        }
    }
    return 0;
}

void sim_control_set( n_int px, n_int py, n_byte value, n_byte character )
{
    n_int character_x, character_y;
    if ( sim_control_translate( px, py, &character_x, &character_y ) )
    {
        sim_control[( character_y * sim_control_max_x ) + character_x] = value;
        if ( value != sim_control_previous_character )
        {
            if ( sim_control_previous_character )
            {
                sim_control_string[sim_control_character_location] = 0;
                sim_control_character_location++;
            }
            sim_control_string_offset[sim_control_previous_character] = sim_control_character_location;
            sim_control_previous_character = value;
        }
        sim_control_string[sim_control_character_location] = character;
        sim_control_character_location++;
    }
}

void sim_control_erase( n_int size_x, n_int size_y, n_int max_characters )
{
    n_int max_y = ( size_y - CHARACTER_WIDTH ) / CHARACTER_HEIGHT;
    sim_control_max_x = max_characters;
    sim_control_previous_character = 0;
    sim_control_character_location = 0;
    memory_erase( sim_control, ( n_uint )( sim_control_max_x * max_y ) );
    memory_erase( sim_control_string, 255 * 40 );
}

static simulated_being *sim_select_name( n_string name )
{
    n_uint name_hash = math_hash( ( n_byte * )name, ( n_uint )io_length( name, STRING_BLOCK_SIZE ) );
    n_uint loop = 0;
    simulated_group *group = sim_group();
    simulated_being *local_beings = group->beings;
    while ( loop < group->num )
    {
        n_uint         being_hash;
        simulated_being   *local_being = &local_beings[loop];
        n_string_block local_name;
        being_name_simple( local_being, local_name );
        being_hash = math_hash( ( n_byte * )local_name, ( n_uint )io_length( local_name, STRING_BLOCK_SIZE ) );
        if ( name_hash == being_hash )
        {
            return local_being;
        }
        loop++;
    }
    return 0L;
}

#undef DEBUG_CONTROL_WINDOW

#ifdef DEBUG_CONTROL_WINDOW

static void sim_control_debug_sim_control( n_int py )
{
    n_int y_loop = 0;
    while ( y_loop < py )
    {
        n_int x_loop = 0;
        while ( x_loop < sim_control_max_x )
        {
            printf( "%d,", sim_control[x_loop + ( y_loop * sim_control_max_x )] );
            x_loop++;
        }
        printf( "\n" );
        y_loop++;
    }
}

#endif



void sim_control_regular( n_int px, n_int py )
{
    n_int character_x, character_y;
    if ( sim_control_translate( px, py, &character_x, &character_y ) )
    {
        n_byte value = sim_control[( character_y * sim_control_max_x ) + character_x];
#ifdef DEBUG_CONTROL_WINDOW
        printf( "p(%ld, %ld) c(%ld, %ld) sim_control_max_x %ld value %d\n", px, py, character_x, character_y, sim_control_max_x, value );
        sim_control_debug_sim_control( character_y );
#endif
        if ( value )
        {
            n_int         offset = sim_control_string_offset[value - 1];
            n_string      contral_name = ( n_string )&sim_control_string[offset];
            simulated_being *select_being = sim_select_name( contral_name );
            if ( select_being )
            {
                sim_set_select( select_being );
            }
        }
    }
}

n_int sim_view_regular( n_int px, n_int py )
{
    simulated_being *local;
    if ( ( local = sim_being_local() ) )
    {
        simulated_group *group = sim_group();
        simulated_being *desired_ape = local;
        n_uint  high_squ = 31;
        n_uint    loop = 0;

        while ( loop < group->num )
        {
            simulated_being     *current_ape = &( group->beings[loop] );

            n_int    screen_x = APESPACE_TO_MAPSPACE( being_location_x( current_ape ) ) - px;
            n_int    screen_y = APESPACE_TO_MAPSPACE( being_location_y( current_ape ) ) - py;
            n_uint   current_squ = ( n_uint )( ( screen_x * screen_x ) + ( screen_y * screen_y ) );

            if ( high_squ > current_squ )
            {
                high_squ = current_squ;
                desired_ape = current_ape;
            }
            loop++;
        }

        if ( local != desired_ape )
        {
            sim_set_select( desired_ape );
            return 0;
        }
        return 1;
    }
    return 0;
}

void sim_terrain( n_int sx )
{
    simulated_being *local;
    if ( sx > 0 )
    {
        if ( ( local = sim_being_local() ) )
        {
            being_wander( local, 1 );
        }
    }
    if ( sx <= 0 )
    {
        if ( ( local = sim_being_local() ) )
        {
            being_wander( local, -1 );
        }
    }
}

void sim_rotate( n_int integer_rotation_256 )
{
    simulated_being *local;
    if ( ( local = sim_being_local() ) )
    {
        being_wander( local, integer_rotation_256 );
    }
}

void sim_change_selected( n_byte forwards )
{
    simulated_group *group = sim_group();
    if ( group )
    {
        command_change_selected( group, forwards );
    }
}

static n_int sim_input( void *vcode, n_byte kind, n_int value )
{
    n_individual_interpret *code = ( n_individual_interpret * )vcode;
    n_int *local_vr = code->variable_references;
    simulated_being    *local_being = 0L;
    n_int temp_select = local_vr[ VARIABLE_SELECT_BEING - VARIABLE_VECT_ANGLE ];

    if ( temp_select < 0 )
    {
        return APESCRIPT_ERROR( code, AE_SELECTED_ENTITY_OUT_OF_RANGE );
    }
    {
        n_uint local_select = ( n_uint )temp_select;
        simulated_group *group = sim_group();

        if ( local_select >= group->num )
        {
            return APESCRIPT_ERROR( code, AE_SELECTED_ENTITY_OUT_OF_RANGE );
        }
        local_being = &( group->beings[local_select] );
    }

    switch ( kind )
    {
    case VARIABLE_BRAIN_VALUE:
    {
#ifdef BRAIN_ON
        n_int    current_x = local_vr[VARIABLE_BRAIN_X - VARIABLE_VECT_ANGLE];
        n_int    current_y = local_vr[VARIABLE_BRAIN_Y - VARIABLE_VECT_ANGLE];
        n_int    current_z = local_vr[VARIABLE_BRAIN_Z - VARIABLE_VECT_ANGLE];

        if ( ( value < 0 ) || ( value > 255 ) )
        {
            return APESCRIPT_ERROR( code, AE_VALUE_OUT_OF_RANGE );
        }

        if ( ( current_x < 0 ) || ( current_y < 0 ) || ( current_z < 0 ) ||
                ( current_x > 31 ) || ( current_y > 31 ) || ( current_z > 31 ) )
        {
            return APESCRIPT_ERROR( code, AE_COORDINATES_OUT_OF_RANGE );
        }
        {
            simulated_being *local_being = ( simulated_being * )( ( n_individual_interpret * )code )->interpret_data;
            n_byte *local_brain = being_brain( local_being );
            if ( local_brain != 0L )
            {
                TRACK_BRAIN( local_brain, current_x, current_y, current_z ) = ( n_byte ) value;
            }
        }
        /* add brain value */
#endif
        return 0;
    }

    case VARIABLE_HONOR:
        local_being->delta.honor = ( n_byte ) value;
        break;
    case VARIABLE_PARASITES:
        being_set_parasites( local_being, ( n_byte ) value );
        break;
    case VARIABLE_HEIGHT:
        being_set_height( local_being, value );
        break;

#if 0 /* TODO: This should not be done */
    case VARIABLE_FAMILY_NAME_ONE:
        being_set_family_name( local_being,
                               UNPACK_FAMILY_FIRST_NAME( ( n_byte2 ) value ),
                               UNPACK_FAMILY_SECOND_NAME( being_family_name( local_being ) ) );
        break;
    case VARIABLE_FAMILY_NAME_TWO:
        being_set_family_name( local_being,
                               UNPACK_FAMILY_FIRST_NAME( being_family_name( local_being ) ),
                               UNPACK_FAMILY_SECOND_NAME( ( n_byte2 ) value ) );
        break;
#endif
    case VARIABLE_GOAL_TYPE:
        local_being->delta.goal[0] = ( n_byte ) ( value % 3 );
        break;
    case VARIABLE_GOAL_X:
        local_being->delta.goal[1] = ( n_byte2 ) value;
        break;
    case VARIABLE_GOAL_Y:
        local_being->delta.goal[2] = ( n_byte2 ) value;
        break;
    case VARIABLE_POSTURE:
        being_set_posture( local_being, ( n_byte ) value );
        break;

    case VARIABLE_DRIVE_HUNGER:
        local_being->changes.drives[DRIVE_HUNGER] = ( n_byte ) value;
        break;
    case VARIABLE_DRIVE_SOCIAL:
        local_being->changes.drives[DRIVE_SOCIAL] = ( n_byte ) value;
        break;
    case VARIABLE_DRIVE_FATIGUE:
        local_being->changes.drives[DRIVE_FATIGUE] = ( n_byte ) value;
        break;
    case VARIABLE_DRIVE_SEX:
        local_being->changes.drives[DRIVE_SEX] = ( n_byte ) value;
        break;

    case VARIABLE_PREFERENCE_MATE_HEIGHT_MALE:
        local_being->changes.learned_preference[PREFERENCE_MATE_HEIGHT_MALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_MATE_HEIGHT_FEMALE:
        local_being->changes.learned_preference[PREFERENCE_MATE_HEIGHT_FEMALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_MATE_PIGMENTATION_MALE:
        local_being->changes.learned_preference[PREFERENCE_MATE_PIGMENTATION_MALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_MATE_PIGMENTATION_FEMALE:
        local_being->changes.learned_preference[PREFERENCE_MATE_PIGMENTATION_FEMALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_MATE_HAIR_MALE:
        local_being->changes.learned_preference[PREFERENCE_MATE_HAIR_MALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_MATE_HAIR_FEMALE:
        local_being->changes.learned_preference[PREFERENCE_MATE_HAIR_FEMALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_MATE_FRAME_MALE:
        local_being->changes.learned_preference[PREFERENCE_MATE_FRAME_MALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_MATE_FRAME_FEMALE:
        local_being->changes.learned_preference[PREFERENCE_MATE_FRAME_FEMALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_GROOM_MALE:
        local_being->changes.learned_preference[PREFERENCE_GROOM_MALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_GROOM_FEMALE:
        local_being->changes.learned_preference[PREFERENCE_GROOM_FEMALE] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_ANECDOTE_EVENT_MUTATION:
        local_being->changes.learned_preference[PREFERENCE_ANECDOTE_EVENT_MUTATION] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_ANECDOTE_AFFECT_MUTATION:
        local_being->changes.learned_preference[PREFERENCE_ANECDOTE_AFFECT_MUTATION] = ( n_byte ) value;
        break;
    case VARIABLE_PREFERENCE_CHAT:
        local_being->changes.learned_preference[PREFERENCE_CHAT] = ( n_byte ) value;
        break;
    case VARIABLE_ATTENTION_ACTOR_INDEX:
        being_set_attention( local_being, ATTENTION_ACTOR, value % SOCIAL_SIZE );
        break;
    case VARIABLE_ATTENTION_EPISODE_INDEX:
        being_set_attention( local_being, ATTENTION_EPISODE, value % EPISODIC_SIZE );
        break;
    case VARIABLE_ATTENTION_BODY_INDEX:
        being_set_attention( local_being, ATTENTION_BODY, value % INVENTORY_SIZE );
        break;
    }

    if ( kind > VARIABLE_BRAIN_VALUE )
    {
        local_vr[kind - VARIABLE_VECT_ANGLE] = value;
        return 0;
    }
    return -1; /* where this fails is more important than this failure */
}


static n_int sim_output( void *vcode, void *vindividual, n_byte *kind, n_int *number )
{
    simulated_group *group = sim_group();

    n_interpret *code = ( n_interpret * ) vcode;
    n_individual_interpret *individual = ( n_individual_interpret * ) vindividual;
    n_byte    first_value = kind[0];
    n_byte    second_value = kind[1];
    if ( first_value == APESCRIPT_NUMBER )
    {
        *number = code->number_buffer[second_value];
        return 0;
    }
    if ( ( first_value == APESCRIPT_TEXT ) && ( VARIABLE_SPECIAL( second_value, code ) == 0 ) )
    {
        n_int    *local_vr = individual->variable_references;

        if ( ( second_value >= VARIABLE_BIOLOGY_AREA ) && ( second_value <= VARIABLE_BIOLOGY_EAGLE ) )
        {
            *number = second_value - VARIABLE_BIOLOGY_AREA;
            return 0;
        }

        if ( second_value > VARIABLE_BRAIN_VALUE )
        {
            *number = local_vr[ second_value - VARIABLE_VECT_ANGLE ];
            return 0;
        }

        {
            simulated_being *local_current = ( simulated_being * )individual->interpret_data;
            n_int          local_number = 0;
            n_vect2       local_vector;
            vect2_direction( &local_vector, local_vr[0], 32 );
            switch ( second_value )
            {

            case VARIABLE_VECT_X:
                local_number = local_vector.x;
                break;

            case VARIABLE_VECT_Y:
                local_number = local_vector.y;
                break;
            case VARIABLE_RANDOM:
                local_number = being_random( local_current );
                break;
            case VARIABLE_WATER_LEVEL:
                local_number = land_tide_level();
                break;
            case VARIABLE_HUNGRY:
                local_number = BEING_HUNGRY;
                break;
            case VARIABLE_ENERGY:
            {
                simulated_being *local_being = ( simulated_being * )individual->interpret_data;
                local_number = being_energy( local_being );
            }
            break;
            case VARIABLE_LOCATION_Z:
            case VARIABLE_TEST_Z:
            case VARIABLE_IS_VISIBLE:
            case VARIABLE_BIOLOGY_OUTPUT:
            {
                n_int    quick_x;
                n_int    quick_y;

                if ( second_value == VARIABLE_LOCATION_Z )
                {
                    quick_x = being_location_x( local_current );
                    quick_y = being_location_y( local_current );
                }
                else
                {
                    quick_x = local_vr[VARIABLE_TEST_X - VARIABLE_VECT_ANGLE];
                    quick_y = local_vr[VARIABLE_TEST_Y - VARIABLE_VECT_ANGLE];
                    if ( ( quick_x < 0 ) || ( quick_y < 0 ) ||
                            ( quick_x > APESPACE_BOUNDS ) || ( quick_y > APESPACE_BOUNDS ) )
                    {
                        return APESCRIPT_ERROR( individual, AE_COORDINATES_OUT_OF_RANGE );
                    }
                }

                if ( second_value == VARIABLE_IS_VISIBLE )
                {
                    /* range already checked */
                    simulated_being *local_being = ( simulated_being * )individual->interpret_data;
                    n_vect2 location;
                    location.x = ( n_byte2 )quick_x;
                    location.y = ( n_byte2 )quick_y;
                    local_number = being_line_of_sight( local_being, &location );
                }
                else
                {
                    if ( second_value == VARIABLE_BIOLOGY_OUTPUT )
                    {
                        n_int    int_qu_op = local_vr[VARIABLE_BIOLOGY_OPERATOR - VARIABLE_VECT_ANGLE];
                        if ( ( int_qu_op < 0 ) || ( int_qu_op > ( VARIABLE_BIOLOGY_EAGLE - VARIABLE_BIOLOGY_AREA ) ) )
                        {
                            return APESCRIPT_ERROR( individual, AE_VALUE_OUT_OF_RANGE );
                        }
                        local_number = land_operator_interpolated(
                                           ( n_byte )quick_x, ( n_byte )quick_y, ( n_byte * )&operators[int_qu_op - VARIABLE_BIOLOGY_AREA] );
                    }
                    else
                    {
                        local_number = land_location( quick_x, quick_y );
                    }
                }
            }
            break;

            case VARIABLE_TIME:
                local_number = land_time();
                break;
            case VARIABLE_DATE:
                local_number = land_date();
                break;
            case VARIABLE_CURRENT_BEING:
                local_number = being_index( group, ( simulated_being * )individual->interpret_data );
                break;
            case VARIABLE_NUMBER_BEINGS:
                local_number = ( n_int )group->num;
                break;

            case VARIABLE_IS_ERROR:
                local_number = -1;
                break;

            case VARIABLE_WEATHER:
            {
                n_int    quick_x;
                n_int    quick_y;

                quick_x = local_vr[VARIABLE_TEST_X - VARIABLE_VECT_ANGLE];
                quick_y = local_vr[VARIABLE_TEST_Y - VARIABLE_VECT_ANGLE];
                if ( ( quick_x < 0 ) || ( quick_y < 0 ) ||
                        ( quick_x > APESPACE_BOUNDS ) || ( quick_y > APESPACE_BOUNDS ) )
                {
                    return APESCRIPT_ERROR( individual, AE_COORDINATES_OUT_OF_RANGE );
                }

                local_number = weather_seven_values( quick_x, quick_y );
            }
            break;
            case VARIABLE_BRAIN_VALUE:
            {
#ifdef BRAIN_ON
                n_int    current_x = local_vr[VARIABLE_BRAIN_X - VARIABLE_VECT_ANGLE];
                n_int    current_y = local_vr[VARIABLE_BRAIN_Y - VARIABLE_VECT_ANGLE];
                n_int    current_z = local_vr[VARIABLE_BRAIN_Z - VARIABLE_VECT_ANGLE];

                if ( ( current_x < 0 ) || ( current_y < 0 ) || ( current_z < 0 ) ||
                        ( current_x > 31 ) || ( current_y > 31 ) || ( current_z > 31 ) )
                {
                    return APESCRIPT_ERROR( individual, AE_COORDINATES_OUT_OF_RANGE );
                }
                {
                    simulated_being *local_being = ( simulated_being * )individual->interpret_data;
                    n_byte *local_brain = being_brain( local_being );
                    if ( local_brain != 0L )
                    {
                        local_number = TRACK_BRAIN( local_brain, current_x, current_y, current_z );
                    }
                }
#endif
            }
            break;
            default:
            {
                n_int             temp_select = local_vr[ VARIABLE_SELECT_BEING - VARIABLE_VECT_ANGLE ];
                simulated_being        *local_being = 0L;
                simulated_isocial    *local_social_graph = 0L;
                simulated_isocial     social_graph;
                n_vect2          location_vect;
#ifdef EPISODIC_ON
                simulated_iepisodic    *local_episodic = 0L;
                simulated_iepisodic    episodic;
#endif

                if ( temp_select < 0 )
                {
                    return APESCRIPT_ERROR( individual, AE_SELECTED_ENTITY_OUT_OF_RANGE );
                }
                {
                    n_uint local_select = ( n_uint )temp_select;
                    if ( local_select >= group->num )
                    {
                        return APESCRIPT_ERROR( individual, AE_SELECTED_ENTITY_OUT_OF_RANGE );
                    }
                    local_being = &( group->beings[local_select] );
                    if ( local_being != 0L )
                    {
                        local_social_graph = being_social( local_being );
                        if ( local_social_graph != 0L )
                        {
                            social_graph = local_social_graph[being_attention( local_being, ATTENTION_ACTOR )];
                        }
#ifdef EPISODIC_ON
                        local_episodic = being_episodic( local_being );
                        if ( local_episodic != 0L )
                        {
                            episodic = local_episodic[being_attention( local_being, ATTENTION_EPISODE )];
                        }
#endif
                    }
                }
                /* TODO: if the being knows the other being it may be possible to guess some of these */

                /* if the current being can't see the other being, it can't get this information */

                being_space( local_being, &location_vect );

                if ( being_line_of_sight( local_current, &location_vect ) == 0 )
                {
                    local_number = -1;
                }
                else if ( ( local_being != 0L ) && ( local_social_graph != 0L ) )
                {
                    switch ( second_value )
                    {

                    case VARIABLE_HONOR:
                        local_number = being_honor( local_being );
                        break;
                    case VARIABLE_PARASITES:
                        local_number = being_parasites( local_being );
                        break;
                    case VARIABLE_HEIGHT:
                        local_number = being_height( local_being );
                        break;
                    case VARIABLE_FIRST_NAME:
                        local_number = being_gender_name( local_being );
                        break;
#if 0 /* TODO: This should not be done */
                    case VARIABLE_FAMILY_NAME_ONE:
                        local_number = UNPACK_FAMILY_FIRST_NAME( being_family_name( local_being ) );
                        break;
                    case VARIABLE_FAMILY_NAME_TWO:
                        local_number = UNPACK_FAMILY_SECOND_NAME( being_family_name( local_being ) );
                        break;
#endif
                    case VARIABLE_GOAL_TYPE:
                        local_number = local_being->delta.goal[0];
                        break;
                    case VARIABLE_GOAL_X:
                        local_number = local_being->delta.goal[1];
                        break;
                    case VARIABLE_GOAL_Y:
                        local_number = local_being->delta.goal[2];
                        break;
                    case VARIABLE_POSTURE:
                        local_number = being_posture( local_being );
                        break;

                    case VARIABLE_DRIVE_HUNGER:
                        local_number = local_being->changes.drives[DRIVE_HUNGER];
                        break;
                    case VARIABLE_DRIVE_SOCIAL:
                        local_number = local_being->changes.drives[DRIVE_SOCIAL];
                        break;
                    case VARIABLE_DRIVE_FATIGUE:
                        local_number = local_being->changes.drives[DRIVE_FATIGUE];
                        break;
                    case VARIABLE_DRIVE_SEX:
                        local_number = local_being->changes.drives[DRIVE_SEX];
                        break;

                    case    VARIABLE_LOCATION_X:
                        local_number = being_location_x( local_being );
                        break;

                    case    VARIABLE_LOCATION_Y:
                        local_number = being_location_y( local_being );
                        break;

                    case    VARIABLE_ID_NUMBER:
                        local_number = GET_I( local_being );
                        break;

                    case    VARIABLE_DATE_OF_BIRTH:
                        local_number = being_dob( local_being );
                        break;
                    case    VARIABLE_STATE:
                        local_number = being_state( local_being );
                        break;
                    case    VARIABLE_PREFERENCE_MATE_HEIGHT_MALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_MATE_HEIGHT_MALE];
                        break;
                    case    VARIABLE_PREFERENCE_MATE_HEIGHT_FEMALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_MATE_HEIGHT_FEMALE];
                        break;
                    case    VARIABLE_PREFERENCE_MATE_PIGMENTATION_MALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_MATE_PIGMENTATION_MALE];
                        break;
                    case    VARIABLE_PREFERENCE_MATE_PIGMENTATION_FEMALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_MATE_PIGMENTATION_FEMALE];
                        break;
                    case    VARIABLE_PREFERENCE_MATE_HAIR_MALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_MATE_HAIR_MALE];
                        break;
                    case    VARIABLE_PREFERENCE_MATE_HAIR_FEMALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_MATE_HAIR_FEMALE];
                        break;
                    case    VARIABLE_PREFERENCE_MATE_FRAME_MALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_MATE_FRAME_MALE];
                        break;
                    case    VARIABLE_PREFERENCE_MATE_FRAME_FEMALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_MATE_FRAME_FEMALE];
                        break;
                    case    VARIABLE_PREFERENCE_GROOM_MALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_GROOM_MALE];
                        break;
                    case    VARIABLE_PREFERENCE_GROOM_FEMALE:
                        local_number = local_being->changes.learned_preference[PREFERENCE_GROOM_FEMALE];
                        break;
                    case    VARIABLE_PREFERENCE_ANECDOTE_EVENT_MUTATION:
                        local_number = local_being->changes.learned_preference[PREFERENCE_ANECDOTE_EVENT_MUTATION];
                        break;
                    case    VARIABLE_PREFERENCE_ANECDOTE_AFFECT_MUTATION:
                        local_number = local_being->changes.learned_preference[PREFERENCE_ANECDOTE_AFFECT_MUTATION];
                        break;
                    case    VARIABLE_PREFERENCE_CHAT:
                        local_number = local_being->changes.learned_preference[PREFERENCE_CHAT];
                        break;
                    case    VARIABLE_ATTENTION_ACTOR_INDEX:
                        local_number = being_attention( local_being, ATTENTION_ACTOR );
                        break;
                    case    VARIABLE_ATTENTION_EPISODE_INDEX:
                        local_number = being_attention( local_being, ATTENTION_EPISODE );
                        break;
                    case    VARIABLE_ATTENTION_BODY_INDEX:
                        local_number = being_attention( local_being, ATTENTION_BODY );
                        break;
                    case    VARIABLE_SHOUT_CONTENT:
                        local_number = local_being->changes.shout[SHOUT_CONTENT];
                        break;
                    case    VARIABLE_SHOUT_HEARD:
                        local_number = local_being->changes.shout[SHOUT_HEARD];
                        break;
                    case    VARIABLE_SHOUT_CTR:
                        local_number = local_being->changes.shout[SHOUT_CTR];
                        break;
                    case    VARIABLE_SHOUT_VOLUME:
                        local_number = local_being->changes.shout[SHOUT_VOLUME];
                        break;
                    case    VARIABLE_SHOUT_FAMILY0:
                        local_number = local_being->changes.shout[SHOUT_FAMILY0];
                        break;
                    case    VARIABLE_SHOUT_FAMILY1:
                        local_number = local_being->changes.shout[SHOUT_FAMILY1];
                        break;

                    case VARIABLE_SOCIAL_GRAPH_LOCATION_X:
                        local_number = social_graph.space_time.location[0];
                        break;
                    case VARIABLE_SOCIAL_GRAPH_LOCATION_Y:
                        local_number = social_graph.space_time.location[1];
                        break;
                    case VARIABLE_SOCIAL_GRAPH_TIME:
                        local_number = social_graph.space_time.time;
                        break;
                    case VARIABLE_SOCIAL_GRAPH_DATE:
                        local_number = social_graph.space_time.date;
                        break;
                    case VARIABLE_SOCIAL_GRAPH_ATTRACTION:
                        local_number = social_graph.attraction;
                        break;
                    case VARIABLE_SOCIAL_GRAPH_FOF:
                        local_number =
                            ( n_int )social_graph.friend_foe -
                            ( n_int )social_respect_mean( local_being );
                        break;
                    case VARIABLE_SOCIAL_GRAPH_FAMILIARITY:
                        local_number = social_graph.familiarity;
                        break;
                    case VARIABLE_MEMORY_FIRST_NAME:
                        local_number = social_graph.first_name[BEING_MET];
                        break;
#if 0 /* TODO: This should not be done */
                    case VARIABLE_MEMORY_FAMILY_NAME_ONE:
                        local_number = UNPACK_FAMILY_FIRST_NAME( social_graph.family_name[BEING_MET] );
                        break;
                    case VARIABLE_MEMORY_FAMILY_NAME_TWO:
                        local_number = UNPACK_FAMILY_SECOND_NAME( social_graph.family_name[BEING_MET] );
                        break;
#endif
#ifdef EPISODIC_ON
                    case VARIABLE_MEMORY_LOCATION_X:
                        local_number = episodic.space_time.location[0];
                        break;
                    case VARIABLE_MEMORY_LOCATION_Y:
                        local_number = episodic.space_time.location[1];
                        break;
                    case VARIABLE_MEMORY_TIME:
                        local_number = episodic.space_time.time;
                        break;
                    case VARIABLE_MEMORY_DATE:
                        local_number = episodic.space_time.date;
                        break;
                    case VARIABLE_MEMORY_FIRST_NAME0:
                        local_number = episodic.first_name[0];
                        break;
                    case VARIABLE_MEMORY_FIRST_NAME1:
                        local_number = episodic.first_name[BEING_MET];
                        break;
#if 0 /* TODO: This should not be done */
                    case VARIABLE_MEMORY_FAMILY_NAME_ONE0:
                        local_number = UNPACK_FAMILY_FIRST_NAME( episodic.family_name[0] );
                        break;
                    case VARIABLE_MEMORY_FAMILY_NAME_TWO0:
                        local_number = UNPACK_FAMILY_SECOND_NAME( episodic.family_name[0] );
                        break;
                    case VARIABLE_MEMORY_FAMILY_NAME_ONE1:
                        local_number = UNPACK_FAMILY_FIRST_NAME( episodic.family_name[BEING_MET] );
                        break;
                    case VARIABLE_MEMORY_FAMILY_NAME_TWO1:
                        local_number = UNPACK_FAMILY_SECOND_NAME( episodic.family_name[BEING_MET] );
                        break;
#endif
                    case VARIABLE_MEMORY_EVENT:
                        local_number = episodic.event;
                        break;
                    case VARIABLE_MEMORY_AFFECT:
                        local_number = episodic.affect - EPISODIC_AFFECT_ZERO;
                        break;
#endif
                    }
                }
            }

            break;
            }
            /* put variable cross here */
            *number = local_number;
            return 0;
        }
    }
    return -1; /* where this fails is more important than this failure */
}


n_int     sim_interpret( n_file *input_file )
{
    input_file->size = input_file->location;
    input_file->location = 0;

    interpret = parse_convert( input_file, VARIABLE_BEING, ( variable_string * )apescript_variable_codes );

    if ( interpret == 0L )
    {
        return -1;
    }
    else
    {
        SC_DEBUG_ON( group.select ); /* turn on debugging after script loading */
    }

    interpret->sc_input  = &sim_input;
    interpret->sc_output = &sim_output;

    interpret->input_greater   = VARIABLE_WEATHER;
    interpret->special_less    = VARIABLE_VECT_X;
    return 0;
}

#ifdef BRAIN_ON
static void sim_brain_loop( simulated_group *group, simulated_being *local_being, void *data )
{
    n_byte2 local_brain_state[3];

    if ( being_brainstates( local_being, ( local_being->delta.awake == 0 ), local_brain_state ) )
    {
        n_byte            *local_brain = being_brain( local_being );
        if ( local_brain != 0L )
        {
            being_brain_cycle( local_brain, local_brain_state );
        }
    }
}
#endif


#ifdef BRAINCODE_ON

static void sim_brain_dialogue_loop( simulated_group *group, simulated_being *local_being, void *data )
{
    n_byte     awake = 1;
    n_byte    *local_internal = being_braincode_internal( local_being );
    n_byte    *local_external = being_braincode_external( local_being );
    if ( local_being->delta.awake == 0 )
    {
        awake = 0;
    }
    /* This should be independent of the brainstate/cognitive simulation code */
    brain_dialogue( group, awake, local_being, local_being, local_internal, local_external, being_random( local_being ) % SOCIAL_SIZE );
    brain_dialogue( group, awake, local_being, local_being, local_external, local_internal, being_random( local_being ) % SOCIAL_SIZE );
}

#endif


static void sim_being_awake_loop_no_sim( simulated_being *local_being )
{
    n_byte awake_condition = being_awake( local_being );
    local_being->delta.awake = awake_condition;

#ifdef DEBUG_LACK_OF_MOVEMENT
    being_register_movement( local_being, "awake condition" );
#endif
}

static void sim_being_cycle( simulated_group *group, simulated_being *local_being, void *data )
{
    if ( local_being->delta.awake == 0 )
    {
        return;
    }

    being_cycle_awake( group, local_being );
}

static void sim_start_conditions( void *vindividual, void *structure, void *data )
{
    n_individual_interpret *individual = ( n_individual_interpret * )vindividual;
    n_int        *variables = individual->variable_references;
    simulated_being *local_being = ( simulated_being * )data;

    variables[VARIABLE_FACING - VARIABLE_VECT_ANGLE] = being_facing( local_being );
    variables[VARIABLE_SPEED - VARIABLE_VECT_ANGLE] =  being_speed( local_being );
    variables[VARIABLE_ENERGY_DELTA - VARIABLE_VECT_ANGLE] = 0;

    variables[VARIABLE_SELECT_BEING - VARIABLE_VECT_ANGLE] = being_index( sim_group(), local_being );

    variables[VARIABLE_HEIGHT - VARIABLE_VECT_ANGLE] = being_height( local_being );
    variables[VARIABLE_GOAL_TYPE - VARIABLE_VECT_ANGLE] = local_being->delta.goal[0];
    variables[VARIABLE_GOAL_X - VARIABLE_VECT_ANGLE] = local_being->delta.goal[1];
    variables[VARIABLE_GOAL_Y - VARIABLE_VECT_ANGLE] = local_being->delta.goal[2];
    variables[VARIABLE_DRIVE_HUNGER - VARIABLE_VECT_ANGLE] = local_being->changes.drives[DRIVE_HUNGER];
    variables[VARIABLE_DRIVE_SOCIAL - VARIABLE_VECT_ANGLE] = local_being->changes.drives[DRIVE_SOCIAL];
    variables[VARIABLE_DRIVE_FATIGUE - VARIABLE_VECT_ANGLE] = local_being->changes.drives[DRIVE_FATIGUE];
    variables[VARIABLE_DRIVE_SEX - VARIABLE_VECT_ANGLE] = local_being->changes.drives[DRIVE_SEX];
    variables[VARIABLE_FAMILY_NAME_ONE - VARIABLE_VECT_ANGLE] = being_family_first_name( local_being );
    variables[VARIABLE_FAMILY_NAME_TWO - VARIABLE_VECT_ANGLE] = being_family_second_name( local_being );
    variables[VARIABLE_HONOR - VARIABLE_VECT_ANGLE] = being_honor( local_being );
    variables[VARIABLE_PARASITES - VARIABLE_VECT_ANGLE] = being_parasites( local_being );
}

static void sim_end_conditions( void *vindividual, void *structure, void *data )
{
    n_individual_interpret *individual = ( n_individual_interpret * )vindividual;
    n_int        *variables = individual->variable_references;
    simulated_being *local_being = ( simulated_being * )data;

    n_int    local_facing = variables[VARIABLE_FACING - VARIABLE_VECT_ANGLE];
    n_int    local_speed  = variables[VARIABLE_SPEED  - VARIABLE_VECT_ANGLE];
    n_int    local_energy_delta = variables[VARIABLE_ENERGY_DELTA - VARIABLE_VECT_ANGLE];
    n_int    local_height = variables[VARIABLE_HEIGHT - VARIABLE_VECT_ANGLE];
    n_int    local_goal_type = variables[VARIABLE_GOAL_TYPE - VARIABLE_VECT_ANGLE];
    n_int    local_goal_x = variables[VARIABLE_GOAL_X - VARIABLE_VECT_ANGLE];
    n_int    local_goal_y = variables[VARIABLE_GOAL_Y - VARIABLE_VECT_ANGLE];
    n_int    local_drive_hunger = variables[VARIABLE_DRIVE_HUNGER - VARIABLE_VECT_ANGLE];
    n_int    local_drive_social = variables[VARIABLE_DRIVE_SOCIAL - VARIABLE_VECT_ANGLE];
    n_int    local_drive_fatigue = variables[VARIABLE_DRIVE_FATIGUE - VARIABLE_VECT_ANGLE];
    n_int    local_drive_sex = variables[VARIABLE_DRIVE_SEX - VARIABLE_VECT_ANGLE];
    n_int    local_family_name1 = variables[VARIABLE_FAMILY_NAME_ONE - VARIABLE_VECT_ANGLE];
    n_int    local_family_name2 = variables[VARIABLE_FAMILY_NAME_TWO - VARIABLE_VECT_ANGLE];

    n_int    local_honor = variables[VARIABLE_HONOR - VARIABLE_VECT_ANGLE];
    n_int    local_parasites = variables[VARIABLE_PARASITES - VARIABLE_VECT_ANGLE];

    if ( local_facing < 0 )
    {
        local_facing = 255 - ( ( 0 - local_facing ) & 255 );
    }
    else
    {
        local_facing = local_facing & 255;
    }

    if ( local_speed > 39 )
    {
        local_speed = 39;
    }
    if ( local_speed < 0 )
    {
        local_speed = 0;
    }

    being_wander( local_being, local_facing - being_facing( local_being ) );

    being_set_speed( local_being, ( n_byte ) local_speed );
    being_energy_delta( local_being, local_energy_delta );

    being_set_height( local_being, local_height );

    if ( local_goal_type != GOAL_NONE )
    {
        local_being->delta.goal[0]  = ( n_byte2 )local_goal_type;
        local_being->delta.goal[1]  = ( n_byte2 )local_goal_x;
        local_being->delta.goal[2]  = ( n_byte2 )local_goal_y;
        local_being->delta.goal[3]  = GOAL_TIMEOUT;

        local_being->braindata.script_overrides |= OVERRIDE_GOAL;
    }
    if ( local_drive_hunger > -1 )
    {
        local_being->changes.drives[DRIVE_HUNGER]  = ( n_byte )local_drive_hunger;
    }
    if ( local_drive_social > -1 )
    {
        local_being->changes.drives[DRIVE_SOCIAL]  = ( n_byte )local_drive_social;
    }
    if ( local_drive_fatigue > -1 )
    {
        local_being->changes.drives[DRIVE_FATIGUE]  = ( n_byte )local_drive_fatigue;
    }
    if ( local_drive_sex > -1 )
    {
        local_being->changes.drives[DRIVE_SEX]  = ( n_byte )local_drive_sex;
    }
    being_set_family_name( local_being, ( n_byte )local_family_name1, ( n_byte )local_family_name2 );

    local_being->delta.honor = ( n_byte )local_honor;
    being_set_parasites( local_being, ( n_byte )local_parasites );
}



static void sim_being_interpret( simulated_group *group, simulated_being *local_being, void *data )
{
    n_individual_interpret individual;

    interpret_individual( &individual );

    if ( local_being->delta.awake == 0 )
    {
        return;
    }

    if ( interpret == 0L )
    {
        return;
    }

    if ( interpret_cycle( interpret, &individual, -1,
                          group->beings, local_being,
                          &sim_start_conditions, &sim_end_conditions ) == -1 )
    {
        interpret_cleanup( &interpret );
    }
}


static void sim_time( simulated_group *group )
{
    simulated_timing *timing = sim_timing();

    timing->count_cycles += group->num;

    timing->count_frames ++;

    if ( ( timing->real_time - timing->last_time ) > 60 )
    {
        timing->last_time = timing->real_time;
        timing->delta_cycles = timing->count_cycles;
        timing->delta_frames = timing->count_frames;
        timing->count_cycles = 0;
        timing->count_frames = 0;
    }
}

#if 1

#define PROCESSING_HEAVY_WEIGHT    (4)
#define PROCESSING_MIDDLE_WEIGHT   (8)
#define PROCESSING_WELTER_WEIGHT  (16)
#define PROCESSING_LIGHT_WEIGHT   (32)
#define PROCESSING_FEATHER_WEIGHT (64)

#else

#define PROCESSING_HEAVY_WEIGHT    (3)
#define PROCESSING_MIDDLE_WEIGHT   (7)
#define PROCESSING_WELTER_WEIGHT  (17)
#define PROCESSING_LIGHT_WEIGHT   (31)
#define PROCESSING_FEATHER_WEIGHT (67)

#endif

static void sim_being_remove_final( simulated_group *group, being_remove_loop2_struct **brls )
{
    group->num = ( *brls )->count;
    if ( ( *brls )->selected_died )
    {
        if ( ( *brls )->count )
        {
            sim_set_select( group->beings );
        }
        else
        {
            sim_set_select( 0L );
        }
    }

    if ( ( *brls )->count == 0 )
    {
        if ( sim_new_run == 0 )
        {
            ( void )SHOW_ERROR( "No Apes remain start new run" );
            sim_new_run = 1;
        }
    }
    being_remove_internal_clear();
    memory_free( ( void ** )brls );
}


void sim_update_output( void )
{
    if ( sim_desire_output == 0 )
    {
        return;
    }

    if ( group.select == 0L )
    {
        return;
    }
    sim_writing_output = 1;
    memory_erase( ( n_byte * )sim_console_output, STRING_BLOCK_SIZE );
    watch_control( &group, being_get_select_name( &group ), group.select, sim_console_output );
    sim_writing_output = 0;
}

static KIND_OF_USE local_execution = KIND_PRE_STARTUP;

void sim_cycle( void )
{
    if ( local_execution == KIND_PRE_STARTUP )
    {
        return;
    }
    if ( local_execution != KIND_NOTHING_TO_RUN )
    {
        if ( local_execution != KIND_MEMORY_SETUP )
        {
            if ( local_execution != KIND_NEW_APES )
            {
                land_clear( local_execution, AGE_OF_MATURITY );
#ifdef LAND_ON
                land_init();
                land_init_high_def( 1 );
                land_tide();
#endif
            }
            if ( local_execution != KIND_LOAD_FILE )
            {
                n_byte2 local_random[2];
                n_byte2 *genetics = land_genetics();
                local_random[0] = genetics[0];
                local_random[1] = genetics[1];

                math_random3( local_random );

#ifdef WEATHER_ON
                weather_init();
#endif
                /* Sets the number of Simulated Apes initially created, and creates them */
                group.num = being_init_group( group.beings, local_random, group.max >> 1, group.max );
            }
        }

        sim_set_select( group.beings );

        sim_new_progress = 0;
        local_execution = KIND_NOTHING_TO_RUN;
    }


    n_int       max_honor = 0;

    land_cycle();
#ifdef WEATHER_ON
    weather_cycle();
#endif

    loop_being_no_sim_no_data( group.beings, group.num, sim_being_awake_loop_no_sim );
    loop_being_no_sim_no_data( group.beings, group.num, being_cycle_universal );

    if ( interpret )
    {
        loop_being( &group, sim_being_interpret, PROCESSING_WELTER_WEIGHT );
    }
    else
    {
        /** Listen for any shouts */
        loop_being( &group, being_listen, PROCESSING_FEATHER_WEIGHT );
#ifdef EPISODIC_ON
        loop_being_no_sim_no_data( group.beings, group.num, episodic_cycle_no_sim );
#endif
        loop_being( &group, sim_being_cycle, PROCESSING_MIDDLE_WEIGHT );
        loop_being( &group, drives_cycle, PROCESSING_LIGHT_WEIGHT );
    }

    if ( land_time() & 1 )
    {
#ifdef BRAIN_ON
        loop_being( &group, sim_brain_loop, PROCESSING_WELTER_WEIGHT );
#endif
    }
#ifdef BRAINCODE_ON
    else
    {
        loop_being( &group, sim_brain_dialogue_loop, PROCESSING_MIDDLE_WEIGHT );
    }
#endif

    loop_being_no_sim( group.beings, group.num, being_tidy_loop_no_sim, &max_honor );

    loop_being( &group, social_initial_loop, PROCESSING_LIGHT_WEIGHT );

    if ( max_honor )
    {
        loop_being_no_sim_no_data( group.beings, group.num, being_recalibrate_honor_loop_no_sim );
    }

    loop_being_no_sim_no_data( group.beings, group.num, social_secondary_loop_no_sim );

    {
        n_string_block selected_name = {0};
        n_int          selected_lives = 1;
        being_remove_loop2_struct *brls = being_remove_initial( &group );
        if ( group.select )
        {
            being_name_simple( group.select, selected_name );
        }
        if ( group.ext_death != 0L )
        {
            loop_no_thread( &group, 0L, being_remove_loop1, 0L );
        }
        loop_no_thread( &group, 0L, being_remove_loop2, brls );
        selected_lives = brls->selected_died == 0;
        sim_being_remove_final( &group, &brls );

        loop_being_no_sim_no_data( group.beings, group.num, being_speed_advance );

        if ( selected_lives )
        {
            simulated_being *new_select = sim_select_name( selected_name );
            if ( new_select != group.select )
            {
                sim_set_select( new_select );
            }
        }
    }

    sim_time( &group );
}

#define    MINIMAL_ALLOCATION    ((512*512)+(TERRAIN_WINDOW_AREA)+(CONTROL_WINDOW_AREA)+(sizeof(simulated_being) * MIN_BEINGS)+sizeof(simulated_remains)+1)

#define MAXIMUM_ALLOCATION  (MINIMAL_ALLOCATION + (sizeof(simulated_being) * 400))

n_uint sim_memory_allocated( n_int max )
{
    if ( max )
    {
        return MAXIMUM_ALLOCATION;
    }
    else
    {
        return initial_memory_allocated;
    }
}

static n_int being_memory( simulated_group *group, n_byte *buffer, n_uint *location, n_uint memory_available )
{
    n_uint  lpx = 0;

    group->max = LARGE_SIM;

    while ( lpx < group->max )
    {
        simulated_being *local_being = &( group->beings[ lpx ] );
        memory_erase( ( n_byte * )local_being, sizeof( simulated_being ) );
        lpx ++;
    }
    return 0;
}

static n_int sim_memory( n_uint offscreen_size )
{
    n_uint    current_location = 0;
    n_uint  memory_allocated = MAXIMUM_ALLOCATION;

    offbuffer = memory_new_range( offscreen_size + MINIMAL_ALLOCATION, &memory_allocated );

    if ( offbuffer == 0L )
    {
        return SHOW_ERROR( "Memory not available" );
    }

    memory_erase( offbuffer, memory_allocated );
    memory_erase( ( void * )&group.remains, sizeof( simulated_remains ) );

    return being_memory( &group, offbuffer, &current_location, memory_allocated );
}

static void debug_birth_event( simulated_being *born, simulated_being *mother, void *sim )
{
    n_string_block name, mother_name, father_name;
    being_name_simple( born, name );
    being_name_simple( mother, mother_name );
    being_name_byte2( mother->changes.father_name[0], mother->changes.father_name[1], father_name );
    printf( "*** Born: %s (Mother: %s Father: %s)\n", name, mother_name, father_name );
}

static void debug_death_event( simulated_being *deceased, void *sim )
{
    n_string_block name;
    being_name_simple( deceased, name );
    printf( "*** Dead: %s\n", name );
}

void *sim_init( KIND_OF_USE kind, n_uint randomise, n_uint offscreen_size, n_uint landbuffer_size )
{
    n_byte2    local_random[2];

    sim_writing_output = 1;
    sim_new_progress = 1;

    if ( kind == KIND_NEW_SIMULATION )
    {
        if ( interpret )
        {
            interpret_cleanup( &interpret );
            interpret = 0L;
        }
        memory_execute(io_command_line_execution_set);
    }
    timing.real_time = randomise;
    timing.last_time = randomise;

#ifdef FIXED_RANDOM_SIM
    randomise = FIXED_RANDOM_SIM;
#endif

    timing.delta_cycles = 0;
    timing.count_cycles = 0;
    timing.delta_frames = 0;
    timing.count_frames = 0;

#if 1
    group.ext_birth = &debug_birth_event;
    group.ext_death = &debug_death_event;
#else
    group.ext_birth = 0L;
    group.ext_death = 0L;
#endif

    if ( ( kind == KIND_START_UP ) || ( kind == KIND_MEMORY_SETUP ) )
    {
        if ( sim_memory( offscreen_size ) != 0 )
        {
            return 0L;
        }
    }

    local_random[0] = ( n_byte2 )( randomise >> 16 ) & 0xffff;
    local_random[1] = ( n_byte2 )( randomise & 0xffff );

    math_random3( local_random );

    if ( ( kind != KIND_LOAD_FILE ) && ( kind != KIND_MEMORY_SETUP ) )
    {
        land_seed_genetics( local_random );
    }

    being_remains_init( &( group.remains ) ); /* Eventually this should be captured through the file handling and moved into the code below */

    local_execution = kind;
    return ( ( void * ) offbuffer );
}

void sim_close( void )
{
    command_quit( 0L, 0L, 0L );
    io_console_quit();
#ifndef _WIN32
    sim_console_clean_up();
#endif
    interpret_cleanup( &interpret );
    memory_free( ( void ** ) &offbuffer );
    /*death_record_file_cleanup();*/
}

void sim_set_select( simulated_being *select )
{
    group.select = select;
}

static void sim_flood_loop( simulated_group *group, simulated_being *local, void *data )
{
    n_vect2 location;

    being_space( local, &location );
    spacetime_convert_to_map( &location );

    if ( land_location_vect( &location ) < 160 )
    {
        being_dead( local );
    }
}

void sim_flood( void )
{
    loop_no_thread( &group, 0L, sim_flood_loop, 0L );
}

void sim_healthy_carrier( void )
{
    n_uint  loop = ( group.num >> 2 );

    while ( loop < group.num )
    {
        simulated_being *local = &group.beings[loop];
        being_dead( local );
        loop++;
    }
}


/* ./universe/transfer.c */
/****************************************************************

 transfer.c

 =============================================================



 ****************************************************************/

#include "entity.h"

#include "universe_internal.h"
#include "universe.h"

/* does not appear to be used here */

void transfer_debug_csv( n_file *fil, n_byte initial )
{
    simulated_group *group = sim_group();

    io_write_csv( fil, ( n_byte * )( &( group->beings[0] ) ), simulated_file_format, FIL_BEI, initial );
}

/* provide an output file buffer to be written */
static void transfer_land( n_file *tranfer_out, simulated_group *group, simulated_file_entry *format )
{
    n_byte2    loc_signature[2] = {( n_byte2 )SIMULATED_APE_SIGNATURE, ( n_byte2 )VERSION_NUMBER};

#ifdef USE_FIL_VER
    io_write_buff( tranfer_out, loc_signature, format, FIL_VER, 0L );
#endif
#ifdef USE_FIL_LAN
    /*
    io_write_buff( tranfer_out, land_ptr(), format, FIL_LAN, 0L ); Needs to be fixed */
#endif
#ifdef USE_FIL_WEA
    io_write_buff( tranfer_out, value->weather, format, FIL_WEA, 0L );
#endif
}

static void transfer_being( n_file *tranfer_out, simulated_group *group, n_int being, simulated_file_entry *format )
{
#ifdef USE_FIL_SOE
    n_int loop = ( SOCIAL_SIZE * being );
    n_int loop_end = loop + SOCIAL_SIZE;
#endif
#ifdef USE_FIL_EPI
    n_int loop_episodic = ( EPISODIC_SIZE * being );
    n_int loop_episodic_end = loop + EPISODIC_SIZE;
#endif

#ifdef USE_FIL_BEI
    io_write_buff( tranfer_out, &( group->beings[being] ), format, FIL_BEI, 0L );
#endif
#ifdef USE_FIL_SOE
    while ( loop < loop_end )
    {
        io_write_buff( tranfer_out, being_social( &( value->beings[being] ) ), format, FIL_SOE, &brain_three_byte_command );
        loop++;
    }
#endif
#ifdef USE_FIL_EPI
    while ( loop_episodic < loop_episodic_end )
    {
        io_write_buff( tranfer_out, being_episodic( &( value->beings[being] ) ), format, FIL_EPI, 0L );
        loop_episodic++;
    }
#endif
}

static n_object *transfer_land_obj( void )
{
    n_object *simulated_iland = object_number( 0L, "date", land_date() );
    n_byte2   *genetics_values = land_genetics();
    n_array   *land_genetics = array_number( genetics_values[0] );
    array_add( land_genetics, array_number( genetics_values[1] ) );

    object_array( simulated_iland, "genetics", land_genetics );
    object_number( simulated_iland, "time", land_time() );
    return simulated_iland;
}

#if 0
static n_object *transfer_being_spacetime_obj( n_spacetime *value )
{
    n_object *simulated_ispacetime = object_number( 0L, "date", value->date );
    n_array   *simulated_ilocation = array_number( value->location[0] );
    array_add( simulated_ilocation, array_number( value->location[1] ) );
    object_array( simulated_ispacetime, "location", simulated_ilocation );
    object_number( simulated_ispacetime, "time", value->time );
    return simulated_ispacetime;
}
#endif

static n_object *transfer_being_constant_obj( simulated_being_constant *constant )
{
    n_int genetic_count = 1;
    n_object *simulated_being_contant = object_number( 0L, "date_of_birth", constant->date_of_birth );
    n_array *generation = array_number( constant->generation_min );
    n_array *genetics = array_number( constant->genetics[0] );
    while ( genetic_count < CHROMOSOMES )
    {
        array_add( genetics, array_number( constant->genetics[genetic_count++] ) );
    }
    object_array( simulated_being_contant, "genetics", genetics );

    array_add( generation, array_number( constant->generation_max ) );
    object_array( simulated_being_contant, "generation_range", generation );

    return simulated_being_contant;
}


static n_object *transfer_being_delta_obj( simulated_being_delta *delta )
{
    n_object *simulated_being_delta = object_number( 0L, "direction_facing", delta->direction_facing );
    n_array   *location = array_number( delta->location[0] );
    n_array   *seed = array_number( delta->random_seed[0] );
    n_array   *goal = array_number( delta->goal[0] );
    n_array   *social_coord = array_number( delta->social_coord_x );

    array_add( location, array_number( delta->location[1] ) );

    array_add( seed, array_number( delta->random_seed[1] ) );

    array_add( goal, array_number( delta->goal[1] ) );
    array_add( goal, array_number( delta->goal[2] ) );
    array_add( goal, array_number( delta->goal[3] ) );

    array_add( social_coord, array_number( delta->social_coord_y ) );
    array_add( social_coord, array_number( delta->social_coord_nx ) );
    array_add( social_coord, array_number( delta->social_coord_ny ) );

    object_array( simulated_being_delta, "location", location );

    object_number( simulated_being_delta, "velocity", delta->velocity[0] );
    object_number( simulated_being_delta, "stored_energy", delta->stored_energy );

    object_array( simulated_being_delta, "random_seed", seed );

    object_number( simulated_being_delta, "macro_state", delta->macro_state );
    object_number( simulated_being_delta, "parasites", delta->parasites );
    object_number( simulated_being_delta, "honor", delta->honor );
    object_number( simulated_being_delta, "crowding", delta->crowding );
    object_number( simulated_being_delta, "height", delta->height );
    object_number( simulated_being_delta, "mass", delta->mass );
    object_number( simulated_being_delta, "posture", delta->posture );

    object_array( simulated_being_delta, "goal", goal );
    object_array( simulated_being_delta, "social_coord", social_coord );

    return simulated_being_delta;
}

static n_object *transfer_being_obj( simulated_being *being )
{
    n_object *simulated_being = 0L;
    n_string_block simple_name;
    being_name_simple( being, simple_name );
    simulated_being = object_string( 0L, "name", simple_name );
    object_object( simulated_being, "delta", transfer_being_delta_obj( &( being->delta ) ) );
    object_object( simulated_being, "constant", transfer_being_constant_obj( &( being->constant ) ) );
    return simulated_being;
}


static n_object *transfer_sim_obj( void )
{
    n_object *simulated_isim_identifier = object_number( 0L, "signature", SIMULATED_APE_SIGNATURE );
    object_number( simulated_isim_identifier, "version number", VERSION_NUMBER );
    object_string( simulated_isim_identifier, "copyright", FULL_VERSION_COPYRIGHT );
    object_string( simulated_isim_identifier, "date", FULL_DATE );
    return simulated_isim_identifier;
}

n_file *tranfer_out_json( void )
{
    n_file *output_file = 0L;
    simulated_group *group = sim_group();

    n_object *simulation_object = object_object( 0L, "information", transfer_sim_obj() );

    object_object( simulation_object, "land", transfer_land_obj() );

    if ( group->num > 0 )
    {
        n_uint        count = 1;
        simulated_being *local_beings = group->beings;
        n_object    *being_object = transfer_being_obj( &( local_beings[0] ) );
        n_array     *beings = array_object( being_object );
        while ( count < group->num )
        {
            being_object = transfer_being_obj( &( local_beings[count++] ) );
            array_add( beings, array_object( being_object ) );
        }
        object_array( simulation_object, "beings", beings );
    }

    output_file = unknown_json( simulation_object, OBJECT_OBJECT );

    obj_free( &simulation_object );

    return output_file;
}

n_file *tranfer_out( void )
{
    simulated_group *group = sim_group();

    n_file           *returnFile = io_file_new();
    n_int              loop = 0;
    n_string fluff[5] = {SHORT_VERSION_NAME, FULL_DATE, COPYRIGHT_DATE, COPYRIGHT_NAME, COPYRIGHT_FOLLOW };

    if ( returnFile == 0L )
    {
        return 0L;
    }
    if ( returnFile->data == 0L )
    {
        memory_free( ( void ** )&returnFile );
        return 0L;
    }

    io_write_buff( returnFile, fluff, 0L, FILE_COPYRIGHT, 0L );

    transfer_land( returnFile, group, ( simulated_file_entry * )simulated_file_format );

    while ( loop < ( n_int )( group->num ) )
    {
        transfer_being( returnFile, group, loop, ( simulated_file_entry * )simulated_file_format );
        loop++;
    }

    /* TODO: Brain block */
    return returnFile;
}

n_int    tranfer_in( n_file *input_file )
{
    n_int  ret_val;
    n_byte *temp_store = 0L;
    n_uint ape_count = 0;
    n_uint social_count = 0;
    n_uint episodic_count = 0;

    simulated_group *group = sim_group();
    n_uint  size_buffer = io_find_size_data( ( simulated_file_entry * )simulated_file_format );

    temp_store = ( n_byte * )memory_new( size_buffer );

    if ( temp_store == 0L )
    {
        return SHOW_ERROR( "No temporary storage memory available" );
    }

    io_whitespace( input_file );

    input_file->location = 0;

    ret_val = io_read_buff( input_file, temp_store, simulated_file_format );

    if ( ret_val != FIL_VER ) /* signature must be first */
    {
        return SHOW_ERROR( "Signature not first in file" );
    }

    {
        n_byte2    *signature = ( n_byte2 * )temp_store;

        if ( signature[0] != SIMULATED_APE_SIGNATURE ) /* not a Simulated Ape file */
        {
            return SHOW_ERROR( "Not a Simulated Ape File" );
        }

        if ( signature[1] > VERSION_NUMBER ) /* file version greater than this version */
        {
            return SHOW_ERROR( "File newer than Simulation" );
        }
    }

    do
    {
        n_byte *temp = 0L;
        ret_val = io_read_buff( input_file, temp_store, simulated_file_format );
        if ( ret_val == -1 )
        {
            SHOW_ERROR( "Failure in file load" );
        }
        if ( ret_val < FILE_EOF )
        {
            n_uint    loop_end = 0;

            switch ( ret_val )
            {
            case FIL_LAN:
            /*
                temp = ( n_byte * )land_ptr();
                loop_end = 11; Needs to be fixed */
                break;
            case FIL_BEI:
                temp = ( n_byte * ) & ( group->beings[ape_count] );
                loop_end = sizeof( simulated_being );
                break;
            case FIL_SOE:
            {
                simulated_isocial *local_social = being_social( &( group->beings[ape_count] ) );
                temp = ( n_byte * )( &local_social[social_count] );
                loop_end = sizeof( simulated_isocial );
            }
            break;
            case FIL_EPI:
            {
                simulated_iepisodic *local_episodic = being_episodic( &( group->beings[ape_count] ) );
                temp = ( n_byte * )( &local_episodic[episodic_count] );
                loop_end = sizeof( simulated_iepisodic );
            }
            break;
            default:
            {
                return SHOW_ERROR( "Unknown file kind" ); /*unknown kind*/
            }
            break;
            }
            if ( temp != 0L )
            {
                memory_copy( temp_store, temp, loop_end );
            }
            if ( ret_val == FIL_BEI )
            {
                ape_count ++;
                if ( ape_count == group->max )
                {
                    group->num = ape_count;
                    return SHOW_ERROR( "Too many apes for memory" );
                }
            }
            if ( ret_val == FIL_SOE )
            {
                social_count ++;
                if ( social_count == ( group->max * SOCIAL_SIZE ) )
                {
                    group->num = ape_count;
                    return SHOW_ERROR( "Too many social graph events for memory" );
                }
            }
            if ( ret_val == FIL_EPI )
            {
                episodic_count ++;
                if ( episodic_count == ( group->max * EPISODIC_SIZE ) )
                {
                    group->num = ape_count;
                    return SHOW_ERROR( "Too many episodic events for memory" );
                }
            }

        }

    }
    while ( ret_val < FILE_EOF );

    if ( ret_val == FILE_EOF )
    {
        group->num = ape_count;
        return 0;
    }
    return SHOW_ERROR( "Process file failed" );
}



/* ./longterm.c */
/****************************************************************

    longterm.c

    =============================================================

 Copyright 1996-2025 Tom Barbalet. All rights reserved.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    This software is a continuing work of Tom Barbalet, begun on
    13 June 1996. No apes or cats were harmed in the writing of
    this software.

****************************************************************/

#define _CRT_SECURE_NO_WARNINGS

#define CONSOLE_ONLY /* Please maintain this define until after ALIFE XIII July 22nd */
#define CONSOLE_REQUIRED
#undef  AUDIT_FILE

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#ifndef _WIN32
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>
#endif

#include "toolkit.h"
#include "sim.h"
#include "script.h"
#include "universe.h"


#ifdef AUDIT_FILE
#include "universe_internal.h"
#endif

n_string_block simulation_filename;

#ifdef AUDIT_FILE

static void audit_print_offset( n_byte *start, n_byte *point, char *text )
{
    printf( "%s %ld\n", text, ( unsigned long )( point - start ) );
}

static void audit_compart_offset()
{
    simulated_being local;
    n_byte *start = ( n_byte * )&local;
    audit_print_offset( start, ( n_byte * ) & ( local.macro_state ), "macro_state" );
    audit_print_offset( start, ( n_byte * ) & ( local.crowding ), "crowding" );
    audit_print_offset( start, ( n_byte * ) & ( local.parasites ), "parasites" );
    audit_print_offset( start, ( n_byte * ) & ( local.honor ), "honor" );

    audit_print_offset( start, ( n_byte * ) & ( local.date_of_conception[0] ), "date_of_conception[0]" );

    audit_print_offset( start, ( n_byte * ) & ( local.fetal_genetics[0] ), "fetal_genetics[0]" );
    audit_print_offset( start, ( n_byte * ) & ( local.genetics[0] ), "genetics[0]" );

    audit_print_offset( start, ( n_byte * ) & ( local.father_name[0] ), "father_name[0]" );

    audit_print_offset( start, ( n_byte * ) & ( local.social_x ), "social_x" );

    audit_print_offset( start, ( n_byte * ) & ( local.drives[0] ), "drives[0]" );
    audit_print_offset( start, ( n_byte * ) & ( local.goal[0] ), "goal[0]" );
    audit_print_offset( start, ( n_byte * ) & ( local.learned_preference[0] ), "learned_preference[0]" );

    audit_print_offset( start, ( n_byte * ) & ( local.generation_min ), "generation_min" );

    audit_print_offset( start, ( n_byte * ) & ( local.territory[0] ), "territory[0]" );
    audit_print_offset( start, ( n_byte * ) & ( local.immune_system ), "immune_system[0]" );

    audit_print_offset( start, ( n_byte * ) & ( local.vessel[0] ), "vessel[0]" );
    audit_print_offset( start, ( n_byte * ) & ( local.metabolism[0] ), "metabolism[0]" );

    audit_print_offset( start, ( n_byte * ) & ( local.braincode_register[0] ), "braincode_register[0]" );
    audit_print_offset( start, ( n_byte * ) & ( local.brainprobe[0] ), "brainprobe[0]" );

    audit_print_offset( start, ( n_byte * ) & ( local.vessel[0] ), "vessel[0]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[1] ), "vessel[1]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[2] ), "vessel[2]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[3] ), "vessel[3]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[4] ), "vessel[4]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[5] ), "vessel[5]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[6] ), "vessel[6]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[7] ), "vessel[7]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[8] ), "vessel[8]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[9] ), "vessel[9]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[10] ), "vessel[10]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[11] ), "vessel[11]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[12] ), "vessel[12]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[13] ), "vessel[13]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[14] ), "vessel[14]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[15] ), "vessel[15]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[16] ), "vessel[16]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[17] ), "vessel[17]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[18] ), "vessel[18]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[19] ), "vessel[19]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[20] ), "vessel[20]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[21] ), "vessel[21]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[22] ), "vessel[22]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[23] ), "vessel[23]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[24] ), "vessel[24]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[25] ), "vessel[25]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[26] ), "vessel[26]" );
    audit_print_offset( start, ( n_byte * ) & ( local.vessel[27] ), "vessel[27]" );

    audit_print_offset( start, ( n_byte * ) & ( local.brain ), "brain" );
}

static void audit( void )
{

    printf( "sizeof(n_byte) %d\n", ( int )sizeof( n_byte ) );
    printf( "sizeof(n_byte2) %d\n", ( int )sizeof( n_byte2 ) );
    printf( "sizeof(n_uint) %d\n", ( int )sizeof( n_uint ) );

    printf( "sizeof(n_byte    *)) %d \n", ( int )sizeof( n_byte * ) );
    /*
    io_audit_file(simulated_file_format, FIL_VER);
    io_audit_file(simulated_file_format, FIL_LAN); */
    io_audit_file( simulated_file_format, FIL_BEI ); /*
    io_audit_file(simulated_file_format, FIL_SOE);
    io_audit_file(simulated_file_format, FIL_EPI); */
    audit_compart_offset();
}

#endif

n_int draw_error( n_constant_string error_text, n_constant_string location, n_int line_number )
{
    printf( "ERROR: %s @ %s %ld\n", ( const n_string ) error_text, location, line_number );
    return -1;
}

int command_line_run( void )
{
    sprintf( simulation_filename, "%s", "realtime.txt" );

#ifdef AUDIT_FILE
    audit();
#endif

    srand( ( unsigned int ) time( NULL ) );
    sim_console( simulation_filename, rand() );

    return ( 1 );
}

#ifndef _WIN32

static int make_periodic( unsigned int period, sigset_t *alarm_sig )
{
    int ret;
    struct itimerval value;

    /* Block SIGALRM in this thread */
    sigemptyset( alarm_sig );
    sigaddset( alarm_sig, SIGALRM );
    pthread_sigmask( SIG_BLOCK, alarm_sig, NULL );

    /* Set the timer to go off after the first period and then
     repetitively */
    value.it_value.tv_sec = period / 1000000;
    value.it_value.tv_usec = period % 1000000;
    value.it_interval.tv_sec = period / 1000000;
    value.it_interval.tv_usec = period % 1000000;
    ret = setitimer( ITIMER_REAL, &value, NULL );
    if ( ret != 0 )
    {
        perror( "Failed to set timer" );
    }
    return ret;
}

static void wait_period( sigset_t *alarm_sig )
{
    int sig;
    /* Wait for the next SIGALRM */
    sigwait( alarm_sig, &sig );
}

#define TIMING_CONST_MS 100

static n_uint count = 0;

static void *periodic_thread( void *arg )
{
    sigset_t alarm_sig;
    simulated_group *group;
    make_periodic( 1000 * TIMING_CONST_MS, &alarm_sig );
    while ( 1 )
    {
        group = sim_group();
        sim_cycle();
        count++;
        if ( ( count & 2047 ) == 0 )
        {
            printf( "count is %ld\n", count );
        }
        if ( group->num == 0 )
        {
            printf( "new run at %ld\n", count );

            sim_init( 1, rand(), MAP_AREA, 0 );
        }

        wait_period( &alarm_sig );
    }
    return NULL;
}

#endif

int main( int argc, n_string argv[] )
{
    return command_line_run();
}

