<HTML><HEAD><TITLE>ApeScript Notes</TITLE></HEAD><BODY bgcolor="#ffffff"><FONT FACE="Arial,Geneva,Helvetica" SIZE=3><CENTER><A HREF="apescript_sim.html">Scripting the Simulation</A> - <A HREF="index.html">Contents</A></CENTER><HR><A NAME="IND"><H2>ApeScript Notes</H2></A><A HREF="#S1">Variables and Functions</A><BR><A HREF="#S2">If, While and Metaphysics</A><BR><A HREF="#S3">Locks</A><BR><A HREF="#S4">Xtreme ApeScript - Case/Switch</A><BR><A HREF="#S5">Xtreme ApeScript - Brain as Memory</A><BR><A HREF="#S6">Debugging the Monkey</A><BR><A HREF="#S7">Variables and Scripts</A><BR><A HREF="#S8">Parsing and Interpreting</A><P><A NAME="S1"><B>Variables and Functions</B></A> ( <A HREF="#IND">Notes Index</A> )<P>ApeScript is a procedural scripting language developed for use with the <A HREF="http://www.nobleape.com/sim/">Noble Ape Simulation</A>. ApeScript is small, memory efficient and highly modular and could easily be ported to other applications. This document describes using both ApeScript and the ApeScript implementation specific to the Noble Ape Simulation.<P>ApeScript requires an initial execution function which must be located at the physical end of the script file. In the case of the Noble Ape Simulation this function is the being function.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( being ) {<BR>&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>All other functions must be defined above the being function. There is no function ordering other than placing the being function at the end of the file. Similarly, all other functions can be referenced as variables. This will be expanded on later in the document. But it is important to note that the being function can not be referenced as a variable.<P>Variables and functions in ApeScript can be made up of any letter or underscore. Numbers or other characters can not be included in variables or functions. It may prove easier as you are learning ApeScript to think of functions as a particular kind of variable. In fact, ApeScript will define the function variable as the point in the interpreted scripting code where the function is defined.<P>Functions (other than being) are called by the keyword run. For example;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( second_time ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( first_time );<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( first_time) {<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( being ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( second_time );<BR>&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>Similarly, the following would also work;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( second_time ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( which_one );<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( first_time) {<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( being ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_one = first_time;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( second_time );<BR>&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>Here you see the variable which_one being set at the function location before it is run in second_time. Normal variables can be defined in a single instance between 0 and 65535. This is deemed the normal operating range of definition in ApeScript. You can define a variable;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;big_minus = 0 - 65535;</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>But as you will see this is the limit in a single line.<P>A variable through use can reach the 32-bit signed min/max of -2147483648 to 2147483647. This can be achieved through cumulative operations.<P>ApeScript allows a wide variety of mathematical and logical operators. The only limit (currently) in ApeScript is that a line of code can only contain two input variables, one operator, one equality and one output variable.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;output_value = input_one + input_two;</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>The number of operators may be subject to change in the future. Your best source for the current operators is the Noble Ape Manual. Similarly it is possible that the negative definition without the zero subtraction or multiple operators used. All this is possible in the future.<P><A NAME="S2"><B>If, While and Metaphysics</B></A> ( <A HREF="#IND">Notes Index</A> )<P>A little naming convention from international English. Brackets refer to this ( and this ).Braces refer to this { and this }. The only use of brackets is run, function, if and while. Similarly, the only place where braces can be used is function, if and while. The check for if and while are based on the same initial premise;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;if ( condition ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( will_be_run );<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;while ( condition ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( will_be_run );<BR>&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>If condition doesn't equal zero, then will_be_run will be run in the if and while operator. The while operator will continue to execute will_be_run until condition equals zero. If condition is zero, then will_be_run will not be executed.<P>The following example shows both if and while being used in a practical context.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( being ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ( loop < number_beings ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( current_being != loop ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select_being = loop;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_x = location_x;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_y = location_y;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select_being = current_being;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other_visible = is_visible;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop = loop + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>This being function identifies each visible being to the current_being.<P>It's important to take a step back and ask the question - what is the being function?<P>Put simply, the being function is run per Noble Ape in the Simulation. The ape that is currently being run is identified by the variable current_being. Initially - at the start of the being function - select_being is set to current_being. However through the script execution select_being can be set to anything from 0 to number_beings - 1.<P>Through developing ApeScript in the <A HREF="http://www.nobleape.com/sim/">Noble Ape Simulation</A>, you should always reference the Simulation linking variables explained in<A HREF="apescript_sim.html">ApeScript and the Noble Ape Simulation</A>.<P>This page describes the current version of the Simulation's special ApeScript variables and how they link to the Simulation. If you develop ApeScript, print this page. If you have any questions from the page email them directly to tom at nobleape dot com. To date, the <A HREF="apescript_sim.html">ApeScript and the Noble Ape Simulation</A> page has been rewritten based on additional information requests. This digression aside, you need to understand what each of the variables mean. The term, output, means you can't set anything to this variable. It is only useful on the right hand side of an equality assignment.<P>Scanning down to the Being section of the <A HREF="apescript_sim.html">ApeScript and the Noble Ape Simulation</A> page, you will note that three variables aren't based on select_being. Of the variables that can be changed in the being (aside from the brain values) only facing, speed and energy can be changed. This means that you can only change the direction facing, the speed and the energy an ape has. Not the Ape's location directly. The location is changed through the direction facing and the speed set. The brain values relate to current_being. Obviously one being can not effect the brain of another being directly.<P>Consider the metaphysics of the individual being functions and the being functions when run together in a single time cycle.<P><A NAME="S3"><B>Locks</B></A> ( <A HREF="#IND">Notes Index</A> )<P>As things are currently ApeScript is an interpreted language. It is integrated in the <A HREF="http://www.nobleape.com/sim/">Noble Ape Simulation</A> but there are still conditions that will cause ApeScript to substantially slow down. Particular variables take longer time to process than others. The biology_output variable is relatively time consuming. is_visible is extremely time consuming. Getting and setting brain_value may be slightly more time consuming than addition.<P>If you experience lock conditions, rework the code to create fewer loops over less variables. Be mindful of the variables that are really pseudo variables (like is_visible or biology_output) which in fact result in substantial code in the Simulation being run to produce a single value.<P><A NAME="S4"><B>Xtreme ApeScript - Case/Switch</B></A> ( <A HREF="#IND">Notes Index</A> )<P>There are some properties of ApeScript that may prove useful in practical applications. Whilst the ApeScript specification is simple, the underlying elements of the specification allow a number of features common to more complex languages.<P>The switch statement is common in many languages - it allows from an input variable a number of possible choices based on that variable. Consider the case with four possibilities.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( case_one ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b * 56;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( case_two ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b - 56;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( case_three ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b + 56;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( case_four ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( being ){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_b = time;<BR><P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = time & 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_function = case_two - case_one;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function * offset_function;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function + case_one;<BR><P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( which_function );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_result = number_a;<BR>&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>This works because each case function decomposes to the same number of interpreted bytes. This idea of interpreted bytes is rather subtle, but it is the basis of functions as variables representing points in the interpreted bytes. Now suppose there are a variety of lengths in each function. The functions do distinctly different things and can't be guaranteed to have the same number of interpreted bytes.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( actual_one ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( actual_two );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_a + 26;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( actual_two ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b * 234;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( actual_three ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b - 10;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_a * 21;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_a + 127;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( actual_four ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( actual_one);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_a * 20;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( direct_one ){ run ( actual_one ); }<BR>&nbsp;&nbsp;&nbsp;function ( direct_two ){ run ( actual_two ); }<BR>&nbsp;&nbsp;&nbsp;function ( direct_three ){ run ( actual_three ); }<BR>&nbsp;&nbsp;&nbsp;function ( direct_four ){ run ( actual_four ); }<P>&nbsp;&nbsp;&nbsp;function ( being ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_b = time;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = time & 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_function = direct_two - direct_one;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function * offset_function;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function + direct_one;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( which_function );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_result = number_a;<BR>&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>Here the functions of the same number of bytes is put in a tight block. This block has the same number of bytes but they refer to different functions that have different numbers of bytes. Applications of if functions may be preferable;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( being ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_b = time;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = time & 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( which_function == 0){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pick_function = actual_one;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( which_function == 1){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pick_function = actual_two;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( which_function == 2){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pick_function = actual_three;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( which_function == 3){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pick_function = actual_four;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( pick_function );<BR>&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3><A NAME="S5"><B>Xtreme ApeScript - Brain as Memory</B></A> ( <A HREF="#IND">Notes Index</A> )<P>For folks looking for traditional array memory, the brain memory provides this for ApeScript. The initial complication is that the Noble Ape brain memory has a time and space based function to move information through it. To stop this effect the brain constants (that govern this spreading of information through the brain) can be set to zero through the variable file. Looking at the Noble Ape source code;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;/* from sim/core/being.c - NOT ApeScript */<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_int	local_a = constants<0>;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_int	local_c = constants<2>;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_int	local_b = constants<1> + local_c;<P>&nbsp;&nbsp;&nbsp;((((aver)*local_a)+((brain)*local_b)-((old_brain)*local_c))>>10)</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>Thus the variable files should contain the following brn per being;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;brn = 0, 1024, 0, 0, 1024, 0;</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>Each memory entry is a single byte. If you want to put larger variables into memory, such as the full range of an ApeScript variable, you will need to write code to spread the variable through the bytes. For example;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( offset_to_brain ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_offset = memory_location * 4;<BR><P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_x = memory_offset & 31;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_offset = memory_offset / 32;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_y = memory_offset & 31;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_offset = memory_offset / 32;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_z = memory_offset & 31;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( number_to_brain ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( offset_to_brain );<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_offset = memory_location * 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_offset = memory_offset & 31;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;negative_one = 0 - 1;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( memory_number < 0 ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_is_negative = 128;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = negative_one - memory_number;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( number > negative_one ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_is_negative = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = memory_number;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_value = absolute_number & 255;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number / 256;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_x = memory_offset + 1;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_value = absolute_number & 255;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number / 256;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_x = memory_offset + 2;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_value = absolute_number & 255;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number / 256;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_x = memory_offset + 3;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_value = absolute_number + number_is_negative;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( brain_to_number ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( offset_to_brain );<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_offset = memory_location * 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_offset = memory_offset & 31;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;negative_one = 0 - 1;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_x = memory_offset + 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_is_negative = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = brain_value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( absolute_number > 127 ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_negative = 128;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number - 128;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number * 256;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_x = memory_offset + 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number + brain_value;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number * 256;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_x = memory_offset + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number + brain_value;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number * 256;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brain_x = memory_offset;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = absolute_number + brain_value;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( is_negative == 128 ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absolute_number = negative_one - absolute_number;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_number = absolute_number;<BR>&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>This script can be further optimized for particular kinds of data you want to put in memory. Not to mention, optimized for the time it takes to get and set a particular number in memory.<P><A NAME="S6"><B>Debugging the Monkey</B></A> ( <A HREF="#IND">Notes Index</A> )<P>ApeScript has a debugger built into it. Currently this provides a file of the Script code being run for a single cycle of the first being being simulated. Using some of the example code from the first set of notes.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( second_time ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( which_one );<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( first_time ) {<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( being ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_one = first_time;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( second_time );<BR>&nbsp;&nbsp;&nbsp;} </TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>Is run through the Simulation and the debug output is produced;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function( being ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_one = 24 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( second_time ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( which_one ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>What this shows is the numerical representation of the first_time function set to which_one. The function second_time is run, then which_one is run successfully. Relatively uneventful. But an accurate indication of the code run.<P>Looking at this code;<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( case_one ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b * 56;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( case_two ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b - 56;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( case_three ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b + 56;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( case_four ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( being ){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_b = time;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = time & 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_function = case_two - case_one;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function * offset_function; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function + case_one;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( which_function );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_result = number_a;<BR>&nbsp;&nbsp;&nbsp;} </TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>This may require a stronger leap of faith for a new ApeScript developer than the first example. Let's look at the debug output.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function( being ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_b = 867 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 3 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_function = 19 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 57 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 66 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( which_function ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = 867 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_result = 867 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>Quite luckily the time & 3 resulted in 3 for which_function. Relatively uneventful with a straight pass-through for number_a = number_b; But still, the debug output is quite useful to verify the method works and the output is exactly as expected in terms of picking the correct function.<P>Looking at the slightly more complex version of the switch/case.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( actual_one ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( actual_two );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_a + 26;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( actual_two ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b * 234;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( actual_three ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b - 10;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_a * 21;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_a + 127;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( actual_four ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run ( actual_one );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_a * 20;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( direct_one ){ run ( actual_one ); }<BR>&nbsp;&nbsp;&nbsp;function ( direct_two ){ run ( actual_two ); }<BR>&nbsp;&nbsp;&nbsp;function ( direct_three ){ run ( actual_three ); }<BR>&nbsp;&nbsp;&nbsp;function ( direct_four ){ run ( actual_four ); } <P>&nbsp;&nbsp;&nbsp;function ( being ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_b = time; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = time & 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_function = direct_two - direct_one;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function * offset_function;<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function + direct_one; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( which_function );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_result = number_a;<BR>&nbsp;&nbsp;&nbsp;} </TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>Looking at the debug output.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function( being ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_b = 942 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 2 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_function = 15 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 30 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 151 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( which_function ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( actual_three ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = 932 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = 19572 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = 19699 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_result = 19699 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>This is as to be expected. Whilst the switch case of 2 is relatively uneventful, it clearly follows the correct function actual_three and the result comes through.<P>Let's try something interesting... a clear error case.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function ( buffer_backstep ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_z = number_y + number_a;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_z * 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_y;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = 3;<BR>&nbsp;&nbsp;&nbsp;}<P>&nbsp;&nbsp;&nbsp;function ( case_one ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b * 56;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( case_two ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_a = number_b - 56;<BR>&nbsp;&nbsp;&nbsp;} <P>&nbsp;&nbsp;&nbsp;function ( being ){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_b = time;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = time & 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_function = case_two - case_one;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function * offset_function; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function + case_one;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* this is clear function abuse, but what will happen? */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random_error = random & 7;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random_error = random_error + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = which_function - random_error;<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( which_function );<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_result = number_a;<BR>&nbsp;&nbsp;&nbsp;} </TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>This is similar to the switch case, but we are mucking up the function to be run by subtracting a random error from 1 to 8.<P><CENTER><TABLE WIDTH=90%><TD ALIGN=LEFT VALIGN=TOP BGCOLOR="#eeeeee"><FONT FACE="Courier, Courier New" SIZE=4>&nbsp;&nbsp;&nbsp;function( being ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_b = 757 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 1 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_function = 19 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 19 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 72 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random_error = 3 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random_error = 4 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which_function = 68 ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run( which_function ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;< ERROR : Input variable without equals ></TABLE></CENTER><P><FONT FACE="Arial,Geneva,Helvetica" SIZE=3>As you can see, an error is fired and recorded in the debug output. This is very useful for novice and expert ApeScript authors alike. You will find yourself writing long bits of code and the debugger may be the only indication that the code won't run correctly.<P>ApeScript allows you to create variables on the fly. Please consider including additional debug values that immediately identify the section of the script information.<P><A NAME="S7"><B>Variables and Scripts</B></A> ( <A HREF="#IND">Notes Index</A> )<P>The Noble Ape Simulation currently has two types of files it reads and one type of file it writes. The Simulation reads and writes variable files. These contain the immediate variables bar the 64k of brain values. These values may be included with future variable input and output files, but at this time, there is little practical use for such large additions to the relatively minimalist variable files. The variable file format is described in great detail <A HREF="file.html">here</A>.<P>In addition to variable files used for input and output, there are script files. These script files are the subject of the ApeScript Notes documents. It is important to think about how the variable files and the scripting files can work together - both in terms of debugging and testing.<P>For example, if you want a particular part of a script to run with a specific ape, the apes ID number (id_number based on select_being) should be the best test for running specific code for a specific ape.<P><A NAME="S8"><B>Parsing and Interpreting</B></A> ( <A HREF="#IND">Notes Index</A> )<P>It is important to note that the current version of ApeScript has two parts - a parser and an interpreter. The parser takes the text information present in the script file and converts it to ApeScript interpretable byte codes. Aside from actual code, these byte codes contain the constant number values used through the script.<P>It is possible to generate a parser error such as using an unrecognizable character or a set of symbols that are not recognized, ++ for example, that won't result in an error that will be shown in a debug file. Please be mindful of this. If you require this information to feature in a debug file, please make contact (tom at nobleape dot com).<P>To explain the logic of why parser errors are not treated as interpreter errors comes in part from the handling of variable files. If a variable file fails to load, it shouldn't display an error. Users may load dud files accidentally and it should effect the Simulation's running in any way. Similarly, a parser error typically indicates that the file loaded is not a script file and not that the logic of the script file will be compromised.<P>In the case of genuine errors, ApeScript will either produce an error or in the case of extreme logic errors - like an infinite loop for example - the interpreter will allow the user to quit or create a new simulation environment.<P><A HREF="http://www.nobleape.com/tom/">Tom Barbalet</A>, 6 October 2005.<HR><CENTER><A HREF="apescript_sim.html">Scripting the Simulation</A> - <A HREF="index.html">Contents</A></CENTER></BODY></HTML>